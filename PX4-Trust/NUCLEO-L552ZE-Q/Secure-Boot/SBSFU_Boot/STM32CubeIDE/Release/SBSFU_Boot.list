
SBSFU_Boot.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .provision    000005d2  0c001000  0c001000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .BL2_NoHdp_Code 000003fe  0c00c800  0c00c800  0001c800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00009638  0c001800  0c001800  00001800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .ARM.exidx    00000008  0c00ae38  0c00ae38  0000ae38  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .copy.table   00000018  0c00ae40  0c00ae40  0000ae40  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .zero.table   00000010  0c00ae58  0c00ae58  0000ae58  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000100  30030000  0c00ae68  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000bdd4  30030100  0c00af68  00010100  2**2
                  ALLOC
  8 .msp_stack    00001404  3003bed4  0c016d3c  0002bed4  2**0
                  ALLOC
  9 .heap         00000000  3003d2d8  3003d2d8  0001cbfe  2**0
                  CONTENTS
 10 .ARM.attributes 00000036  00000000  00000000  0001cbfe  2**0
                  CONTENTS, READONLY
 11 .comment      00000053  00000000  00000000  0001cc34  2**0
                  CONTENTS, READONLY
 12 .debug_info   0003b1a2  00000000  00000000  0001cc87  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00008c1a  00000000  00000000  00057e29  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    0001ac2f  00000000  00000000  00060a43  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001638  00000000  00000000  0007b672  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00002018  00000000  00000000  0007ccaa  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00030635  00000000  00000000  0007ecc2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0002cf3a  00000000  00000000  000af2f7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00112d9d  00000000  00000000  000dc231  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  000046a8  00000000  00000000  001eefd0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .stab         00000084  00000000  00000000  001f3678  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .stabstr      00000117  00000000  00000000  001f36fc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .BL2_NoHdp_Code:

0c00c800 <mpu_armv8m_enable>:
               (MPU_ARMV8M_MAIR_ATTR_CODE_VAL << MPU_MAIR0_Attr1_Pos) |
               (MPU_ARMV8M_MAIR_ATTR_DATA_VAL << MPU_MAIR0_Attr2_Pos) |
               (MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL << MPU_MAIR0_Attr3_Pos);

  mpu->CTRL =
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
 c00c800:	2900      	cmp	r1, #0
 c00c802:	bf18      	it	ne
 c00c804:	2104      	movne	r1, #4
    (hfnmi_en   ? MPU_CTRL_HFNMIENA_Msk   : 0);
 c00c806:	2a00      	cmp	r2, #0
 c00c808:	bf18      	it	ne
 c00c80a:	2202      	movne	r2, #2
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c00c80c:	6803      	ldr	r3, [r0, #0]
  mpu->MAIR0 = (MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL << MPU_MAIR0_Attr0_Pos) |
 c00c80e:	4807      	ldr	r0, [pc, #28]	; (c00c82c <mpu_armv8m_enable+0x2c>)
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
 c00c810:	4311      	orrs	r1, r2
  mpu->MAIR0 = (MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL << MPU_MAIR0_Attr0_Pos) |
 c00c812:	6318      	str	r0, [r3, #48]	; 0x30
  mpu->CTRL =
 c00c814:	6059      	str	r1, [r3, #4]

  /*Ensure all configuration is written before enable*/

  mpu->CTRL |= MPU_CTRL_ENABLE_Msk;
 c00c816:	685a      	ldr	r2, [r3, #4]
 c00c818:	f042 0201 	orr.w	r2, r2, #1
 c00c81c:	605a      	str	r2, [r3, #4]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 c00c81e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c00c822:	f3bf 8f6f 	isb	sy

  /* Enable MPU before next instruction */
  __DSB();
  __ISB();
  return MPU_ARMV8M_OK;
}
 c00c826:	2000      	movs	r0, #0
 c00c828:	4770      	bx	lr
 c00c82a:	bf00      	nop
 c00c82c:	44ffaa04 	.word	0x44ffaa04

0c00c830 <mpu_armv8m_region_enable>:
  enum mpu_armv8m_error_t ret_val = MPU_ARMV8M_OK;
  uint32_t base_cfg;
  uint32_t limit_cfg;

  /*FIXME : Add complete error checking*/
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c00c830:	684a      	ldr	r2, [r1, #4]
{
 c00c832:	b510      	push	{r4, lr}
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c00c834:	f012 041f 	ands.w	r4, r2, #31
 c00c838:	d125      	bne.n	c00c886 <mpu_armv8m_region_enable+0x56>
  /* region_limit doesn't need to be aligned but the scatter
   * file needs to be setup to ensure that partitions do not overlap.
   */
  /* don't disable MPU */

  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 c00c83a:	780b      	ldrb	r3, [r1, #0]
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c00c83c:	6800      	ldr	r0, [r0, #0]

  /* This 0s the lower bits of the base address */
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
 c00c83e:	f022 021f 	bic.w	r2, r2, #31
  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 c00c842:	6083      	str	r3, [r0, #8]
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c00c844:	7c0b      	ldrb	r3, [r1, #16]
 c00c846:	f003 0301 	and.w	r3, r3, #1
 c00c84a:	4313      	orrs	r3, r2
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
 c00c84c:	7c8a      	ldrb	r2, [r1, #18]
 c00c84e:	00d2      	lsls	r2, r2, #3
 c00c850:	f002 0218 	and.w	r2, r2, #24
 c00c854:	431a      	orrs	r2, r3
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
 c00c856:	7c4b      	ldrb	r3, [r1, #17]
 c00c858:	005b      	lsls	r3, r3, #1
 c00c85a:	f003 0306 	and.w	r3, r3, #6
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c00c85e:	4313      	orrs	r3, r2

  mpu->RBAR = base_cfg;
 c00c860:	60c3      	str	r3, [r0, #12]

  /*This 0s the lower bits of base address but they are treated as 1 */
  limit_cfg = (region_cfg->region_limit - 1) & MPU_RLAR_LIMIT_Msk;
 c00c862:	688b      	ldr	r3, [r1, #8]
 c00c864:	3b01      	subs	r3, #1
 c00c866:	f023 021f 	bic.w	r2, r3, #31

  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
 c00c86a:	68cb      	ldr	r3, [r1, #12]
 c00c86c:	005b      	lsls	r3, r3, #1
 c00c86e:	f003 030e 	and.w	r3, r3, #14
 c00c872:	4313      	orrs	r3, r2
               MPU_RLAR_AttrIndx_Msk;

  limit_cfg |= MPU_RLAR_EN_Msk;
 c00c874:	f043 0301 	orr.w	r3, r3, #1

  mpu->RLAR = limit_cfg;
 c00c878:	6103      	str	r3, [r0, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 c00c87a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c00c87e:	f3bf 8f6f 	isb	sy

  /* Enable MPU before the next instruction */
  __DSB();
  __ISB();

  return ret_val;
 c00c882:	4620      	mov	r0, r4
}
 c00c884:	bd10      	pop	{r4, pc}
    return MPU_ARMV8M_ERROR;
 c00c886:	2001      	movs	r0, #1
 c00c888:	e7fc      	b.n	c00c884 <mpu_armv8m_region_enable+0x54>

0c00c88a <mpu_armv8m_region_disable>:
enum mpu_armv8m_error_t mpu_armv8m_region_disable(
  struct mpu_armv8m_dev_t *dev,
  uint32_t region_nr)
{

  MPU_Type *mpu = (MPU_Type *)dev->base;
 c00c88a:	6803      	ldr	r3, [r0, #0]
  uint32_t ctrl_before;

  /*FIXME : Add complete error checking*/

  ctrl_before = mpu->CTRL;
  mpu->CTRL = 0;
 c00c88c:	2000      	movs	r0, #0
  ctrl_before = mpu->CTRL;
 c00c88e:	685a      	ldr	r2, [r3, #4]

  mpu->RNR  = region_nr & MPU_RNR_REGION_Msk;
 c00c890:	b2c9      	uxtb	r1, r1
  mpu->CTRL = 0;
 c00c892:	6058      	str	r0, [r3, #4]
  mpu->RNR  = region_nr & MPU_RNR_REGION_Msk;
 c00c894:	6099      	str	r1, [r3, #8]

  mpu->RBAR = 0;
 c00c896:	60d8      	str	r0, [r3, #12]
  mpu->RLAR = 0;
 c00c898:	6118      	str	r0, [r3, #16]

  /*Restore main MPU control*/
  mpu->CTRL = ctrl_before;
 c00c89a:	605a      	str	r2, [r3, #4]

  return ret_val;
}
 c00c89c:	4770      	bx	lr
	...

0c00c8a0 <execute_loader>:
  * @brief This function activates the protection before executing local loader.
  * @note
  * @retval void
  */
void execute_loader(void)
{
 c00c8a0:	b508      	push	{r3, lr}
#if defined(MCUBOOT_PRIMARY_ONLY)
  static struct arm_vector_table *vt = (struct arm_vector_table *)LOADER_S_CODE_START;

  /* Update run time protections for application execution */
  TFM_LL_SECU_UpdateLoaderRunTimeProtections();
 c00c8a2:	f000 f8c7 	bl	c00ca34 <TFM_LL_SECU_UpdateLoaderRunTimeProtections>

  /* set the secure vector */
  SCB->VTOR = (uint32_t)LOADER_S_CODE_START;
 c00c8a6:	4b08      	ldr	r3, [pc, #32]	; (c00c8c8 <execute_loader+0x28>)
 c00c8a8:	4a08      	ldr	r2, [pc, #32]	; (c00c8cc <execute_loader+0x2c>)
 c00c8aa:	6093      	str	r3, [r2, #8]
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 c00c8ac:	2200      	movs	r2, #0
 c00c8ae:	f382 880a 	msr	MSPLIM, r2
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 c00c8b2:	681a      	ldr	r2, [r3, #0]
 c00c8b4:	f382 8808 	msr	MSP, r2
  __ASM volatile ("dsb 0xF":::"memory");
 c00c8b8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c00c8bc:	f3bf 8f6f 	isb	sy
   * bootloader transparent to it.
   */
  __set_MSP(vt->msp);
  __DSB();
  __ISB();
  boot_jump_to_next_image(vt->reset);
 c00c8c0:	6858      	ldr	r0, [r3, #4]
 c00c8c2:	f000 f98b 	bl	c00cbdc <boot_jump_to_next_image>
  boot_jump_to_ns_image(vt->reset);
#endif /* defined(MCUBOOT_PRIMARY_ONLY) */

  /* Avoid compiler to pop registers after having changed MSP */
#if !defined(__ICCARM__)
  __builtin_unreachable();
 c00c8c6:	bf00      	nop
 c00c8c8:	0c078000 	.word	0x0c078000
 c00c8cc:	e000ed00 	.word	0xe000ed00

0c00c8d0 <boot_jump_to_ns_image>:
 *  - There are secrets in the memory: KDF parameter, symmetric key,
 *    manufacturer sensitive code/data, etc.
 */
__attribute__((naked)) void boot_jump_to_ns_image(uint32_t reset_handler_addr)
{
  __ASM volatile(
 c00c8d0:	4607      	mov	r7, r0
 c00c8d2:	f000 f81d 	bl	c00c910 <boot_clean_ns_ram_area>
 c00c8d6:	2000      	movs	r0, #0
 c00c8d8:	4601      	mov	r1, r0
 c00c8da:	4602      	mov	r2, r0
 c00c8dc:	4603      	mov	r3, r0
 c00c8de:	4604      	mov	r4, r0
 c00c8e0:	4605      	mov	r5, r0
 c00c8e2:	4606      	mov	r6, r0
 c00c8e4:	4680      	mov	r8, r0
 c00c8e6:	4681      	mov	r9, r0
 c00c8e8:	4682      	mov	sl, r0
 c00c8ea:	4683      	mov	fp, r0
 c00c8ec:	4684      	mov	ip, r0
 c00c8ee:	4686      	mov	lr, r0
 c00c8f0:	f027 0701 	bic.w	r7, r7, #1
 c00c8f4:	47bc      	blxns	r7

0c00c8f6 <boot_clear_bl2_ram_area>:
  __IO uint32_t *pt = (uint32_t *)BL2_DATA_START;
  uint32_t index;

  for (index = 0; index < (BL2_DATA_SIZE / 4); index++)
  {
    pt[index] = 0;
 c00c8f6:	2100      	movs	r1, #0
{
 c00c8f8:	4b03      	ldr	r3, [pc, #12]	; (c00c908 <boot_clear_bl2_ram_area+0x12>)
  for (index = 0; index < (BL2_DATA_SIZE / 4); index++)
 c00c8fa:	4a04      	ldr	r2, [pc, #16]	; (c00c90c <boot_clear_bl2_ram_area+0x16>)
    pt[index] = 0;
 c00c8fc:	f843 1b04 	str.w	r1, [r3], #4
  for (index = 0; index < (BL2_DATA_SIZE / 4); index++)
 c00c900:	4293      	cmp	r3, r2
 c00c902:	d1fb      	bne.n	c00c8fc <boot_clear_bl2_ram_area+0x6>
  }
}
 c00c904:	4770      	bx	lr
 c00c906:	bf00      	nop
 c00c908:	30030000 	.word	0x30030000
 c00c90c:	30040000 	.word	0x30040000

0c00c910 <boot_clean_ns_ram_area>:
#endif /* TFM_ERROR_HANDLER_NON_SECURE */
  uint32_t index;
  /* clean all SRAM1 */
  for (index = 0; index < (_SRAM1_SIZE_MAX / 4); index++)
  {
    pt[index] = 0;
 c00c910:	2100      	movs	r1, #0
{
 c00c912:	4b08      	ldr	r3, [pc, #32]	; (c00c934 <boot_clean_ns_ram_area+0x24>)
  for (index = 0; index < (_SRAM1_SIZE_MAX / 4); index++)
 c00c914:	4a08      	ldr	r2, [pc, #32]	; (c00c938 <boot_clean_ns_ram_area+0x28>)
    pt[index] = 0;
 c00c916:	f843 1b04 	str.w	r1, [r3], #4
  for (index = 0; index < (_SRAM1_SIZE_MAX / 4); index++)
 c00c91a:	4293      	cmp	r3, r2
 c00c91c:	d1fb      	bne.n	c00c916 <boot_clean_ns_ram_area+0x6>
  }
  /* unsecure all SRAM1 */
  for (index = 0; index < 24 ; index++)
 c00c91e:	2300      	movs	r3, #0
  {
    /* assume loader is only in SRAM1 */
    GTZC_MPCBB1_S->VCTR[index] = 0;
 c00c920:	4618      	mov	r0, r3
 c00c922:	4a06      	ldr	r2, [pc, #24]	; (c00c93c <boot_clean_ns_ram_area+0x2c>)
 c00c924:	f103 0140 	add.w	r1, r3, #64	; 0x40
  for (index = 0; index < 24 ; index++)
 c00c928:	3301      	adds	r3, #1
 c00c92a:	2b18      	cmp	r3, #24
    GTZC_MPCBB1_S->VCTR[index] = 0;
 c00c92c:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
  for (index = 0; index < 24 ; index++)
 c00c930:	d1f8      	bne.n	c00c924 <boot_clean_ns_ram_area+0x14>
  }
}
 c00c932:	4770      	bx	lr
 c00c934:	30000100 	.word	0x30000100
 c00c938:	30030100 	.word	0x30030100
 c00c93c:	50032c00 	.word	0x50032c00

0c00c940 <Error_Handler>:
#define WHILE_1_OPCODE 0xe7fe
  typedef void (*nsfptr_t)(void) __attribute__((cmse_nonsecure_call));
  nsfptr_t nsfptr = (nsfptr_t)(SRAM1_BASE_NS + 1);
  __IO uint16_t *pt = (uint16_t *)SRAM1_BASE_NS;
  /*  copy while(1) instruction */
  *pt = WHILE_1_OPCODE;
 c00c940:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 c00c944:	f24e 72fe 	movw	r2, #59390	; 0xe7fe
{
 c00c948:	b510      	push	{r4, lr}
  *pt = WHILE_1_OPCODE;
 c00c94a:	801a      	strh	r2, [r3, #0]
  __ASM volatile ("dsb 0xF":::"memory");
 c00c94c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c00c950:	f3bf 8f6f 	isb	sy
  /* Flush and refill pipeline  */
  __DSB();
  __ISB();
  /*  call non secure while(1) */
  nsfptr();
 c00c954:	4c14      	ldr	r4, [pc, #80]	; (c00c9a8 <Error_Handler+0x68>)
 c00c956:	0864      	lsrs	r4, r4, #1
 c00c958:	0064      	lsls	r4, r4, #1
 c00c95a:	4620      	mov	r0, r4
 c00c95c:	4621      	mov	r1, r4
 c00c95e:	4622      	mov	r2, r4
 c00c960:	4623      	mov	r3, r4
 c00c962:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 c00c966:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 c00c96a:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 c00c96e:	eef7 1a00 	vmov.f32	s3, #112	; 0x3f800000  1.0
 c00c972:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
 c00c976:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
 c00c97a:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
 c00c97e:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
 c00c982:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
 c00c986:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
 c00c98a:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 c00c98e:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 c00c992:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 c00c996:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 c00c99a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 c00c99e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 c00c9a2:	f7fd f8e3 	bl	c009b6c <__gnu_cmse_nonsecure_call>
  /* an infinite loop,  and a reset for single fault injection */
  static __IO int once = 1;
  while (once);
  NVIC_SystemReset();
#endif  /*  TFM_ERROR_HANDLER_NON_SECURE */
}
 c00c9a6:	bd10      	pop	{r4, pc}
 c00c9a8:	20000001 	.word	0x20000001

0c00c9ac <jumper>:
{
 c00c9ac:	b538      	push	{r3, r4, r5, lr}
    if (ImageValidStatus[image_index] != IMAGE_VALID)
 c00c9ae:	4b13      	ldr	r3, [pc, #76]	; (c00c9fc <jumper+0x50>)
{
 c00c9b0:	4604      	mov	r4, r0
    if (ImageValidStatus[image_index] != IMAGE_VALID)
 c00c9b2:	781b      	ldrb	r3, [r3, #0]
 c00c9b4:	2b55      	cmp	r3, #85	; 0x55
 c00c9b6:	d004      	beq.n	c00c9c2 <jumper+0x16>
      BOOT_LOG_ERR("Error while double controlling images validation");
 c00c9b8:	4811      	ldr	r0, [pc, #68]	; (c00ca00 <jumper+0x54>)
 c00c9ba:	f7fc fa2d 	bl	c008e18 <puts>
      Error_Handler();
 c00c9be:	f7ff ffbf 	bl	c00c940 <Error_Handler>
  if (HAL_ICACHE_Invalidate() != HAL_OK)
 c00c9c2:	f7f7 f955 	bl	c003c70 <HAL_ICACHE_Invalidate>
 c00c9c6:	b108      	cbz	r0, c00c9cc <jumper+0x20>
    Error_Handler();
 c00c9c8:	f7ff ffba 	bl	c00c940 <Error_Handler>
  TFM_LL_SECU_UpdateRunTimeProtections();
 c00c9cc:	f000 f8ca 	bl	c00cb64 <TFM_LL_SECU_UpdateRunTimeProtections>
  SCB->VTOR = (uint32_t)vector;
 c00c9d0:	4b0c      	ldr	r3, [pc, #48]	; (c00ca04 <jumper+0x58>)
  vt = (struct arm_vector_table *)vector;
 c00c9d2:	4d0d      	ldr	r5, [pc, #52]	; (c00ca08 <jumper+0x5c>)
  SCB->VTOR = (uint32_t)vector;
 c00c9d4:	609c      	str	r4, [r3, #8]
  vt = (struct arm_vector_table *)vector;
 c00c9d6:	602c      	str	r4, [r5, #0]
  TFM_LL_SECU_UpdateRunTimeProtections();
 c00c9d8:	f000 f8c4 	bl	c00cb64 <TFM_LL_SECU_UpdateRunTimeProtections>
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 c00c9dc:	2300      	movs	r3, #0
 c00c9de:	f383 880a 	msr	MSPLIM, r3
  __set_MSP(vt->msp);
 c00c9e2:	682b      	ldr	r3, [r5, #0]
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 c00c9e4:	681b      	ldr	r3, [r3, #0]
 c00c9e6:	f383 8808 	msr	MSP, r3
  __ASM volatile ("dsb 0xF":::"memory");
 c00c9ea:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c00c9ee:	f3bf 8f6f 	isb	sy
  boot_jump_to_next_image(vt->reset);
 c00c9f2:	682b      	ldr	r3, [r5, #0]
 c00c9f4:	6858      	ldr	r0, [r3, #4]
 c00c9f6:	f000 f8f1 	bl	c00cbdc <boot_jump_to_next_image>
  __builtin_unreachable();
 c00c9fa:	bf00      	nop
 c00c9fc:	30030004 	.word	0x30030004
 c00ca00:	0c00a1a4 	.word	0x0c00a1a4
 c00ca04:	e000ed00 	.word	0xe000ed00
 c00ca08:	30030130 	.word	0x30030130

0c00ca0c <enable_hdp_protection>:
{
#ifdef TFM_HDP_PROTECT_ENABLE
  do
  {
    /* Activate HDP protection */
    SET_BIT(FLASH->SECHDPCR, FLASH_SECHDPCR_HDP1_ACCDIS);
 c00ca0c:	4b08      	ldr	r3, [pc, #32]	; (c00ca30 <enable_hdp_protection+0x24>)
 c00ca0e:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 c00ca12:	f042 0201 	orr.w	r2, r2, #1
 c00ca16:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
  } while ((FLASH->SECHDPCR & FLASH_SECHDPCR_HDP1_ACCDIS) != FLASH_SECHDPCR_HDP1_ACCDIS);
 c00ca1a:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 c00ca1e:	07d2      	lsls	r2, r2, #31
 c00ca20:	d5f5      	bpl.n	c00ca0e <enable_hdp_protection+0x2>

  if ((FLASH->SECHDPCR & FLASH_SECHDPCR_HDP1_ACCDIS) != FLASH_SECHDPCR_HDP1_ACCDIS)
 c00ca22:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 c00ca26:	07db      	lsls	r3, r3, #31
 c00ca28:	d401      	bmi.n	c00ca2e <enable_hdp_protection+0x22>
  {
    /* Security issue : execution stopped ! */
    Error_Handler();
 c00ca2a:	f7ff bf89 	b.w	c00c940 <Error_Handler>
  }
#endif /* TFM_HDP_PROTECT_ENABLE */
}
 c00ca2e:	4770      	bx	lr
 c00ca30:	50022000 	.word	0x50022000

0c00ca34 <TFM_LL_SECU_UpdateLoaderRunTimeProtections>:
{
 c00ca34:	b500      	push	{lr}
 c00ca36:	b089      	sub	sp, #36	; 0x24
  enable_hdp_protection();  
 c00ca38:	f7ff ffe8 	bl	c00ca0c <enable_hdp_protection>
  mpu_armv8m_region_disable(&dev_mpu_s,2);
 c00ca3c:	2102      	movs	r1, #2
 c00ca3e:	4840      	ldr	r0, [pc, #256]	; (c00cb40 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x10c>)
 c00ca40:	f7ff ff23 	bl	c00c88a <mpu_armv8m_region_disable>
  region_cfg.region_base = SRAM1_BASE_NS;
 c00ca44:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 c00ca48:	2207      	movs	r2, #7
 c00ca4a:	e9cd 2303 	strd	r2, r3, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c00ca4e:	2302      	movs	r3, #2
 c00ca50:	493c      	ldr	r1, [pc, #240]	; (c00cb44 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x110>)
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c00ca52:	483b      	ldr	r0, [pc, #236]	; (c00cb40 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x10c>)
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c00ca54:	e9cd 1305 	strd	r1, r3, [sp, #20]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c00ca58:	2301      	movs	r3, #1
 c00ca5a:	f8ad 301c 	strh.w	r3, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c00ca5e:	2300      	movs	r3, #0
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c00ca60:	a903      	add	r1, sp, #12
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c00ca62:	f88d 301e 	strb.w	r3, [sp, #30]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c00ca66:	f7ff fee3 	bl	c00c830 <mpu_armv8m_region_enable>
 c00ca6a:	b108      	cbz	r0, c00ca70 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x3c>
    Error_Handler();
 c00ca6c:	f7ff ff68 	bl	c00c940 <Error_Handler>
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c00ca70:	4a35      	ldr	r2, [pc, #212]	; (c00cb48 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x114>)
  SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSMPU;  
 c00ca72:	4936      	ldr	r1, [pc, #216]	; (c00cb4c <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x118>)
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c00ca74:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c00ca76:	f043 0301 	orr.w	r3, r3, #1
 c00ca7a:	6613      	str	r3, [r2, #96]	; 0x60
 c00ca7c:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c00ca7e:	f003 0301 	and.w	r3, r3, #1
 c00ca82:	9301      	str	r3, [sp, #4]
 c00ca84:	9b01      	ldr	r3, [sp, #4]
  SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSMPU;  
 c00ca86:	690b      	ldr	r3, [r1, #16]
 c00ca88:	f043 0302 	orr.w	r3, r3, #2
 c00ca8c:	610b      	str	r3, [r1, #16]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c00ca8e:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c00ca90:	f043 0301 	orr.w	r3, r3, #1
 c00ca94:	6613      	str	r3, [r2, #96]	; 0x60
 c00ca96:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c00ca98:	f003 0301 	and.w	r3, r3, #1
 c00ca9c:	9302      	str	r3, [sp, #8]
 c00ca9e:	9b02      	ldr	r3, [sp, #8]
  SYSCFG->CSLCKR |= SYSCFG_CNSLCKR_LOCKNSMPU;
 c00caa0:	690b      	ldr	r3, [r1, #16]
 c00caa2:	f043 0302 	orr.w	r3, r3, #2
 c00caa6:	610b      	str	r3, [r1, #16]
  \brief   Disable SAU
  \details Disables the Security Attribution Unit (SAU).
 */
__STATIC_INLINE void TZ_SAU_Disable(void)
{
    SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);
 c00caa8:	4b29      	ldr	r3, [pc, #164]	; (c00cb50 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x11c>)
 c00caaa:	6818      	ldr	r0, [r3, #0]
 c00caac:	f020 0001 	bic.w	r0, r0, #1
 c00cab0:	6018      	str	r0, [r3, #0]
  SAU->RNR  = 0;
 c00cab2:	2000      	movs	r0, #0
 c00cab4:	6098      	str	r0, [r3, #8]
  SAU->RBAR = ((uint32_t)LOADER_NS_DATA_START) & SAU_RBAR_BADDR_Msk;
 c00cab6:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 c00caba:	60d8      	str	r0, [r3, #12]
  SAU->RLAR = (((uint32_t)LOADER_NS_DATA_LIMIT) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c00cabc:	f500 303f 	add.w	r0, r0, #195584	; 0x2fc00
 c00cac0:	f200 30e1 	addw	r0, r0, #993	; 0x3e1
 c00cac4:	6118      	str	r0, [r3, #16]
  SAU->RNR  = 1;
 c00cac6:	2001      	movs	r0, #1
 c00cac8:	6098      	str	r0, [r3, #8]
  SAU->RBAR = ((uint32_t)PERIPH_BASE_NS & SAU_RBAR_BADDR_Msk);
 c00caca:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 c00cace:	60d8      	str	r0, [r3, #12]
  SAU->RLAR = (((uint32_t)PERIPH_BASE_NS + 0xFFFFFFF) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c00cad0:	4820      	ldr	r0, [pc, #128]	; (c00cb54 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x120>)
 c00cad2:	6118      	str	r0, [r3, #16]
  SAU->RNR  = 3;
 c00cad4:	2003      	movs	r0, #3
 c00cad6:	6098      	str	r0, [r3, #8]
  SAU->RBAR = ((uint32_t)LOADER_NS_CODE_START) & SAU_RBAR_BADDR_Msk;
 c00cad8:	481f      	ldr	r0, [pc, #124]	; (c00cb58 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x124>)
 c00cada:	60d8      	str	r0, [r3, #12]
  SAU->RLAR = (((uint32_t)LOADER_NS_CODE_LIMIT) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c00cadc:	f500 409f 	add.w	r0, r0, #20352	; 0x4f80
 c00cae0:	3061      	adds	r0, #97	; 0x61
 c00cae2:	6118      	str	r0, [r3, #16]
  SAU->RNR  = 4;
 c00cae4:	2004      	movs	r0, #4
 c00cae6:	6098      	str	r0, [r3, #8]
  SAU->RBAR = ((uint32_t)LOADER_CMSE_VENEER_REGION_START) & SAU_RBAR_BADDR_Msk;
 c00cae8:	481c      	ldr	r0, [pc, #112]	; (c00cb5c <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x128>)
 c00caea:	60d8      	str	r0, [r3, #12]
  SAU->RLAR = (((uint32_t)LOADER_CMSE_VENEER_REGION_LIMIT) & SAU_RLAR_LADDR_Msk) |  SAU_RLAR_NSC_Msk |SAU_RLAR_ENABLE_Msk;
 c00caec:	30e3      	adds	r0, #227	; 0xe3
 c00caee:	6118      	str	r0, [r3, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 c00caf0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c00caf4:	f3bf 8f6f 	isb	sy
    SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);
 c00caf8:	6818      	ldr	r0, [r3, #0]
 c00cafa:	f040 0001 	orr.w	r0, r0, #1
 c00cafe:	6018      	str	r0, [r3, #0]
    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
 c00cb00:	4817      	ldr	r0, [pc, #92]	; (c00cb60 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0x12c>)
 c00cb02:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 c00cb06:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
 c00cb0a:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c00cb0e:	f8d0 3234 	ldr.w	r3, [r0, #564]	; 0x234
                   ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos       ) & FPU_FPCCR_TS_Msk       ) |
 c00cb12:	f023 53e0 	bic.w	r3, r3, #469762048	; 0x1c000000
                   ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
 c00cb16:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c00cb1a:	f8c0 3234 	str.w	r3, [r0, #564]	; 0x234
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c00cb1e:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c00cb20:	f043 0301 	orr.w	r3, r3, #1
 c00cb24:	6613      	str	r3, [r2, #96]	; 0x60
 c00cb26:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c00cb28:	f003 0301 	and.w	r3, r3, #1
 c00cb2c:	9303      	str	r3, [sp, #12]
 c00cb2e:	9b03      	ldr	r3, [sp, #12]
  SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSAU;
 c00cb30:	690b      	ldr	r3, [r1, #16]
 c00cb32:	f043 0304 	orr.w	r3, r3, #4
 c00cb36:	610b      	str	r3, [r1, #16]
}
 c00cb38:	b009      	add	sp, #36	; 0x24
 c00cb3a:	f85d fb04 	ldr.w	pc, [sp], #4
 c00cb3e:	bf00      	nop
 c00cb40:	30030058 	.word	0x30030058
 c00cb44:	2003ffff 	.word	0x2003ffff
 c00cb48:	50021000 	.word	0x50021000
 c00cb4c:	50010000 	.word	0x50010000
 c00cb50:	e000edd0 	.word	0xe000edd0
 c00cb54:	4fffffe1 	.word	0x4fffffe1
 c00cb58:	0807b000 	.word	0x0807b000
 c00cb5c:	0c07af00 	.word	0x0c07af00
 c00cb60:	e000ed00 	.word	0xe000ed00

0c00cb64 <TFM_LL_SECU_UpdateRunTimeProtections>:
{
 c00cb64:	b510      	push	{r4, lr}
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c00cb66:	2400      	movs	r4, #0
{
 c00cb68:	b086      	sub	sp, #24
  enable_hdp_protection();
 c00cb6a:	f7ff ff4f 	bl	c00ca0c <enable_hdp_protection>
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c00cb6e:	4b17      	ldr	r3, [pc, #92]	; (c00cbcc <TFM_LL_SECU_UpdateRunTimeProtections+0x68>)
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c00cb70:	4817      	ldr	r0, [pc, #92]	; (c00cbd0 <TFM_LL_SECU_UpdateRunTimeProtections+0x6c>)
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c00cb72:	e9cd 4301 	strd	r4, r3, [sp, #4]
  region_cfg.region_limit = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET + FLASH_S_PARTITION_SIZE - 1;
 c00cb76:	f503 43ff 	add.w	r3, r3, #32640	; 0x7f80
 c00cb7a:	337f      	adds	r3, #127	; 0x7f
 c00cb7c:	9303      	str	r3, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c00cb7e:	2302      	movs	r3, #2
 c00cb80:	9304      	str	r3, [sp, #16]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
 c00cb82:	f44f 7300 	mov.w	r3, #512	; 0x200
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c00cb86:	a901      	add	r1, sp, #4
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
 c00cb88:	f8ad 3014 	strh.w	r3, [sp, #20]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c00cb8c:	f88d 4016 	strb.w	r4, [sp, #22]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c00cb90:	f7ff fe4e 	bl	c00c830 <mpu_armv8m_region_enable>
 c00cb94:	b108      	cbz	r0, c00cb9a <TFM_LL_SECU_UpdateRunTimeProtections+0x36>
    Error_Handler();
 c00cb96:	f7ff fed3 	bl	c00c940 <Error_Handler>
  region_cfg.region_base = FLASH_BASE_NS + NS_IMAGE_PRIMARY_PARTITION_OFFSET;
 c00cb9a:	4b0e      	ldr	r3, [pc, #56]	; (c00cbd4 <TFM_LL_SECU_UpdateRunTimeProtections+0x70>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c00cb9c:	480e      	ldr	r0, [pc, #56]	; (c00cbd8 <TFM_LL_SECU_UpdateRunTimeProtections+0x74>)
  region_cfg.region_base = FLASH_BASE_NS + NS_IMAGE_PRIMARY_PARTITION_OFFSET;
 c00cb9e:	9302      	str	r3, [sp, #8]
  region_cfg.region_limit = FLASH_BASE_NS + NS_IMAGE_PRIMARY_PARTITION_OFFSET + FLASH_NS_PARTITION_SIZE - 1;
 c00cba0:	f503 23c5 	add.w	r3, r3, #403456	; 0x62800
 c00cba4:	f203 73ff 	addw	r3, r3, #2047	; 0x7ff
 c00cba8:	9303      	str	r3, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c00cbaa:	2302      	movs	r3, #2
 c00cbac:	9304      	str	r3, [sp, #16]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
 c00cbae:	f44f 7300 	mov.w	r3, #512	; 0x200
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c00cbb2:	a901      	add	r1, sp, #4
  region_cfg.region_nr = 0;
 c00cbb4:	9401      	str	r4, [sp, #4]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
 c00cbb6:	f8ad 3014 	strh.w	r3, [sp, #20]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c00cbba:	f88d 4016 	strb.w	r4, [sp, #22]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c00cbbe:	f7ff fe37 	bl	c00c830 <mpu_armv8m_region_enable>
 c00cbc2:	b108      	cbz	r0, c00cbc8 <TFM_LL_SECU_UpdateRunTimeProtections+0x64>
    Error_Handler();
 c00cbc4:	f7ff febc 	bl	c00c940 <Error_Handler>
}
 c00cbc8:	b006      	add	sp, #24
 c00cbca:	bd10      	pop	{r4, pc}
 c00cbcc:	0c00d000 	.word	0x0c00d000
 c00cbd0:	30030054 	.word	0x30030054
 c00cbd4:	08015000 	.word	0x08015000
 c00cbd8:	30030050 	.word	0x30030050

0c00cbdc <boot_jump_to_next_image>:
 *  - There are secrets in the memory: KDF parameter, symmetric key,
 *    manufacturer sensitive code/data, etc.
 */
__attribute__((naked)) void boot_jump_to_next_image(uint32_t reset_handler_addr)
{
    __ASM volatile(
 c00cbdc:	4607      	mov	r7, r0
 c00cbde:	f7ff fe8a 	bl	c00c8f6 <boot_clear_bl2_ram_area>
 c00cbe2:	2000      	movs	r0, #0
 c00cbe4:	4601      	mov	r1, r0
 c00cbe6:	4602      	mov	r2, r0
 c00cbe8:	4603      	mov	r3, r0
 c00cbea:	4604      	mov	r4, r0
 c00cbec:	4605      	mov	r5, r0
 c00cbee:	4606      	mov	r6, r0
 c00cbf0:	4680      	mov	r8, r0
 c00cbf2:	4681      	mov	r9, r0
 c00cbf4:	4682      	mov	sl, r0
 c00cbf6:	4683      	mov	fp, r0
 c00cbf8:	4684      	mov	ip, r0
 c00cbfa:	4686      	mov	lr, r0
 c00cbfc:	4738      	bx	r7

Disassembly of section .text:

0c001800 <__Vectors>:
 c001800:	3003d2d8 	.word	0x3003d2d8
 c001804:	0c001ab1 	.word	0x0c001ab1
 c001808:	0c00261d 	.word	0x0c00261d
 c00180c:	0c001add 	.word	0x0c001add
 c001810:	0c001ae1 	.word	0x0c001ae1
 c001814:	0c001ae5 	.word	0x0c001ae5
 c001818:	0c001ae9 	.word	0x0c001ae9
 c00181c:	0c001aed 	.word	0x0c001aed
	...
 c00182c:	0c001af1 	.word	0x0c001af1
 c001830:	0c001af5 	.word	0x0c001af5
 c001834:	00000000 	.word	0x00000000
 c001838:	0c001af9 	.word	0x0c001af9
 c00183c:	0c001afd 	.word	0x0c001afd
 c001840:	0c001b01 	.word	0x0c001b01
 c001844:	0c001b05 	.word	0x0c001b05
 c001848:	0c001b09 	.word	0x0c001b09
 c00184c:	0c001b0d 	.word	0x0c001b0d
 c001850:	0c001b11 	.word	0x0c001b11
 c001854:	0c001b15 	.word	0x0c001b15
 c001858:	0c001b19 	.word	0x0c001b19
 c00185c:	0c001b1d 	.word	0x0c001b1d
 c001860:	0c001b21 	.word	0x0c001b21
 c001864:	0c001b25 	.word	0x0c001b25
 c001868:	0c001b29 	.word	0x0c001b29
 c00186c:	0c001b2d 	.word	0x0c001b2d
 c001870:	0c001b31 	.word	0x0c001b31
 c001874:	0c001b35 	.word	0x0c001b35
 c001878:	0c001b39 	.word	0x0c001b39
 c00187c:	0c001b3d 	.word	0x0c001b3d
 c001880:	0c001b41 	.word	0x0c001b41
 c001884:	0c001b45 	.word	0x0c001b45
 c001888:	0c001b49 	.word	0x0c001b49
 c00188c:	0c001b4d 	.word	0x0c001b4d
 c001890:	0c001b51 	.word	0x0c001b51
 c001894:	0c001b55 	.word	0x0c001b55
 c001898:	0c001b59 	.word	0x0c001b59
 c00189c:	0c001b5d 	.word	0x0c001b5d
 c0018a0:	0c001b61 	.word	0x0c001b61
 c0018a4:	0c001b65 	.word	0x0c001b65
 c0018a8:	0c001b69 	.word	0x0c001b69
 c0018ac:	0c001b6d 	.word	0x0c001b6d
 c0018b0:	0c001b71 	.word	0x0c001b71
 c0018b4:	0c001b75 	.word	0x0c001b75
 c0018b8:	0c001b79 	.word	0x0c001b79
 c0018bc:	0c001b7d 	.word	0x0c001b7d
 c0018c0:	0c001b81 	.word	0x0c001b81
 c0018c4:	0c001b85 	.word	0x0c001b85
 c0018c8:	0c001b89 	.word	0x0c001b89
 c0018cc:	0c001b8d 	.word	0x0c001b8d
 c0018d0:	0c001b91 	.word	0x0c001b91
 c0018d4:	0c001b95 	.word	0x0c001b95
 c0018d8:	0c001b99 	.word	0x0c001b99
 c0018dc:	0c001b9d 	.word	0x0c001b9d
 c0018e0:	0c001ba1 	.word	0x0c001ba1
 c0018e4:	0c001ba5 	.word	0x0c001ba5
 c0018e8:	0c001ba9 	.word	0x0c001ba9
 c0018ec:	0c001bad 	.word	0x0c001bad
 c0018f0:	0c001bb1 	.word	0x0c001bb1
 c0018f4:	0c001bb5 	.word	0x0c001bb5
 c0018f8:	0c001bb9 	.word	0x0c001bb9
 c0018fc:	0c001bbd 	.word	0x0c001bbd
 c001900:	0c001bc1 	.word	0x0c001bc1
 c001904:	0c001bc5 	.word	0x0c001bc5
 c001908:	0c001bc9 	.word	0x0c001bc9
 c00190c:	0c001bcd 	.word	0x0c001bcd
 c001910:	0c001bd1 	.word	0x0c001bd1
 c001914:	0c001bd5 	.word	0x0c001bd5
 c001918:	0c001bd9 	.word	0x0c001bd9
 c00191c:	0c001bdd 	.word	0x0c001bdd
 c001920:	0c001be1 	.word	0x0c001be1
 c001924:	0c001be5 	.word	0x0c001be5
 c001928:	0c001be9 	.word	0x0c001be9
 c00192c:	0c001bed 	.word	0x0c001bed
 c001930:	0c001bf1 	.word	0x0c001bf1
 c001934:	0c001bf5 	.word	0x0c001bf5
 c001938:	0c001bf9 	.word	0x0c001bf9
 c00193c:	0c001bfd 	.word	0x0c001bfd
 c001940:	0c001c01 	.word	0x0c001c01
 c001944:	0c001c05 	.word	0x0c001c05
 c001948:	0c001c09 	.word	0x0c001c09
 c00194c:	0c001c0d 	.word	0x0c001c0d
 c001950:	0c001c11 	.word	0x0c001c11
 c001954:	0c001c15 	.word	0x0c001c15
 c001958:	0c001c19 	.word	0x0c001c19
 c00195c:	0c001c1d 	.word	0x0c001c1d
 c001960:	0c001c21 	.word	0x0c001c21
 c001964:	0c001c25 	.word	0x0c001c25
 c001968:	0c001c29 	.word	0x0c001c29
 c00196c:	0c001c2d 	.word	0x0c001c2d
 c001970:	0c001c31 	.word	0x0c001c31
 c001974:	00000000 	.word	0x00000000
 c001978:	0c001c35 	.word	0x0c001c35
 c00197c:	00000000 	.word	0x00000000
 c001980:	0c001c39 	.word	0x0c001c39
 c001984:	0c001c3d 	.word	0x0c001c3d
 c001988:	0c001c41 	.word	0x0c001c41
 c00198c:	0c001c45 	.word	0x0c001c45
 c001990:	0c001c49 	.word	0x0c001c49
 c001994:	0c001c4d 	.word	0x0c001c4d
 c001998:	0c001c51 	.word	0x0c001c51
 c00199c:	0c001c55 	.word	0x0c001c55
 c0019a0:	0c001c59 	.word	0x0c001c59
 c0019a4:	0c001c5d 	.word	0x0c001c5d
 c0019a8:	0c001c61 	.word	0x0c001c61
 c0019ac:	0c001c65 	.word	0x0c001c65
 c0019b0:	0c001c69 	.word	0x0c001c69
 c0019b4:	00000000 	.word	0x00000000
 c0019b8:	0c001c6d 	.word	0x0c001c6d
 c0019bc:	0c001c71 	.word	0x0c001c71
	...
 c0019c8:	0c001c75 	.word	0x0c001c75
 c0019cc:	0c001c79 	.word	0x0c001c79
 c0019d0:	0c001c7d 	.word	0x0c001c7d
 c0019d4:	0c001c81 	.word	0x0c001c81
 c0019d8:	0c001c85 	.word	0x0c001c85
 c0019dc:	0c001c89 	.word	0x0c001c89
 c0019e0:	0c001c8d 	.word	0x0c001c8d
 c0019e4:	0c001c91 	.word	0x0c001c91
 c0019e8:	0c001c95 	.word	0x0c001c95
 c0019ec:	0c001c99 	.word	0x0c001c99
 c0019f0:	0c001c9d 	.word	0x0c001c9d

0c0019f4 <__do_global_dtors_aux>:
 c0019f4:	b510      	push	{r4, lr}
 c0019f6:	4c05      	ldr	r4, [pc, #20]	; (c001a0c <__do_global_dtors_aux+0x18>)
 c0019f8:	7823      	ldrb	r3, [r4, #0]
 c0019fa:	b933      	cbnz	r3, c001a0a <__do_global_dtors_aux+0x16>
 c0019fc:	4b04      	ldr	r3, [pc, #16]	; (c001a10 <__do_global_dtors_aux+0x1c>)
 c0019fe:	b113      	cbz	r3, c001a06 <__do_global_dtors_aux+0x12>
 c001a00:	4804      	ldr	r0, [pc, #16]	; (c001a14 <__do_global_dtors_aux+0x20>)
 c001a02:	e000      	b.n	c001a06 <__do_global_dtors_aux+0x12>
 c001a04:	bf00      	nop
 c001a06:	2301      	movs	r3, #1
 c001a08:	7023      	strb	r3, [r4, #0]
 c001a0a:	bd10      	pop	{r4, pc}
 c001a0c:	30030100 	.word	0x30030100
 c001a10:	00000000 	.word	0x00000000
 c001a14:	0c00ae34 	.word	0x0c00ae34

0c001a18 <frame_dummy>:
 c001a18:	b508      	push	{r3, lr}
 c001a1a:	4b03      	ldr	r3, [pc, #12]	; (c001a28 <frame_dummy+0x10>)
 c001a1c:	b11b      	cbz	r3, c001a26 <frame_dummy+0xe>
 c001a1e:	4903      	ldr	r1, [pc, #12]	; (c001a2c <frame_dummy+0x14>)
 c001a20:	4803      	ldr	r0, [pc, #12]	; (c001a30 <frame_dummy+0x18>)
 c001a22:	e000      	b.n	c001a26 <frame_dummy+0xe>
 c001a24:	bf00      	nop
 c001a26:	bd08      	pop	{r3, pc}
 c001a28:	00000000 	.word	0x00000000
 c001a2c:	30030104 	.word	0x30030104
 c001a30:	0c00ae34 	.word	0x0c00ae34

0c001a34 <_stack_init>:
 c001a34:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
 c001a38:	4770      	bx	lr
 c001a3a:	bf00      	nop

0c001a3c <_mainCRTStartup>:
 c001a3c:	4b17      	ldr	r3, [pc, #92]	; (c001a9c <_mainCRTStartup+0x60>)
 c001a3e:	2b00      	cmp	r3, #0
 c001a40:	bf08      	it	eq
 c001a42:	4b13      	ldreq	r3, [pc, #76]	; (c001a90 <_mainCRTStartup+0x54>)
 c001a44:	469d      	mov	sp, r3
 c001a46:	f7ff fff5 	bl	c001a34 <_stack_init>
 c001a4a:	2100      	movs	r1, #0
 c001a4c:	468b      	mov	fp, r1
 c001a4e:	460f      	mov	r7, r1
 c001a50:	4813      	ldr	r0, [pc, #76]	; (c001aa0 <_mainCRTStartup+0x64>)
 c001a52:	4a14      	ldr	r2, [pc, #80]	; (c001aa4 <_mainCRTStartup+0x68>)
 c001a54:	1a12      	subs	r2, r2, r0
 c001a56:	f007 f8a6 	bl	c008ba6 <memset>
 c001a5a:	4b0e      	ldr	r3, [pc, #56]	; (c001a94 <_mainCRTStartup+0x58>)
 c001a5c:	2b00      	cmp	r3, #0
 c001a5e:	d000      	beq.n	c001a62 <_mainCRTStartup+0x26>
 c001a60:	4798      	blx	r3
 c001a62:	4b0d      	ldr	r3, [pc, #52]	; (c001a98 <_mainCRTStartup+0x5c>)
 c001a64:	2b00      	cmp	r3, #0
 c001a66:	d000      	beq.n	c001a6a <_mainCRTStartup+0x2e>
 c001a68:	4798      	blx	r3
 c001a6a:	2000      	movs	r0, #0
 c001a6c:	2100      	movs	r1, #0
 c001a6e:	0004      	movs	r4, r0
 c001a70:	000d      	movs	r5, r1
 c001a72:	480d      	ldr	r0, [pc, #52]	; (c001aa8 <_mainCRTStartup+0x6c>)
 c001a74:	2800      	cmp	r0, #0
 c001a76:	d002      	beq.n	c001a7e <_mainCRTStartup+0x42>
 c001a78:	480c      	ldr	r0, [pc, #48]	; (c001aac <_mainCRTStartup+0x70>)
 c001a7a:	e000      	b.n	c001a7e <_mainCRTStartup+0x42>
 c001a7c:	bf00      	nop
 c001a7e:	f007 f861 	bl	c008b44 <__libc_init_array>
 c001a82:	0020      	movs	r0, r4
 c001a84:	0029      	movs	r1, r5
 c001a86:	f006 feb1 	bl	c0087ec <main>
 c001a8a:	f007 f847 	bl	c008b1c <exit>
 c001a8e:	bf00      	nop
 c001a90:	00080000 	.word	0x00080000
	...
 c001a9c:	3003d2d8 	.word	0x3003d2d8
 c001aa0:	30030100 	.word	0x30030100
 c001aa4:	3003bed4 	.word	0x3003bed4
	...

0c001ab0 <Reset_Handler>:
 c001ab0:	4906      	ldr	r1, [pc, #24]	; (c001acc <Reset_Handler+0x1c>)
 c001ab2:	4a07      	ldr	r2, [pc, #28]	; (c001ad0 <Reset_Handler+0x20>)
 c001ab4:	4b07      	ldr	r3, [pc, #28]	; (c001ad4 <Reset_Handler+0x24>)
 c001ab6:	1a9b      	subs	r3, r3, r2
 c001ab8:	dd03      	ble.n	c001ac2 <Reset_Handler+0x12>
 c001aba:	3b04      	subs	r3, #4
 c001abc:	58c8      	ldr	r0, [r1, r3]
 c001abe:	50d0      	str	r0, [r2, r3]
 c001ac0:	dcfb      	bgt.n	c001aba <Reset_Handler+0xa>
 c001ac2:	f000 fe95 	bl	c0027f0 <SystemInit>
 c001ac6:	f7ff ffb9 	bl	c001a3c <_mainCRTStartup>
 c001aca:	0000      	.short	0x0000
 c001acc:	0c00ae68 	.word	0x0c00ae68
 c001ad0:	30030000 	.word	0x30030000
 c001ad4:	30030100 	.word	0x30030100
 c001ad8:	f000 bda0 	b.w	c00261c <NMI_Handler>

0c001adc <HardFault_Handler>:
 c001adc:	f7ff bffe 	b.w	c001adc <HardFault_Handler>

0c001ae0 <MemManage_Handler>:
 c001ae0:	f7ff bffe 	b.w	c001ae0 <MemManage_Handler>

0c001ae4 <BusFault_Handler>:
 c001ae4:	f7ff bffe 	b.w	c001ae4 <BusFault_Handler>

0c001ae8 <UsageFault_Handler>:
 c001ae8:	f7ff bffe 	b.w	c001ae8 <UsageFault_Handler>

0c001aec <SecureFault_Handler>:
 c001aec:	f7ff bffe 	b.w	c001aec <SecureFault_Handler>

0c001af0 <SVC_Handler>:
 c001af0:	f7ff bffe 	b.w	c001af0 <SVC_Handler>

0c001af4 <DebugMon_Handler>:
 c001af4:	f7ff bffe 	b.w	c001af4 <DebugMon_Handler>

0c001af8 <PendSV_Handler>:
 c001af8:	f7ff bffe 	b.w	c001af8 <PendSV_Handler>

0c001afc <SysTick_Handler>:
 c001afc:	f7ff bffe 	b.w	c001afc <SysTick_Handler>

0c001b00 <WWDG_IRQHandler>:
 c001b00:	f7ff bffe 	b.w	c001b00 <WWDG_IRQHandler>

0c001b04 <PVD_PVM_IRQHandler>:
 c001b04:	f7ff bffe 	b.w	c001b04 <PVD_PVM_IRQHandler>

0c001b08 <RTC_IRQHandler>:
 c001b08:	f7ff bffe 	b.w	c001b08 <RTC_IRQHandler>

0c001b0c <RTC_IRQHandler_S>:
 c001b0c:	f7ff bffe 	b.w	c001b0c <RTC_IRQHandler_S>

0c001b10 <TAMP_IRQHandler>:
 c001b10:	f7ff bffe 	b.w	c001b10 <TAMP_IRQHandler>

0c001b14 <TAMP_IRQHandler_S>:
 c001b14:	f7ff bffe 	b.w	c001b14 <TAMP_IRQHandler_S>

0c001b18 <FLASH_IRQHandler>:
 c001b18:	f7ff bffe 	b.w	c001b18 <FLASH_IRQHandler>

0c001b1c <FLASH_IRQHandler_S>:
 c001b1c:	f7ff bffe 	b.w	c001b1c <FLASH_IRQHandler_S>

0c001b20 <SERR_IRQHandler>:
 c001b20:	f7ff bffe 	b.w	c001b20 <SERR_IRQHandler>

0c001b24 <RCC_IRQHandler>:
 c001b24:	f7ff bffe 	b.w	c001b24 <RCC_IRQHandler>

0c001b28 <RCC_IRQHandler_S>:
 c001b28:	f7ff bffe 	b.w	c001b28 <RCC_IRQHandler_S>

0c001b2c <EXTI0_IRQHandler>:
 c001b2c:	f7ff bffe 	b.w	c001b2c <EXTI0_IRQHandler>

0c001b30 <EXTI1_IRQHandler>:
 c001b30:	f7ff bffe 	b.w	c001b30 <EXTI1_IRQHandler>

0c001b34 <EXTI2_IRQHandler>:
 c001b34:	f7ff bffe 	b.w	c001b34 <EXTI2_IRQHandler>

0c001b38 <EXTI3_IRQHandler>:
 c001b38:	f7ff bffe 	b.w	c001b38 <EXTI3_IRQHandler>

0c001b3c <EXTI4_IRQHandler>:
 c001b3c:	f7ff bffe 	b.w	c001b3c <EXTI4_IRQHandler>

0c001b40 <EXTI5_IRQHandler>:
 c001b40:	f7ff bffe 	b.w	c001b40 <EXTI5_IRQHandler>

0c001b44 <EXTI6_IRQHandler>:
 c001b44:	f7ff bffe 	b.w	c001b44 <EXTI6_IRQHandler>

0c001b48 <EXTI7_IRQHandler>:
 c001b48:	f7ff bffe 	b.w	c001b48 <EXTI7_IRQHandler>

0c001b4c <EXTI8_IRQHandler>:
 c001b4c:	f7ff bffe 	b.w	c001b4c <EXTI8_IRQHandler>

0c001b50 <EXTI9_IRQHandler>:
 c001b50:	f7ff bffe 	b.w	c001b50 <EXTI9_IRQHandler>

0c001b54 <EXTI10_IRQHandler>:
 c001b54:	f7ff bffe 	b.w	c001b54 <EXTI10_IRQHandler>

0c001b58 <EXTI11_IRQHandler>:
 c001b58:	f7ff bffe 	b.w	c001b58 <EXTI11_IRQHandler>

0c001b5c <EXTI12_IRQHandler>:
 c001b5c:	f7ff bffe 	b.w	c001b5c <EXTI12_IRQHandler>

0c001b60 <EXTI13_IRQHandler>:
 c001b60:	f7ff bffe 	b.w	c001b60 <EXTI13_IRQHandler>

0c001b64 <EXTI14_IRQHandler>:
 c001b64:	f7ff bffe 	b.w	c001b64 <EXTI14_IRQHandler>

0c001b68 <EXTI15_IRQHandler>:
 c001b68:	f7ff bffe 	b.w	c001b68 <EXTI15_IRQHandler>

0c001b6c <DMAMUX1_IRQHandler>:
 c001b6c:	f7ff bffe 	b.w	c001b6c <DMAMUX1_IRQHandler>

0c001b70 <DMAMUX1_IRQHandler_S>:
 c001b70:	f7ff bffe 	b.w	c001b70 <DMAMUX1_IRQHandler_S>

0c001b74 <DMA1_Channel1_IRQHandler>:
 c001b74:	f7ff bffe 	b.w	c001b74 <DMA1_Channel1_IRQHandler>

0c001b78 <DMA1_Channel2_IRQHandler>:
 c001b78:	f7ff bffe 	b.w	c001b78 <DMA1_Channel2_IRQHandler>

0c001b7c <DMA1_Channel3_IRQHandler>:
 c001b7c:	f7ff bffe 	b.w	c001b7c <DMA1_Channel3_IRQHandler>

0c001b80 <DMA1_Channel4_IRQHandler>:
 c001b80:	f7ff bffe 	b.w	c001b80 <DMA1_Channel4_IRQHandler>

0c001b84 <DMA1_Channel5_IRQHandler>:
 c001b84:	f7ff bffe 	b.w	c001b84 <DMA1_Channel5_IRQHandler>

0c001b88 <DMA1_Channel6_IRQHandler>:
 c001b88:	f7ff bffe 	b.w	c001b88 <DMA1_Channel6_IRQHandler>

0c001b8c <DMA1_Channel7_IRQHandler>:
 c001b8c:	f7ff bffe 	b.w	c001b8c <DMA1_Channel7_IRQHandler>

0c001b90 <DMA1_Channel8_IRQHandler>:
 c001b90:	f7ff bffe 	b.w	c001b90 <DMA1_Channel8_IRQHandler>

0c001b94 <ADC1_2_IRQHandler>:
 c001b94:	f7ff bffe 	b.w	c001b94 <ADC1_2_IRQHandler>

0c001b98 <DAC_IRQHandler>:
 c001b98:	f7ff bffe 	b.w	c001b98 <DAC_IRQHandler>

0c001b9c <FDCAN1_IT0_IRQHandler>:
 c001b9c:	f7ff bffe 	b.w	c001b9c <FDCAN1_IT0_IRQHandler>

0c001ba0 <FDCAN1_IT1_IRQHandler>:
 c001ba0:	f7ff bffe 	b.w	c001ba0 <FDCAN1_IT1_IRQHandler>

0c001ba4 <TIM1_BRK_IRQHandler>:
 c001ba4:	f7ff bffe 	b.w	c001ba4 <TIM1_BRK_IRQHandler>

0c001ba8 <TIM1_UP_IRQHandler>:
 c001ba8:	f7ff bffe 	b.w	c001ba8 <TIM1_UP_IRQHandler>

0c001bac <TIM1_TRG_COM_IRQHandler>:
 c001bac:	f7ff bffe 	b.w	c001bac <TIM1_TRG_COM_IRQHandler>

0c001bb0 <TIM1_CC_IRQHandler>:
 c001bb0:	f7ff bffe 	b.w	c001bb0 <TIM1_CC_IRQHandler>

0c001bb4 <TIM2_IRQHandler>:
 c001bb4:	f7ff bffe 	b.w	c001bb4 <TIM2_IRQHandler>

0c001bb8 <TIM3_IRQHandler>:
 c001bb8:	f7ff bffe 	b.w	c001bb8 <TIM3_IRQHandler>

0c001bbc <TIM4_IRQHandler>:
 c001bbc:	f7ff bffe 	b.w	c001bbc <TIM4_IRQHandler>

0c001bc0 <TIM5_IRQHandler>:
 c001bc0:	f7ff bffe 	b.w	c001bc0 <TIM5_IRQHandler>

0c001bc4 <TIM6_IRQHandler>:
 c001bc4:	f7ff bffe 	b.w	c001bc4 <TIM6_IRQHandler>

0c001bc8 <TIM7_IRQHandler>:
 c001bc8:	f7ff bffe 	b.w	c001bc8 <TIM7_IRQHandler>

0c001bcc <TIM8_BRK_IRQHandler>:
 c001bcc:	f7ff bffe 	b.w	c001bcc <TIM8_BRK_IRQHandler>

0c001bd0 <TIM8_UP_IRQHandler>:
 c001bd0:	f7ff bffe 	b.w	c001bd0 <TIM8_UP_IRQHandler>

0c001bd4 <TIM8_TRG_COM_IRQHandler>:
 c001bd4:	f7ff bffe 	b.w	c001bd4 <TIM8_TRG_COM_IRQHandler>

0c001bd8 <TIM8_CC_IRQHandler>:
 c001bd8:	f7ff bffe 	b.w	c001bd8 <TIM8_CC_IRQHandler>

0c001bdc <I2C1_EV_IRQHandler>:
 c001bdc:	f7ff bffe 	b.w	c001bdc <I2C1_EV_IRQHandler>

0c001be0 <I2C1_ER_IRQHandler>:
 c001be0:	f7ff bffe 	b.w	c001be0 <I2C1_ER_IRQHandler>

0c001be4 <I2C2_EV_IRQHandler>:
 c001be4:	f7ff bffe 	b.w	c001be4 <I2C2_EV_IRQHandler>

0c001be8 <I2C2_ER_IRQHandler>:
 c001be8:	f7ff bffe 	b.w	c001be8 <I2C2_ER_IRQHandler>

0c001bec <SPI1_IRQHandler>:
 c001bec:	f7ff bffe 	b.w	c001bec <SPI1_IRQHandler>

0c001bf0 <SPI2_IRQHandler>:
 c001bf0:	f7ff bffe 	b.w	c001bf0 <SPI2_IRQHandler>

0c001bf4 <USART1_IRQHandler>:
 c001bf4:	f7ff bffe 	b.w	c001bf4 <USART1_IRQHandler>

0c001bf8 <USART2_IRQHandler>:
 c001bf8:	f7ff bffe 	b.w	c001bf8 <USART2_IRQHandler>

0c001bfc <USART3_IRQHandler>:
 c001bfc:	f7ff bffe 	b.w	c001bfc <USART3_IRQHandler>

0c001c00 <UART4_IRQHandler>:
 c001c00:	f7ff bffe 	b.w	c001c00 <UART4_IRQHandler>

0c001c04 <UART5_IRQHandler>:
 c001c04:	f7ff bffe 	b.w	c001c04 <UART5_IRQHandler>

0c001c08 <LPUART1_IRQHandler>:
 c001c08:	f7ff bffe 	b.w	c001c08 <LPUART1_IRQHandler>

0c001c0c <LPTIM1_IRQHandler>:
 c001c0c:	f7ff bffe 	b.w	c001c0c <LPTIM1_IRQHandler>

0c001c10 <LPTIM2_IRQHandler>:
 c001c10:	f7ff bffe 	b.w	c001c10 <LPTIM2_IRQHandler>

0c001c14 <TIM15_IRQHandler>:
 c001c14:	f7ff bffe 	b.w	c001c14 <TIM15_IRQHandler>

0c001c18 <TIM16_IRQHandler>:
 c001c18:	f7ff bffe 	b.w	c001c18 <TIM16_IRQHandler>

0c001c1c <TIM17_IRQHandler>:
 c001c1c:	f7ff bffe 	b.w	c001c1c <TIM17_IRQHandler>

0c001c20 <COMP_IRQHandler>:
 c001c20:	f7ff bffe 	b.w	c001c20 <COMP_IRQHandler>

0c001c24 <USB_FS_IRQHandler>:
 c001c24:	f7ff bffe 	b.w	c001c24 <USB_FS_IRQHandler>

0c001c28 <CRS_IRQHandler>:
 c001c28:	f7ff bffe 	b.w	c001c28 <CRS_IRQHandler>

0c001c2c <FMC_IRQHandler>:
 c001c2c:	f7ff bffe 	b.w	c001c2c <FMC_IRQHandler>

0c001c30 <OCTOSPI1_IRQHandler>:
 c001c30:	f7ff bffe 	b.w	c001c30 <OCTOSPI1_IRQHandler>

0c001c34 <SDMMC1_IRQHandler>:
 c001c34:	f7ff bffe 	b.w	c001c34 <SDMMC1_IRQHandler>

0c001c38 <DMA2_Channel1_IRQHandler>:
 c001c38:	f7ff bffe 	b.w	c001c38 <DMA2_Channel1_IRQHandler>

0c001c3c <DMA2_Channel2_IRQHandler>:
 c001c3c:	f7ff bffe 	b.w	c001c3c <DMA2_Channel2_IRQHandler>

0c001c40 <DMA2_Channel3_IRQHandler>:
 c001c40:	f7ff bffe 	b.w	c001c40 <DMA2_Channel3_IRQHandler>

0c001c44 <DMA2_Channel4_IRQHandler>:
 c001c44:	f7ff bffe 	b.w	c001c44 <DMA2_Channel4_IRQHandler>

0c001c48 <DMA2_Channel5_IRQHandler>:
 c001c48:	f7ff bffe 	b.w	c001c48 <DMA2_Channel5_IRQHandler>

0c001c4c <DMA2_Channel6_IRQHandler>:
 c001c4c:	f7ff bffe 	b.w	c001c4c <DMA2_Channel6_IRQHandler>

0c001c50 <DMA2_Channel7_IRQHandler>:
 c001c50:	f7ff bffe 	b.w	c001c50 <DMA2_Channel7_IRQHandler>

0c001c54 <DMA2_Channel8_IRQHandler>:
 c001c54:	f7ff bffe 	b.w	c001c54 <DMA2_Channel8_IRQHandler>

0c001c58 <I2C3_EV_IRQHandler>:
 c001c58:	f7ff bffe 	b.w	c001c58 <I2C3_EV_IRQHandler>

0c001c5c <I2C3_ER_IRQHandler>:
 c001c5c:	f7ff bffe 	b.w	c001c5c <I2C3_ER_IRQHandler>

0c001c60 <SAI1_IRQHandler>:
 c001c60:	f7ff bffe 	b.w	c001c60 <SAI1_IRQHandler>

0c001c64 <SAI2_IRQHandler>:
 c001c64:	f7ff bffe 	b.w	c001c64 <SAI2_IRQHandler>

0c001c68 <TSC_IRQHandler>:
 c001c68:	f7ff bffe 	b.w	c001c68 <TSC_IRQHandler>

0c001c6c <RNG_IRQHandler>:
 c001c6c:	f7ff bffe 	b.w	c001c6c <RNG_IRQHandler>

0c001c70 <FPU_IRQHandler>:
 c001c70:	f7ff bffe 	b.w	c001c70 <FPU_IRQHandler>

0c001c74 <LPTIM3_IRQHandler>:
 c001c74:	f7ff bffe 	b.w	c001c74 <LPTIM3_IRQHandler>

0c001c78 <SPI3_IRQHandler>:
 c001c78:	f7ff bffe 	b.w	c001c78 <SPI3_IRQHandler>

0c001c7c <I2C4_ER_IRQHandler>:
 c001c7c:	f7ff bffe 	b.w	c001c7c <I2C4_ER_IRQHandler>

0c001c80 <I2C4_EV_IRQHandler>:
 c001c80:	f7ff bffe 	b.w	c001c80 <I2C4_EV_IRQHandler>

0c001c84 <DFSDM1_FLT0_IRQHandler>:
 c001c84:	f7ff bffe 	b.w	c001c84 <DFSDM1_FLT0_IRQHandler>

0c001c88 <DFSDM1_FLT1_IRQHandler>:
 c001c88:	f7ff bffe 	b.w	c001c88 <DFSDM1_FLT1_IRQHandler>

0c001c8c <DFSDM1_FLT2_IRQHandler>:
 c001c8c:	f7ff bffe 	b.w	c001c8c <DFSDM1_FLT2_IRQHandler>

0c001c90 <DFSDM1_FLT3_IRQHandler>:
 c001c90:	f7ff bffe 	b.w	c001c90 <DFSDM1_FLT3_IRQHandler>

0c001c94 <UCPD1_IRQHandler>:
 c001c94:	f7ff bffe 	b.w	c001c94 <UCPD1_IRQHandler>

0c001c98 <ICACHE_IRQHandler>:
 c001c98:	f7ff bffe 	b.w	c001c98 <ICACHE_IRQHandler>

0c001c9c <OTFDEC1_IRQHandler>:
 c001c9c:	f7ff bffe 	b.w	c001c9c <OTFDEC1_IRQHandler>

0c001ca0 <CalculateCrc>:
  * @param  CRCx CRC Instance
  * @retval None
  */
__STATIC_INLINE void LL_CRC_ResetCRCCalculationUnit(CRC_TypeDef *CRCx)
{
  SET_BIT(CRCx->CR, CRC_CR_RESET);
 c001ca0:	4b0f      	ldr	r3, [pc, #60]	; (c001ce0 <CalculateCrc+0x40>)
  * @param  Data value of  the eeprom variable.
  * @param  VirtAddress address of the eeprom variable.
  * @retval 16-bit CRC value computed on Data and Virtual Address.
  */
static uint16_t CalculateCrc(NVCNT_DATA_TYPE Data, uint16_t VirtAddress)
{
 c001ca2:	b513      	push	{r0, r1, r4, lr}
 c001ca4:	689a      	ldr	r2, [r3, #8]
 c001ca6:	f042 0201 	orr.w	r2, r2, #1
 c001caa:	609a      	str	r2, [r3, #8]
  * @retval None
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 c001cac:	4a0d      	ldr	r2, [pc, #52]	; (c001ce4 <CalculateCrc+0x44>)
 c001cae:	6c94      	ldr	r4, [r2, #72]	; 0x48
 c001cb0:	f444 5480 	orr.w	r4, r4, #4096	; 0x1000
 c001cb4:	6494      	str	r4, [r2, #72]	; 0x48
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 c001cb6:	6c92      	ldr	r2, [r2, #72]	; 0x48
 c001cb8:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 c001cbc:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 c001cbe:	9a01      	ldr	r2, [sp, #4]
  * @param  PolynomCoef Value to be programmed in Programmable Polynomial value register
  * @retval None
  */
__STATIC_INLINE void LL_CRC_SetPolynomialCoef(CRC_TypeDef *CRCx, uint32_t PolynomCoef)
{
  WRITE_REG(CRCx->POL, PolynomCoef);
 c001cc0:	f248 0205 	movw	r2, #32773	; 0x8005
 c001cc4:	615a      	str	r2, [r3, #20]
  MODIFY_REG(CRCx->CR, CRC_CR_POLYSIZE, PolySize);
 c001cc6:	689a      	ldr	r2, [r3, #8]
 c001cc8:	f022 0218 	bic.w	r2, r2, #24
 c001ccc:	f042 0208 	orr.w	r2, r2, #8
 c001cd0:	609a      	str	r2, [r3, #8]
  * @param  InData value to be provided to CRC calculator between between Min_Data=0 and Max_Data=0xFFFFFFFF
  * @retval None
  */
__STATIC_INLINE void LL_CRC_FeedData32(CRC_TypeDef *CRCx, uint32_t InData)
{
  WRITE_REG(CRCx->DR, InData);
 c001cd2:	6018      	str	r0, [r3, #0]
__STATIC_INLINE void LL_CRC_FeedData16(CRC_TypeDef *CRCx, uint16_t InData)
{
  __IO uint16_t *pReg;

  pReg = (__IO uint16_t *)(__IO void *)(&CRCx->DR);                             /* Derogation MisraC2012 R.11.5 */
  *pReg = InData;
 c001cd4:	8019      	strh	r1, [r3, #0]
  * @param  CRCx CRC Instance
  * @retval Current CRC calculation result as stored in CRC_DR register (16 bits).
  */
__STATIC_INLINE uint16_t LL_CRC_ReadData16(CRC_TypeDef *CRCx)
{
  return (uint16_t)READ_REG(CRCx->DR);
 c001cd6:	6818      	ldr	r0, [r3, #0]
  LL_CRC_FeedData32(CRC, Data);
  LL_CRC_FeedData16(CRC, VirtAddress);

  /* Return computed CRC value */
  return (LL_CRC_ReadData16(CRC));
}
 c001cd8:	b280      	uxth	r0, r0
 c001cda:	b002      	add	sp, #8
 c001cdc:	bd10      	pop	{r4, pc}
 c001cde:	bf00      	nop
 c001ce0:	50023000 	.word	0x50023000
 c001ce4:	50021000 	.word	0x50021000

0c001ce8 <tfm_plat_read_nv_counter>:
{
 c001ce8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c001cec:	2300      	movs	r3, #0
{
 c001cee:	4693      	mov	fp, r2
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c001cf0:	2200      	movs	r2, #0
  if (size < sizeof(NVCNT_DATA_TYPE))
 c001cf2:	2903      	cmp	r1, #3
{
 c001cf4:	4682      	mov	sl, r0
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c001cf6:	e9cd 2300 	strd	r2, r3, [sp]
  if (size < sizeof(NVCNT_DATA_TYPE))
 c001cfa:	d934      	bls.n	c001d66 <tfm_plat_read_nv_counter+0x7e>
  uint32_t previous_value = 0;
 c001cfc:	2500      	movs	r5, #0
  counter = BL2_NV_COUNTERS_AREA_SIZE - NVCNT_ELEMENT_SIZE;
 c001cfe:	f640 76f8 	movw	r6, #4088	; 0xff8
  uint32_t found = 0;
 c001d02:	462c      	mov	r4, r5
    err = FLASH_DEV_NAME.ReadData(BL2_NV_COUNTERS_AREA_ADDR + counter, &addressvalue,
 c001d04:	4b19      	ldr	r3, [pc, #100]	; (c001d6c <tfm_plat_read_nv_counter+0x84>)
 c001d06:	695f      	ldr	r7, [r3, #20]
 c001d08:	2208      	movs	r2, #8
 c001d0a:	4669      	mov	r1, sp
 c001d0c:	4630      	mov	r0, r6
 c001d0e:	47b8      	blx	r7
    if ((err == ARM_DRIVER_OK) && (addressvalue != NVCNT_PAGESTAT_ERASED))
 c001d10:	b9f8      	cbnz	r0, c001d52 <tfm_plat_read_nv_counter+0x6a>
 c001d12:	e9dd 8900 	ldrd	r8, r9, [sp]
 c001d16:	f1b9 3fff 	cmp.w	r9, #4294967295
 c001d1a:	bf08      	it	eq
 c001d1c:	f1b8 3fff 	cmpeq.w	r8, #4294967295
 c001d20:	d017      	beq.n	c001d52 <tfm_plat_read_nv_counter+0x6a>
      if (addressvalue == 0)
 c001d22:	ea58 0309 	orrs.w	r3, r8, r9
 c001d26:	d103      	bne.n	c001d30 <tfm_plat_read_nv_counter+0x48>
        return TFM_PLAT_ERR_SYSTEM_ERR;
 c001d28:	2001      	movs	r0, #1
}
 c001d2a:	b003      	add	sp, #12
 c001d2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (NVCNT_ID_VALUE(addressvalue) == counter_id)
 c001d30:	fa1f f188 	uxth.w	r1, r8
 c001d34:	4551      	cmp	r1, sl
 c001d36:	d10c      	bne.n	c001d52 <tfm_plat_read_nv_counter+0x6a>
        crc = CalculateCrc(NVCNT_DATA_VALUE(addressvalue), NVCNT_ID_VALUE(addressvalue));
 c001d38:	4648      	mov	r0, r9
 c001d3a:	f7ff ffb1 	bl	c001ca0 <CalculateCrc>
        if (crc == NVCNT_CRC_VALUE(addressvalue))
 c001d3e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 c001d42:	9b01      	ldr	r3, [sp, #4]
 c001d44:	4290      	cmp	r0, r2
 c001d46:	d104      	bne.n	c001d52 <tfm_plat_read_nv_counter+0x6a>
          if (found != 1)
 c001d48:	b94c      	cbnz	r4, c001d5e <tfm_plat_read_nv_counter+0x76>
            *((uint32_t *)val) = NVCNT_DATA_VALUE(addressvalue);
 c001d4a:	461d      	mov	r5, r3
            found = 1;
 c001d4c:	2401      	movs	r4, #1
            *((uint32_t *)val) = NVCNT_DATA_VALUE(addressvalue);
 c001d4e:	f8cb 3000 	str.w	r3, [fp]
    counter -= NVCNT_ELEMENT_SIZE;
 c001d52:	3e08      	subs	r6, #8
  while (counter >= PAGE_HEADER_SIZE)
 c001d54:	2e38      	cmp	r6, #56	; 0x38
 c001d56:	d1d7      	bne.n	c001d08 <tfm_plat_read_nv_counter+0x20>
  if (found == 1)
 c001d58:	f1c4 0001 	rsb	r0, r4, #1
 c001d5c:	e7e5      	b.n	c001d2a <tfm_plat_read_nv_counter+0x42>
            if (current_value >= previous_value)
 c001d5e:	42ab      	cmp	r3, r5
 c001d60:	d2e2      	bcs.n	c001d28 <tfm_plat_read_nv_counter+0x40>
 c001d62:	461d      	mov	r5, r3
 c001d64:	e7f5      	b.n	c001d52 <tfm_plat_read_nv_counter+0x6a>
    return TFM_PLAT_ERR_INVALID_INPUT;
 c001d66:	2003      	movs	r0, #3
 c001d68:	e7df      	b.n	c001d2a <tfm_plat_read_nv_counter+0x42>
 c001d6a:	bf00      	nop
 c001d6c:	0c00a264 	.word	0x0c00a264

0c001d70 <tfm_plat_init_nv_counter>:
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c001d70:	2200      	movs	r2, #0
 c001d72:	2300      	movs	r3, #0
{
 c001d74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  bool readstatus = true;
 c001d78:	2401      	movs	r4, #1
  uint32_t counter = 0U;
 c001d7a:	2500      	movs	r5, #0
    err = FLASH_DEV_NAME.ReadData(Address + counter, &addressvalue,
 c001d7c:	4f72      	ldr	r7, [pc, #456]	; (c001f48 <tfm_plat_init_nv_counter+0x1d8>)
{
 c001d7e:	b088      	sub	sp, #32
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c001d80:	e9cd 2302 	strd	r2, r3, [sp, #8]
    err = FLASH_DEV_NAME.ReadData(Address + counter, &addressvalue,
 c001d84:	f8d7 8014 	ldr.w	r8, [r7, #20]
 c001d88:	2208      	movs	r2, #8
 c001d8a:	4628      	mov	r0, r5
 c001d8c:	a906      	add	r1, sp, #24
 c001d8e:	47c0      	blx	r8
    if ((err != ARM_DRIVER_OK) || (addressvalue != NVCNT_PAGESTAT_ERASED))
 c001d90:	2800      	cmp	r0, #0
 c001d92:	d136      	bne.n	c001e02 <tfm_plat_init_nv_counter+0x92>
 c001d94:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
      readstatus = false;
 c001d98:	3301      	adds	r3, #1
 c001d9a:	bf0c      	ite	eq
 c001d9c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c001da0:	2400      	movne	r4, #0
    counter = counter + NVCNT_ELEMENT_SIZE;
 c001da2:	3508      	adds	r5, #8
  while (counter < PageSize)
 c001da4:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
 c001da8:	d1ee      	bne.n	c001d88 <tfm_plat_init_nv_counter+0x18>
  return readstatus;
 c001daa:	4e68      	ldr	r6, [pc, #416]	; (c001f4c <tfm_plat_init_nv_counter+0x1dc>)
  if (VerifyPageFullyErased(BL2_NV_COUNTERS_AREA_ADDR, BL2_NV_COUNTERS_AREA_SIZE))
 c001dac:	2c00      	cmp	r4, #0
 c001dae:	f000 80a5 	beq.w	c001efc <tfm_plat_init_nv_counter+0x18c>
    HAL_Delay(500);
 c001db2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 c001db6:	f001 f8ab 	bl	c002f10 <HAL_Delay>
    BOOT_LOG_INF("Initializing BL2 NV area : Power down/reset not supported...");
 c001dba:	4865      	ldr	r0, [pc, #404]	; (c001f50 <tfm_plat_init_nv_counter+0x1e0>)
 c001dbc:	f007 f82c 	bl	c008e18 <puts>
  int32_t err;
  uint32_t crc = 0U;
  __IO NVCNT_ELEMENT_TYPE element;
  int32_t loop = sizeof(huk) / sizeof(NVCNT_DATA_TYPE) - 1;
  uint32_t address = BL2_NV_COUNTERS_AREA_ADDR;
  huk[0] = NVCNT_HEADER_VALUE;
 c001dc0:	9600      	str	r6, [sp, #0]
  /*  write the HUK in header */
  while (loop >= 0)
  {
    /* store in revert order , read is done in revert at the end all is in order */
    /* compute crc */
    crc = CalculateCrc(huk[loop], huk_random_id);
 c001dc2:	f644 0155 	movw	r1, #18517	; 0x4855
 c001dc6:	9800      	ldr	r0, [sp, #0]
 c001dc8:	f7ff ff6a 	bl	c001ca0 <CalculateCrc>
    /*  build element  */
    element = NVCNT_ELEMENT_VALUE(huk_random_id, huk[loop], crc);
 c001dcc:	9900      	ldr	r1, [sp, #0]
 c001dce:	f644 0455 	movw	r4, #18517	; 0x4855
 c001dd2:	460b      	mov	r3, r1
 c001dd4:	ea44 4200 	orr.w	r2, r4, r0, lsl #16
 c001dd8:	e9cd 2304 	strd	r2, r3, [sp, #16]
    /* write element  */
    err = FLASH_DEV_NAME.ProgramData(address,
 c001ddc:	2000      	movs	r0, #0
 c001dde:	2208      	movs	r2, #8
 c001de0:	f8d7 a018 	ldr.w	sl, [r7, #24]
 c001de4:	a904      	add	r1, sp, #16
 c001de6:	47d0      	blx	sl
    address += sizeof(NVCNT_ELEMENT_TYPE);
    loop--;
  }

  /* clean huk footprint  */
  element = 0;
 c001de8:	2200      	movs	r2, #0
 c001dea:	2300      	movs	r3, #0
 c001dec:	e9cd 2304 	strd	r2, r3, [sp, #16]
  memset((void *)huk, 0, sizeof(huk));
  if (err == ARM_DRIVER_OK)
 c001df0:	b148      	cbz	r0, c001e06 <tfm_plat_init_nv_counter+0x96>
      BOOT_LOG_ERR("Init BL2 NV Header area: Failed");
 c001df2:	4858      	ldr	r0, [pc, #352]	; (c001f54 <tfm_plat_init_nv_counter+0x1e4>)
    BOOT_LOG_ERR("Wrong BL2 NV Area header");
 c001df4:	f007 f810 	bl	c008e18 <puts>
    return TFM_PLAT_ERR_SYSTEM_ERR;
 c001df8:	2401      	movs	r4, #1
}
 c001dfa:	4620      	mov	r0, r4
 c001dfc:	b008      	add	sp, #32
 c001dfe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      readstatus = false;
 c001e02:	2400      	movs	r4, #0
 c001e04:	e7cd      	b.n	c001da2 <tfm_plat_init_nv_counter+0x32>
    BOOT_LOG_INF("Init BL2 NV Header area: Done");
 c001e06:	4854      	ldr	r0, [pc, #336]	; (c001f58 <tfm_plat_init_nv_counter+0x1e8>)
 c001e08:	f007 f806 	bl	c008e18 <puts>
    BOOT_LOG_INF("Initializing BL2 NV Counters");
 c001e0c:	4853      	ldr	r0, [pc, #332]	; (c001f5c <tfm_plat_init_nv_counter+0x1ec>)
 c001e0e:	f007 f803 	bl	c008e18 <puts>
 c001e12:	2403      	movs	r4, #3
 c001e14:	2500      	movs	r5, #0
  /* initialize only one counter */
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
  {

    /* Check if pages are full, i.e. max number of written elements achieved */
    if (uhNbWrittenElements >= NVCNT_MAX_WRITTEN_ELEMENTS)
 c001e16:	4f52      	ldr	r7, [pc, #328]	; (c001f60 <tfm_plat_init_nv_counter+0x1f0>)
    /* Calculate crc of variable data and virtual address */
    crc = CalculateCrc(data, counter_id);
    /*  build element  */
    element = NVCNT_ELEMENT_VALUE(counter_id, data, crc);
    /* Program variable data + virtual address + crc */
    err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c001e18:	f8df 9154 	ldr.w	r9, [pc, #340]	; c001f70 <tfm_plat_init_nv_counter+0x200>
    if (uhNbWrittenElements >= NVCNT_MAX_WRITTEN_ELEMENTS)
 c001e1c:	683b      	ldr	r3, [r7, #0]
 c001e1e:	f5b3 7ffc 	cmp.w	r3, #504	; 0x1f8
 c001e22:	d263      	bcs.n	c001eec <tfm_plat_init_nv_counter+0x17c>
    crc = CalculateCrc(data, counter_id);
 c001e24:	b2a1      	uxth	r1, r4
 c001e26:	2000      	movs	r0, #0
 c001e28:	f7ff ff3a 	bl	c001ca0 <CalculateCrc>
    element = NVCNT_ELEMENT_VALUE(counter_id, data, crc);
 c001e2c:	ea44 4000 	orr.w	r0, r4, r0, lsl #16
 c001e30:	e9cd 0506 	strd	r0, r5, [sp, #24]
    err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c001e34:	2208      	movs	r2, #8
 c001e36:	f8d9 0000 	ldr.w	r0, [r9]
 c001e3a:	a906      	add	r1, sp, #24
 c001e3c:	47d0      	blx	sl
                                     &element,
                                     NVCNT_ELEMENT_SIZE);
    /* If program operation was failed, a Flash error code is returned */
    if (err != ARM_DRIVER_OK)
 c001e3e:	2800      	cmp	r0, #0
 c001e40:	d154      	bne.n	c001eec <tfm_plat_init_nv_counter+0x17c>
    {
      return false;
    }

    /* Increment global variables relative to write operation done*/
    uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c001e42:	f8d9 3000 	ldr.w	r3, [r9]
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
 c001e46:	2d00      	cmp	r5, #0
    uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c001e48:	f103 0308 	add.w	r3, r3, #8
 c001e4c:	f8c9 3000 	str.w	r3, [r9]
    uhNbWrittenElements++;
 c001e50:	683b      	ldr	r3, [r7, #0]
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
 c001e52:	bf08      	it	eq
 c001e54:	2c04      	cmpeq	r4, #4
    uhNbWrittenElements++;
 c001e56:	f103 0301 	add.w	r3, r3, #1
 c001e5a:	603b      	str	r3, [r7, #0]
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
 c001e5c:	d048      	beq.n	c001ef0 <tfm_plat_init_nv_counter+0x180>
 c001e5e:	2404      	movs	r4, #4
 c001e60:	2500      	movs	r5, #0
 c001e62:	e7db      	b.n	c001e1c <tfm_plat_init_nv_counter+0xac>
  BOOT_LOG_INF("Checking BL2 NV Counter consistency");
 c001e64:	483f      	ldr	r0, [pc, #252]	; (c001f64 <tfm_plat_init_nv_counter+0x1f4>)
 c001e66:	f006 ffd7 	bl	c008e18 <puts>
  if (tfm_plat_read_nv_counter(PLAT_NV_COUNTER_3, sizeof(counter_value),
 c001e6a:	2104      	movs	r1, #4
 c001e6c:	2003      	movs	r0, #3
 c001e6e:	aa06      	add	r2, sp, #24
 c001e70:	f7ff ff3a 	bl	c001ce8 <tfm_plat_read_nv_counter>
 c001e74:	b120      	cbz	r0, c001e80 <tfm_plat_init_nv_counter+0x110>
    BOOT_LOG_ERR("NV Counter Not consistent %d", PLAT_NV_COUNTER_3);
 c001e76:	2103      	movs	r1, #3
    BOOT_LOG_ERR("NV Counter Not consistent %d", PLAT_NV_COUNTER_4);
 c001e78:	483b      	ldr	r0, [pc, #236]	; (c001f68 <tfm_plat_init_nv_counter+0x1f8>)
 c001e7a:	f006 ff47 	bl	c008d0c <iprintf>
    return TFM_PLAT_ERR_SYSTEM_ERR;
 c001e7e:	e7bb      	b.n	c001df8 <tfm_plat_init_nv_counter+0x88>
  BOOT_LOG_INF("Consistent BL2 NV Counter %d  = 0x%x", PLAT_NV_COUNTER_3, counter_value);
 c001e80:	2103      	movs	r1, #3
 c001e82:	9a06      	ldr	r2, [sp, #24]
 c001e84:	4839      	ldr	r0, [pc, #228]	; (c001f6c <tfm_plat_init_nv_counter+0x1fc>)
 c001e86:	f006 ff41 	bl	c008d0c <iprintf>
  if (tfm_plat_read_nv_counter(PLAT_NV_COUNTER_4, sizeof(counter_value),
 c001e8a:	2104      	movs	r1, #4
 c001e8c:	aa06      	add	r2, sp, #24
 c001e8e:	4608      	mov	r0, r1
 c001e90:	f7ff ff2a 	bl	c001ce8 <tfm_plat_read_nv_counter>
 c001e94:	4604      	mov	r4, r0
 c001e96:	b108      	cbz	r0, c001e9c <tfm_plat_init_nv_counter+0x12c>
    BOOT_LOG_ERR("NV Counter Not consistent %d", PLAT_NV_COUNTER_4);
 c001e98:	2104      	movs	r1, #4
 c001e9a:	e7ed      	b.n	c001e78 <tfm_plat_init_nv_counter+0x108>
  uwAddressNextWrite = PAGE_HEADER_SIZE;
 c001e9c:	2540      	movs	r5, #64	; 0x40
  uhNbWrittenElements = 0U;
 c001e9e:	4f30      	ldr	r7, [pc, #192]	; (c001f60 <tfm_plat_init_nv_counter+0x1f0>)
  uwAddressNextWrite = PAGE_HEADER_SIZE;
 c001ea0:	4e33      	ldr	r6, [pc, #204]	; (c001f70 <tfm_plat_init_nv_counter+0x200>)
  BOOT_LOG_INF("Consistent BL2 NV Counter %d  = 0x%x", PLAT_NV_COUNTER_4, counter_value);
 c001ea2:	2104      	movs	r1, #4
 c001ea4:	9a06      	ldr	r2, [sp, #24]
 c001ea6:	4831      	ldr	r0, [pc, #196]	; (c001f6c <tfm_plat_init_nv_counter+0x1fc>)
 c001ea8:	f006 ff30 	bl	c008d0c <iprintf>
  uhNbWrittenElements = 0U;
 c001eac:	603c      	str	r4, [r7, #0]
  uwAddressNextWrite = PAGE_HEADER_SIZE;
 c001eae:	6035      	str	r5, [r6, #0]
    err = FLASH_DEV_NAME.ReadData(BL2_NV_COUNTERS_AREA_ADDR + varidx, &addressvalue,
 c001eb0:	2208      	movs	r2, #8
 c001eb2:	4628      	mov	r0, r5
 c001eb4:	eb0d 0102 	add.w	r1, sp, r2
 c001eb8:	47c0      	blx	r8
    if ((err == ARM_DRIVER_ERROR_SPECIFIC) || (addressvalue != NVCNT_MASK_FULL))
 c001eba:	1d83      	adds	r3, r0, #6
 c001ebc:	d006      	beq.n	c001ecc <tfm_plat_init_nv_counter+0x15c>
 c001ebe:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c001ec2:	3301      	adds	r3, #1
 c001ec4:	bf08      	it	eq
 c001ec6:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c001eca:	d00b      	beq.n	c001ee4 <tfm_plat_init_nv_counter+0x174>
      uhNbWrittenElements++;
 c001ecc:	683b      	ldr	r3, [r7, #0]
  for (varidx = PAGE_HEADER_SIZE; varidx < BL2_NV_COUNTERS_AREA_SIZE; varidx += NVCNT_ELEMENT_SIZE)
 c001ece:	3508      	adds	r5, #8
      uhNbWrittenElements++;
 c001ed0:	3301      	adds	r3, #1
 c001ed2:	603b      	str	r3, [r7, #0]
      uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c001ed4:	6833      	ldr	r3, [r6, #0]
  for (varidx = PAGE_HEADER_SIZE; varidx < BL2_NV_COUNTERS_AREA_SIZE; varidx += NVCNT_ELEMENT_SIZE)
 c001ed6:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
      uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c001eda:	f103 0308 	add.w	r3, r3, #8
 c001ede:	6033      	str	r3, [r6, #0]
  for (varidx = PAGE_HEADER_SIZE; varidx < BL2_NV_COUNTERS_AREA_SIZE; varidx += NVCNT_ELEMENT_SIZE)
 c001ee0:	d1e6      	bne.n	c001eb0 <tfm_plat_init_nv_counter+0x140>
 c001ee2:	e78a      	b.n	c001dfa <tfm_plat_init_nv_counter+0x8a>
      if (err != ARM_DRIVER_OK)
 c001ee4:	1e04      	subs	r4, r0, #0
 c001ee6:	bf18      	it	ne
 c001ee8:	2401      	movne	r4, #1
 c001eea:	e786      	b.n	c001dfa <tfm_plat_init_nv_counter+0x8a>
      BOOT_LOG_ERR("Init BL2 NV counters : Failed");
 c001eec:	4821      	ldr	r0, [pc, #132]	; (c001f74 <tfm_plat_init_nv_counter+0x204>)
 c001eee:	e781      	b.n	c001df4 <tfm_plat_init_nv_counter+0x84>
    BOOT_LOG_INF("Init BL2 NV counters to 0 : Done");
 c001ef0:	4821      	ldr	r0, [pc, #132]	; (c001f78 <tfm_plat_init_nv_counter+0x208>)
 c001ef2:	f006 ff91 	bl	c008e18 <puts>
    BOOT_LOG_INF("BL2 NV Area Initialized : Power Down/reset supported");
 c001ef6:	4821      	ldr	r0, [pc, #132]	; (c001f7c <tfm_plat_init_nv_counter+0x20c>)
 c001ef8:	f006 ff8e 	bl	c008e18 <puts>
  BOOT_LOG_INF("Checking BL2 NV area");
 c001efc:	4820      	ldr	r0, [pc, #128]	; (c001f80 <tfm_plat_init_nv_counter+0x210>)
 c001efe:	f006 ff8b 	bl	c008e18 <puts>
  BOOT_LOG_INF("Checking BL2 NV area header");
 c001f02:	4820      	ldr	r0, [pc, #128]	; (c001f84 <tfm_plat_init_nv_counter+0x214>)
 c001f04:	f006 ff88 	bl	c008e18 <puts>
    err = FLASH_DEV_NAME.ReadData(address, (void *)&addressvalue,
 c001f08:	2208      	movs	r2, #8
 c001f0a:	2000      	movs	r0, #0
 c001f0c:	a906      	add	r1, sp, #24
 c001f0e:	47c0      	blx	r8
    if ((err == ARM_DRIVER_OK) && (addressvalue != NVCNT_PAGESTAT_ERASED))
 c001f10:	4604      	mov	r4, r0
 c001f12:	b980      	cbnz	r0, c001f36 <tfm_plat_init_nv_counter+0x1c6>
 c001f14:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 c001f18:	1c59      	adds	r1, r3, #1
 c001f1a:	bf08      	it	eq
 c001f1c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c001f20:	d009      	beq.n	c001f36 <tfm_plat_init_nv_counter+0x1c6>
      crc = CalculateCrc(NVCNT_DATA_VALUE(addressvalue), NVCNT_ID_VALUE(addressvalue));
 c001f22:	4618      	mov	r0, r3
 c001f24:	b291      	uxth	r1, r2
 c001f26:	f7ff febb 	bl	c001ca0 <CalculateCrc>
      if (crc == NVCNT_CRC_VALUE(addressvalue))
 c001f2a:	f8bd 201a 	ldrh.w	r2, [sp, #26]
 c001f2e:	9b07      	ldr	r3, [sp, #28]
 c001f30:	4290      	cmp	r0, r2
 c001f32:	d101      	bne.n	c001f38 <tfm_plat_init_nv_counter+0x1c8>
        huk[loop] = NVCNT_DATA_VALUE(addressvalue);
 c001f34:	9301      	str	r3, [sp, #4]
 c001f36:	2401      	movs	r4, #1
  if (huk[0] != NVCNT_HEADER_VALUE)
 c001f38:	9b01      	ldr	r3, [sp, #4]
 c001f3a:	42b3      	cmp	r3, r6
 c001f3c:	d101      	bne.n	c001f42 <tfm_plat_init_nv_counter+0x1d2>
  if (!Check_Header())
 c001f3e:	2c00      	cmp	r4, #0
 c001f40:	d190      	bne.n	c001e64 <tfm_plat_init_nv_counter+0xf4>
    BOOT_LOG_ERR("Wrong BL2 NV Area header");
 c001f42:	4811      	ldr	r0, [pc, #68]	; (c001f88 <tfm_plat_init_nv_counter+0x218>)
 c001f44:	e756      	b.n	c001df4 <tfm_plat_init_nv_counter+0x84>
 c001f46:	bf00      	nop
 c001f48:	0c00a264 	.word	0x0c00a264
 c001f4c:	aaddeecc 	.word	0xaaddeecc
 c001f50:	0c009f6c 	.word	0x0c009f6c
 c001f54:	0c009fb0 	.word	0x0c009fb0
 c001f58:	0c009fd7 	.word	0x0c009fd7
 c001f5c:	0c009ffc 	.word	0x0c009ffc
 c001f60:	3003011c 	.word	0x3003011c
 c001f64:	0c00a07f 	.word	0x0c00a07f
 c001f68:	0c00a0aa 	.word	0x0c00a0aa
 c001f6c:	0c00a0cf 	.word	0x0c00a0cf
 c001f70:	30030000 	.word	0x30030000
 c001f74:	0c00a0fc 	.word	0x0c00a0fc
 c001f78:	0c00a121 	.word	0x0c00a121
 c001f7c:	0c00a149 	.word	0x0c00a149
 c001f80:	0c00a020 	.word	0x0c00a020
 c001f84:	0c00a03c 	.word	0x0c00a03c
 c001f88:	0c00a05f 	.word	0x0c00a05f

0c001f8c <tfm_plat_set_nv_counter>:
{
 c001f8c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c001f90:	460d      	mov	r5, r1
  if ((tfm_plat_read_nv_counter(CounterId, sizeof(current_value), (uint8_t *)&current_value)
 c001f92:	aa01      	add	r2, sp, #4
 c001f94:	2104      	movs	r1, #4
{
 c001f96:	4606      	mov	r6, r0
  if ((tfm_plat_read_nv_counter(CounterId, sizeof(current_value), (uint8_t *)&current_value)
 c001f98:	f7ff fea6 	bl	c001ce8 <tfm_plat_read_nv_counter>
 c001f9c:	4604      	mov	r4, r0
 c001f9e:	bb60      	cbnz	r0, c001ffa <tfm_plat_set_nv_counter+0x6e>
       != TFM_PLAT_ERR_SUCCESS) || (Data < current_value))
 c001fa0:	9b01      	ldr	r3, [sp, #4]
 c001fa2:	42ab      	cmp	r3, r5
 c001fa4:	d829      	bhi.n	c001ffa <tfm_plat_set_nv_counter+0x6e>
  if (current_value == Data)
 c001fa6:	d024      	beq.n	c001ff2 <tfm_plat_set_nv_counter+0x66>
  if (uhNbWrittenElements >= NVCNT_MAX_WRITTEN_ELEMENTS)
 c001fa8:	4f16      	ldr	r7, [pc, #88]	; (c002004 <tfm_plat_set_nv_counter+0x78>)
 c001faa:	683b      	ldr	r3, [r7, #0]
 c001fac:	f5b3 7ffc 	cmp.w	r3, #504	; 0x1f8
 c001fb0:	d225      	bcs.n	c001ffe <tfm_plat_set_nv_counter+0x72>
  crc = CalculateCrc(Data, CounterId);
 c001fb2:	4631      	mov	r1, r6
 c001fb4:	4628      	mov	r0, r5
 c001fb6:	f7ff fe73 	bl	c001ca0 <CalculateCrc>
  err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c001fba:	2208      	movs	r2, #8
 c001fbc:	f8df 8050 	ldr.w	r8, [pc, #80]	; c002010 <tfm_plat_set_nv_counter+0x84>
 c001fc0:	4b11      	ldr	r3, [pc, #68]	; (c002008 <tfm_plat_set_nv_counter+0x7c>)
  element = NVCNT_ELEMENT_VALUE(CounterId, Data, crc);
 c001fc2:	ea46 4000 	orr.w	r0, r6, r0, lsl #16
 c001fc6:	e9cd 0502 	strd	r0, r5, [sp, #8]
  err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c001fca:	699b      	ldr	r3, [r3, #24]
 c001fcc:	f8d8 0000 	ldr.w	r0, [r8]
 c001fd0:	eb0d 0102 	add.w	r1, sp, r2
 c001fd4:	4798      	blx	r3
  if (err != ARM_DRIVER_OK)
 c001fd6:	b980      	cbnz	r0, c001ffa <tfm_plat_set_nv_counter+0x6e>
  uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c001fd8:	f8d8 3000 	ldr.w	r3, [r8]
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c001fdc:	462a      	mov	r2, r5
  uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c001fde:	3308      	adds	r3, #8
 c001fe0:	f8c8 3000 	str.w	r3, [r8]
  uhNbWrittenElements++;
 c001fe4:	683b      	ldr	r3, [r7, #0]
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c001fe6:	4631      	mov	r1, r6
  uhNbWrittenElements++;
 c001fe8:	3301      	adds	r3, #1
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c001fea:	4808      	ldr	r0, [pc, #32]	; (c00200c <tfm_plat_set_nv_counter+0x80>)
  uhNbWrittenElements++;
 c001fec:	603b      	str	r3, [r7, #0]
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c001fee:	f006 fe8d 	bl	c008d0c <iprintf>
}
 c001ff2:	4620      	mov	r0, r4
 c001ff4:	b004      	add	sp, #16
 c001ff6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return TFM_PLAT_ERR_SYSTEM_ERR;
 c001ffa:	2401      	movs	r4, #1
 c001ffc:	e7f9      	b.n	c001ff2 <tfm_plat_set_nv_counter+0x66>
    return TFM_PLAT_ERR_MAX_VALUE;
 c001ffe:	2402      	movs	r4, #2
 c002000:	e7f7      	b.n	c001ff2 <tfm_plat_set_nv_counter+0x66>
 c002002:	bf00      	nop
 c002004:	3003011c 	.word	0x3003011c
 c002008:	0c00a264 	.word	0x0c00a264
 c00200c:	0c00a185 	.word	0x0c00a185
 c002010:	30030000 	.word	0x30030000

0c002014 <boot_platform_noimage>:
  __HAL_RCC_GPIOA_CLK_ENABLE();
 c002014:	4b33      	ldr	r3, [pc, #204]	; (c0020e4 <boot_platform_noimage+0xd0>)
{
 c002016:	b500      	push	{lr}
  __HAL_RCC_GPIOA_CLK_ENABLE();
 c002018:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 c00201a:	b089      	sub	sp, #36	; 0x24
  __HAL_RCC_GPIOA_CLK_ENABLE();
 c00201c:	f042 0201 	orr.w	r2, r2, #1
 c002020:	64da      	str	r2, [r3, #76]	; 0x4c
 c002022:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c002024:	f002 0201 	and.w	r2, r2, #1
 c002028:	9200      	str	r2, [sp, #0]
 c00202a:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 c00202c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00202e:	f042 0202 	orr.w	r2, r2, #2
 c002032:	64da      	str	r2, [r3, #76]	; 0x4c
 c002034:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c002036:	f002 0202 	and.w	r2, r2, #2
 c00203a:	9201      	str	r2, [sp, #4]
 c00203c:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 c00203e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c002040:	f042 0204 	orr.w	r2, r2, #4
 c002044:	64da      	str	r2, [r3, #76]	; 0x4c
 c002046:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c002048:	f002 0204 	and.w	r2, r2, #4
 c00204c:	9202      	str	r2, [sp, #8]
 c00204e:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 c002050:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c002052:	f042 0208 	orr.w	r2, r2, #8
 c002056:	64da      	str	r2, [r3, #76]	; 0x4c
 c002058:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00205a:	f002 0208 	and.w	r2, r2, #8
 c00205e:	9203      	str	r2, [sp, #12]
 c002060:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 c002062:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c002064:	f042 0210 	orr.w	r2, r2, #16
 c002068:	64da      	str	r2, [r3, #76]	; 0x4c
 c00206a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00206c:	f002 0210 	and.w	r2, r2, #16
 c002070:	9204      	str	r2, [sp, #16]
 c002072:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 c002074:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c002076:	f042 0220 	orr.w	r2, r2, #32
 c00207a:	64da      	str	r2, [r3, #76]	; 0x4c
 c00207c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00207e:	f002 0220 	and.w	r2, r2, #32
 c002082:	9205      	str	r2, [sp, #20]
 c002084:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 c002086:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c002088:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 c00208c:	64da      	str	r2, [r3, #76]	; 0x4c
 c00208e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c002090:	f002 0240 	and.w	r2, r2, #64	; 0x40
 c002094:	9206      	str	r2, [sp, #24]
 c002096:	9a06      	ldr	r2, [sp, #24]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 c002098:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00209a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 c00209e:	64da      	str	r2, [r3, #76]	; 0x4c
 c0020a0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  GPIOA_S->SECCFGR = 0x0;
 c0020a2:	4a11      	ldr	r2, [pc, #68]	; (c0020e8 <boot_platform_noimage+0xd4>)
  __HAL_RCC_GPIOH_CLK_ENABLE();
 c0020a4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 c0020a8:	9307      	str	r3, [sp, #28]
 c0020aa:	9b07      	ldr	r3, [sp, #28]
  GPIOA_S->SECCFGR = 0x0;
 c0020ac:	2300      	movs	r3, #0
 c0020ae:	6313      	str	r3, [r2, #48]	; 0x30
  GPIOB_S->SECCFGR = 0x0;
 c0020b0:	f8c2 3430 	str.w	r3, [r2, #1072]	; 0x430
  GPIOC_S->SECCFGR = 0x0;
 c0020b4:	f8c2 3830 	str.w	r3, [r2, #2096]	; 0x830
  GPIOD_S->SECCFGR = 0x0;
 c0020b8:	f8c2 3c30 	str.w	r3, [r2, #3120]	; 0xc30
  GPIOB_S->SECCFGR = 0x0;
 c0020bc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  GPIOE_S->SECCFGR = 0x0;
 c0020c0:	f8c2 3c30 	str.w	r3, [r2, #3120]	; 0xc30
  GPIOC_S->SECCFGR = 0x0;
 c0020c4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  GPIOF_S->SECCFGR = 0x0;
 c0020c8:	f8c2 3c30 	str.w	r3, [r2, #3120]	; 0xc30
  GPIOD_S->SECCFGR = 0x0;
 c0020cc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  GPIOG_S->SECCFGR = 0x0;
 c0020d0:	f8c2 3c30 	str.w	r3, [r2, #3120]	; 0xc30
  GPIOE_S->SECCFGR = 0x0;
 c0020d4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  GPIOH_S->SECCFGR = 0x0;
 c0020d8:	f8c2 3c30 	str.w	r3, [r2, #3120]	; 0xc30
  TFM_LL_SECU_SetLoaderCodeSecure();
 c0020dc:	f000 fc2e 	bl	c00293c <TFM_LL_SECU_SetLoaderCodeSecure>
  execute_loader();
 c0020e0:	f00a fbde 	bl	c00c8a0 <execute_loader>
 c0020e4:	50021000 	.word	0x50021000
 c0020e8:	52020000 	.word	0x52020000

0c0020ec <HAL_InitTick>:
  uint32_t ticks = SystemCoreClock ;
 c0020ec:	4b04      	ldr	r3, [pc, #16]	; (c002100 <HAL_InitTick+0x14>)
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 c0020ee:	2000      	movs	r0, #0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 c0020f0:	681a      	ldr	r2, [r3, #0]
 c0020f2:	4b04      	ldr	r3, [pc, #16]	; (c002104 <HAL_InitTick+0x18>)
 c0020f4:	3a01      	subs	r2, #1
 c0020f6:	605a      	str	r2, [r3, #4]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 c0020f8:	2205      	movs	r2, #5
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 c0020fa:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 c0020fc:	601a      	str	r2, [r3, #0]
}
 c0020fe:	4770      	bx	lr
 c002100:	3003004c 	.word	0x3003004c
 c002104:	e000e010 	.word	0xe000e010

0c002108 <HAL_GetTick>:
  t2 =  SysTick->VAL;
 c002108:	490f      	ldr	r1, [pc, #60]	; (c002148 <HAL_GetTick+0x40>)
 c00210a:	4a10      	ldr	r2, [pc, #64]	; (c00214c <HAL_GetTick+0x44>)
  if (t2 <= t1)
 c00210c:	4810      	ldr	r0, [pc, #64]	; (c002150 <HAL_GetTick+0x48>)
{
 c00210e:	b530      	push	{r4, r5, lr}
  if (t2 <= t1)
 c002110:	6803      	ldr	r3, [r0, #0]
  t2 =  SysTick->VAL;
 c002112:	688c      	ldr	r4, [r1, #8]
  if (t2 <= t1)
 c002114:	6815      	ldr	r5, [r2, #0]
 c002116:	42a3      	cmp	r3, r4
 c002118:	442b      	add	r3, r5
  if (tdelta > (SystemCoreClock / (1000U)))
 c00211a:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    tdelta += t1 + SysTick->LOAD - t2;
 c00211e:	bf3c      	itt	cc
 c002120:	6849      	ldrcc	r1, [r1, #4]
 c002122:	185b      	addcc	r3, r3, r1
  if (tdelta > (SystemCoreClock / (1000U)))
 c002124:	490b      	ldr	r1, [pc, #44]	; (c002154 <HAL_GetTick+0x4c>)
    tdelta += t1 + SysTick->LOAD - t2;
 c002126:	1b1b      	subs	r3, r3, r4
  if (tdelta > (SystemCoreClock / (1000U)))
 c002128:	6809      	ldr	r1, [r1, #0]
 c00212a:	6013      	str	r3, [r2, #0]
 c00212c:	fbb1 f1f5 	udiv	r1, r1, r5
 c002130:	4299      	cmp	r1, r3
 c002132:	4b09      	ldr	r3, [pc, #36]	; (c002158 <HAL_GetTick+0x50>)
 c002134:	d204      	bcs.n	c002140 <HAL_GetTick+0x38>
    tdelta = 0U;
 c002136:	2500      	movs	r5, #0
 c002138:	6819      	ldr	r1, [r3, #0]
 c00213a:	6015      	str	r5, [r2, #0]
    m_uTick ++;
 c00213c:	3101      	adds	r1, #1
 c00213e:	6019      	str	r1, [r3, #0]
  t1 = t2;
 c002140:	6004      	str	r4, [r0, #0]
}
 c002142:	6818      	ldr	r0, [r3, #0]
 c002144:	bd30      	pop	{r4, r5, pc}
 c002146:	bf00      	nop
 c002148:	e000e010 	.word	0xe000e010
 c00214c:	3003012c 	.word	0x3003012c
 c002150:	30030128 	.word	0x30030128
 c002154:	3003004c 	.word	0x3003004c
 c002158:	30030124 	.word	0x30030124

0c00215c <icache_init>:
{
 c00215c:	b508      	push	{r3, lr}
  if (HAL_ICACHE_Enable() != HAL_OK)
 c00215e:	f001 fd61 	bl	c003c24 <HAL_ICACHE_Enable>
 c002162:	b118      	cbz	r0, c00216c <icache_init+0x10>
}
 c002164:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 c002168:	f00a bbea 	b.w	c00c940 <Error_Handler>
}
 c00216c:	bd08      	pop	{r3, pc}
	...

0c002170 <boot_platform_init>:
{
 c002170:	b530      	push	{r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 c002172:	4c23      	ldr	r4, [pc, #140]	; (c002200 <boot_platform_init+0x90>)
{
 c002174:	b089      	sub	sp, #36	; 0x24
  HAL_Init();
 c002176:	f000 feba 	bl	c002eee <HAL_Init>
  stdio_init();
 c00217a:	f006 fcbb 	bl	c008af4 <stdio_init>
  icache_init();
 c00217e:	f7ff ffed 	bl	c00215c <icache_init>
  TFM_LL_SECU_ApplyRunTimeProtections();
 c002182:	f000 fbfd 	bl	c002980 <TFM_LL_SECU_ApplyRunTimeProtections>
  TFM_LL_SECU_CheckStaticProtections();
 c002186:	f000 fd1d 	bl	c002bc4 <TFM_LL_SECU_CheckStaticProtections>
  __HAL_RCC_PWR_CLK_ENABLE();
 c00218a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c00218c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 c002190:	65a3      	str	r3, [r4, #88]	; 0x58
 c002192:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c002194:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c002198:	9301      	str	r3, [sp, #4]
 c00219a:	9b01      	ldr	r3, [sp, #4]
  HAL_PWREx_EnableSRAM2ContentRetention();
 c00219c:	f001 fd8c 	bl	c003cb8 <HAL_PWREx_EnableSRAM2ContentRetention>
  TFM_LL_SECU_ApplyRunTimeProtections();
 c0021a0:	f000 fbee 	bl	c002980 <TFM_LL_SECU_ApplyRunTimeProtections>
  TFM_LL_SECU_CheckStaticProtections();
 c0021a4:	f000 fd0e 	bl	c002bc4 <TFM_LL_SECU_CheckStaticProtections>
  if (FLASH_DEV_NAME.Initialize(NULL) != ARM_DRIVER_OK)
 c0021a8:	4b16      	ldr	r3, [pc, #88]	; (c002204 <boot_platform_init+0x94>)
 c0021aa:	2000      	movs	r0, #0
 c0021ac:	689b      	ldr	r3, [r3, #8]
 c0021ae:	4798      	blx	r3
 c0021b0:	b120      	cbz	r0, c0021bc <boot_platform_init+0x4c>
    BOOT_LOG_ERR("Error while initializing Flash Interface");
 c0021b2:	4815      	ldr	r0, [pc, #84]	; (c002208 <boot_platform_init+0x98>)
 c0021b4:	f006 fe30 	bl	c008e18 <puts>
    Error_Handler();
 c0021b8:	f00a fbc2 	bl	c00c940 <Error_Handler>
  BUTTON_CLK_ENABLE;
 c0021bc:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  GPIO_Init.Mode      = 0;
 c0021be:	f44f 5500 	mov.w	r5, #8192	; 0x2000
  BUTTON_CLK_ENABLE;
 c0021c2:	f043 0304 	orr.w	r3, r3, #4
 c0021c6:	64e3      	str	r3, [r4, #76]	; 0x4c
 c0021c8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  GPIO_Init.Mode      = 0;
 c0021ca:	2400      	movs	r4, #0
  BUTTON_CLK_ENABLE;
 c0021cc:	f003 0304 	and.w	r3, r3, #4
 c0021d0:	9302      	str	r3, [sp, #8]
 c0021d2:	9b02      	ldr	r3, [sp, #8]
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
 c0021d4:	2302      	movs	r3, #2
  HAL_GPIO_Init(BUTTON_PORT, &GPIO_Init);
 c0021d6:	480d      	ldr	r0, [pc, #52]	; (c00220c <boot_platform_init+0x9c>)
 c0021d8:	a903      	add	r1, sp, #12
  GPIO_Init.Pull      = GPIO_NOPULL;
 c0021da:	e9cd 4305 	strd	r4, r3, [sp, #20]
  GPIO_Init.Mode      = 0;
 c0021de:	e9cd 5403 	strd	r5, r4, [sp, #12]
  GPIO_Init.Alternate = 0;
 c0021e2:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(BUTTON_PORT, &GPIO_Init);
 c0021e4:	f001 fa2a 	bl	c00363c <HAL_GPIO_Init>
  if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) == GPIO_PIN_SET)
 c0021e8:	4629      	mov	r1, r5
 c0021ea:	4808      	ldr	r0, [pc, #32]	; (c00220c <boot_platform_init+0x9c>)
 c0021ec:	f001 faf0 	bl	c0037d0 <HAL_GPIO_ReadPin>
 c0021f0:	2801      	cmp	r0, #1
 c0021f2:	d101      	bne.n	c0021f8 <boot_platform_init+0x88>
    boot_platform_noimage();
 c0021f4:	f7ff ff0e 	bl	c002014 <boot_platform_noimage>
}
 c0021f8:	4620      	mov	r0, r4
 c0021fa:	b009      	add	sp, #36	; 0x24
 c0021fc:	bd30      	pop	{r4, r5, pc}
 c0021fe:	bf00      	nop
 c002200:	50021000 	.word	0x50021000
 c002204:	0c00a264 	.word	0x0c00a264
 c002208:	0c00a1dc 	.word	0x0c00a1dc
 c00220c:	52020800 	.word	0x52020800

0c002210 <USART_GetVersion>:
  0  /* Reserved */
};

static ARM_DRIVER_VERSION USART_GetVersion(void)
{
  return DriverVersion;
 c002210:	4b06      	ldr	r3, [pc, #24]	; (c00222c <USART_GetVersion+0x1c>)
{
 c002212:	b082      	sub	sp, #8
  return DriverVersion;
 c002214:	6818      	ldr	r0, [r3, #0]
 c002216:	2300      	movs	r3, #0
 c002218:	b282      	uxth	r2, r0
 c00221a:	f362 030f 	bfi	r3, r2, #0, #16
 c00221e:	0c00      	lsrs	r0, r0, #16
 c002220:	f360 431f 	bfi	r3, r0, #16, #16
}
 c002224:	4618      	mov	r0, r3
 c002226:	b002      	add	sp, #8
 c002228:	4770      	bx	lr
 c00222a:	bf00      	nop
 c00222c:	0c00a20c 	.word	0x0c00a20c

0c002230 <USART_GetCapabilities>:

static ARM_USART_CAPABILITIES USART_GetCapabilities(void)
{
  return DriverCapabilities;
}
 c002230:	2001      	movs	r0, #1
 c002232:	4770      	bx	lr

0c002234 <USART0_Uninitialize>:

static int32_t USART0_Uninitialize(void)
{
  /* Nothing to be done */
  return ARM_DRIVER_OK;
}
 c002234:	2000      	movs	r0, #0
 c002236:	4770      	bx	lr

0c002238 <USART0_PowerControl>:

static int32_t USART0_PowerControl(ARM_POWER_STATE state)
{
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c002238:	f06f 0003 	mvn.w	r0, #3
 c00223c:	4770      	bx	lr

0c00223e <USART0_Transfer>:
  ARG_UNUSED(data_out);
  ARG_UNUSED(data_in);
  ARG_UNUSED(num);

  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c00223e:	f06f 0003 	mvn.w	r0, #3
 c002242:	4770      	bx	lr

0c002244 <USART0_GetTxCount>:

static uint32_t USART0_GetTxCount(void)
{
  return (uint32_t)ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c002244:	f06f 0003 	mvn.w	r0, #3
 c002248:	4770      	bx	lr

0c00224a <USART0_Control>:
  return (uint32_t)ARM_DRIVER_ERROR_UNSUPPORTED;
}
static int32_t USART0_Control(uint32_t control, uint32_t arg)
{
  return ARM_DRIVER_OK;
}
 c00224a:	2000      	movs	r0, #0
 c00224c:	4770      	bx	lr

0c00224e <USART0_GetStatus>:

static ARM_USART_STATUS USART0_GetStatus(void)
{
  ARM_USART_STATUS status = {0, 0, 0, 0, 0, 0, 0, 0};
 c00224e:	2300      	movs	r3, #0
{
 c002250:	b082      	sub	sp, #8
  ARM_USART_STATUS status = {0, 0, 0, 0, 0, 0, 0, 0};
 c002252:	9301      	str	r3, [sp, #4]
  return status;
 c002254:	9801      	ldr	r0, [sp, #4]
}
 c002256:	b002      	add	sp, #8
 c002258:	4770      	bx	lr

0c00225a <USART0_GetModemStatus>:
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}

static ARM_USART_MODEM_STATUS USART0_GetModemStatus(void)
{
  ARM_USART_MODEM_STATUS modem_status = {0, 0, 0, 0, 0};
 c00225a:	2300      	movs	r3, #0
{
 c00225c:	b082      	sub	sp, #8
  ARM_USART_MODEM_STATUS modem_status = {0, 0, 0, 0, 0};
 c00225e:	9301      	str	r3, [sp, #4]
  return modem_status;
 c002260:	9801      	ldr	r0, [sp, #4]
}
 c002262:	b002      	add	sp, #8
 c002264:	4770      	bx	lr
	...

0c002268 <USART0_Receive>:
{
 c002268:	b510      	push	{r4, lr}
 c00226a:	460c      	mov	r4, r1
  if ((data == NULL) || (num == 0U))
 c00226c:	4601      	mov	r1, r0
 c00226e:	b130      	cbz	r0, c00227e <USART0_Receive+0x16>
 c002270:	b12c      	cbz	r4, c00227e <USART0_Receive+0x16>
  HAL_UART_Receive_IT(&uart_device, data, num);
 c002272:	4804      	ldr	r0, [pc, #16]	; (c002284 <USART0_Receive+0x1c>)
 c002274:	b2a2      	uxth	r2, r4
 c002276:	f002 fa87 	bl	c004788 <HAL_UART_Receive_IT>
  return num;
 c00227a:	4620      	mov	r0, r4
}
 c00227c:	bd10      	pop	{r4, pc}
    return ARM_DRIVER_ERROR_PARAMETER;
 c00227e:	f06f 0004 	mvn.w	r0, #4
 c002282:	e7fb      	b.n	c00227c <USART0_Receive+0x14>
 c002284:	30030134 	.word	0x30030134

0c002288 <USART0_Send>:
{
 c002288:	b508      	push	{r3, lr}
  if ((data == NULL) || (num == 0U))
 c00228a:	b148      	cbz	r0, c0022a0 <USART0_Send+0x18>
 c00228c:	b141      	cbz	r1, c0022a0 <USART0_Send+0x18>
  HAL_UART_Transmit(&uart_device, (uint8_t *) data, num,  1000);
 c00228e:	b28a      	uxth	r2, r1
 c002290:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 c002294:	4601      	mov	r1, r0
 c002296:	4804      	ldr	r0, [pc, #16]	; (c0022a8 <USART0_Send+0x20>)
 c002298:	f002 f949 	bl	c00452e <HAL_UART_Transmit>
  return ARM_DRIVER_OK;
 c00229c:	2000      	movs	r0, #0
}
 c00229e:	bd08      	pop	{r3, pc}
    return ARM_DRIVER_ERROR_PARAMETER;
 c0022a0:	f06f 0004 	mvn.w	r0, #4
 c0022a4:	e7fb      	b.n	c00229e <USART0_Send+0x16>
 c0022a6:	bf00      	nop
 c0022a8:	30030134 	.word	0x30030134

0c0022ac <USART0_Initialize>:
{
 c0022ac:	b510      	push	{r4, lr}
  COM_TX_GPIO_CLK_ENABLE();
 c0022ae:	4c2b      	ldr	r4, [pc, #172]	; (c00235c <USART0_Initialize+0xb0>)
{
 c0022b0:	b08a      	sub	sp, #40	; 0x28
  COM_TX_GPIO_CLK_ENABLE();
 c0022b2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 c0022b4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c0022b8:	64e3      	str	r3, [r4, #76]	; 0x4c
 c0022ba:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 c0022bc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 c0022c0:	9301      	str	r3, [sp, #4]
 c0022c2:	9b01      	ldr	r3, [sp, #4]
 c0022c4:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c0022c6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 c0022ca:	65a3      	str	r3, [r4, #88]	; 0x58
 c0022cc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c0022ce:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c0022d2:	9302      	str	r3, [sp, #8]
 c0022d4:	9b02      	ldr	r3, [sp, #8]
 c0022d6:	f001 fcdd 	bl	c003c94 <HAL_PWREx_EnableVddIO2>
  COM_RX_GPIO_CLK_ENABLE();
 c0022da:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
 c0022dc:	2280      	movs	r2, #128	; 0x80
  COM_RX_GPIO_CLK_ENABLE();
 c0022de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c0022e2:	64e3      	str	r3, [r4, #76]	; 0x4c
 c0022e4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c0022e6:	a905      	add	r1, sp, #20
  COM_RX_GPIO_CLK_ENABLE();
 c0022e8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 c0022ec:	9303      	str	r3, [sp, #12]
 c0022ee:	9b03      	ldr	r3, [sp, #12]
  COM_CLK_ENABLE();
 c0022f0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c0022f2:	481b      	ldr	r0, [pc, #108]	; (c002360 <USART0_Initialize+0xb4>)
  COM_CLK_ENABLE();
 c0022f4:	f043 0301 	orr.w	r3, r3, #1
 c0022f8:	65e3      	str	r3, [r4, #92]	; 0x5c
 c0022fa:	6de3      	ldr	r3, [r4, #92]	; 0x5c
  GPIO_Init.Alternate = COM_TX_AF;
 c0022fc:	2408      	movs	r4, #8
  COM_CLK_ENABLE();
 c0022fe:	f003 0301 	and.w	r3, r3, #1
 c002302:	9304      	str	r3, [sp, #16]
 c002304:	9b04      	ldr	r3, [sp, #16]
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
 c002306:	2302      	movs	r3, #2
 c002308:	e9cd 2305 	strd	r2, r3, [sp, #20]
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
 c00230c:	9308      	str	r3, [sp, #32]
  GPIO_Init.Pull      = GPIO_PULLUP;
 c00230e:	2301      	movs	r3, #1
  GPIO_Init.Alternate = COM_TX_AF;
 c002310:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_Init.Pull      = GPIO_PULLUP;
 c002312:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c002314:	f001 f992 	bl	c00363c <HAL_GPIO_Init>
  GPIO_Init.Pin       = COM_RX_PIN;
 c002318:	f44f 7380 	mov.w	r3, #256	; 0x100
  HAL_GPIO_Init(COM_RX_GPIO_PORT, &GPIO_Init);
 c00231c:	a905      	add	r1, sp, #20
 c00231e:	4810      	ldr	r0, [pc, #64]	; (c002360 <USART0_Initialize+0xb4>)
  GPIO_Init.Pin       = COM_RX_PIN;
 c002320:	9305      	str	r3, [sp, #20]
  GPIO_Init.Alternate = COM_RX_AF;
 c002322:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(COM_RX_GPIO_PORT, &GPIO_Init);
 c002324:	f001 f98a 	bl	c00363c <HAL_GPIO_Init>
  uart_device.Init.BaudRate       = 115200;
 c002328:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  uart_device.Instance = COM_INSTANCE;
 c00232c:	480d      	ldr	r0, [pc, #52]	; (c002364 <USART0_Initialize+0xb8>)
  uart_device.Init.BaudRate       = 115200;
 c00232e:	490e      	ldr	r1, [pc, #56]	; (c002368 <USART0_Initialize+0xbc>)
  uart_device.Init.Mode           = UART_MODE_TX_RX;
 c002330:	220c      	movs	r2, #12
  uart_device.Init.BaudRate       = 115200;
 c002332:	e9c0 1300 	strd	r1, r3, [r0]
  uart_device.Init.WordLength     = UART_WORDLENGTH_8B;
 c002336:	2300      	movs	r3, #0
  uart_device.Init.HwFlowCtl      = UART_HWCONTROL_NONE;
 c002338:	e9c0 2305 	strd	r2, r3, [r0, #20]
  uart_device.Init.OverSampling   = UART_OVERSAMPLING_8;
 c00233c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  uart_device.Init.StopBits       = UART_STOPBITS_1;
 c002340:	e9c0 3302 	strd	r3, r3, [r0, #8]
  uart_device.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 c002344:	e9c0 2307 	strd	r2, r3, [r0, #28]
  uart_device.Init.Parity         = UART_PARITY_NONE;
 c002348:	6103      	str	r3, [r0, #16]
  uart_device.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 c00234a:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&uart_device) != HAL_OK)
 c00234c:	f002 f981 	bl	c004652 <HAL_UART_Init>
 c002350:	3800      	subs	r0, #0
 c002352:	bf18      	it	ne
 c002354:	2001      	movne	r0, #1
}
 c002356:	4240      	negs	r0, r0
 c002358:	b00a      	add	sp, #40	; 0x28
 c00235a:	bd10      	pop	{r4, pc}
 c00235c:	50021000 	.word	0x50021000
 c002360:	52021800 	.word	0x52021800
 c002364:	30030134 	.word	0x30030134
 c002368:	50008000 	.word	0x50008000

0c00236c <USART0_SetModemControl>:
 c00236c:	f06f 0003 	mvn.w	r0, #3
 c002370:	4770      	bx	lr

0c002372 <USART0_GetRxCount>:
 c002372:	f06f 0003 	mvn.w	r0, #3
 c002376:	4770      	bx	lr

0c002378 <Flash_GetVersion>:
static ARM_FLASH_STATUS ARM_FLASH0_STATUS = {0, 0, 0};

#if !defined(LOCAL_LOADER_CONFIG)
static ARM_DRIVER_VERSION Flash_GetVersion(void)
{
  return DriverVersion;
 c002378:	4b06      	ldr	r3, [pc, #24]	; (c002394 <Flash_GetVersion+0x1c>)
{
 c00237a:	b082      	sub	sp, #8
  return DriverVersion;
 c00237c:	6818      	ldr	r0, [r3, #0]
 c00237e:	2300      	movs	r3, #0
 c002380:	b282      	uxth	r2, r0
 c002382:	f362 030f 	bfi	r3, r2, #0, #16
 c002386:	0c00      	lsrs	r0, r0, #16
 c002388:	f360 431f 	bfi	r3, r0, #16, #16
}
 c00238c:	4618      	mov	r0, r3
 c00238e:	b002      	add	sp, #8
 c002390:	4770      	bx	lr
 c002392:	bf00      	nop
 c002394:	0c00a260 	.word	0x0c00a260

0c002398 <Flash_GetCapabilities>:

static ARM_FLASH_CAPABILITIES Flash_GetCapabilities(void)
{
  return DriverCapabilities;
}
 c002398:	200c      	movs	r0, #12
 c00239a:	4770      	bx	lr

0c00239c <Flash_Uninitialize>:
}
#if !defined(LOCAL_LOADER_CONFIG)
static int32_t Flash_Uninitialize(void)
{
  return ARM_DRIVER_OK;
}
 c00239c:	2000      	movs	r0, #0
 c00239e:	4770      	bx	lr

0c0023a0 <Flash_PowerControl>:

static int32_t Flash_PowerControl(ARM_POWER_STATE state)
{
  switch (state)
 c0023a0:	2801      	cmp	r0, #1
 c0023a2:	d905      	bls.n	c0023b0 <Flash_PowerControl+0x10>
 c0023a4:	2802      	cmp	r0, #2
  {
    case ARM_POWER_FULL:
      /* Nothing to be done */
      return ARM_DRIVER_OK;
 c0023a6:	bf14      	ite	ne
 c0023a8:	f06f 0004 	mvnne.w	r0, #4
 c0023ac:	2000      	moveq	r0, #0
 c0023ae:	4770      	bx	lr
  switch (state)
 c0023b0:	f06f 0003 	mvn.w	r0, #3
    case ARM_POWER_LOW:
      return ARM_DRIVER_ERROR_UNSUPPORTED;
    default:
      return ARM_DRIVER_ERROR_PARAMETER;
  }
}
 c0023b4:	4770      	bx	lr

0c0023b6 <Flash_EraseChip>:
}
#if !defined(LOCAL_LOADER_CONFIG)
static int32_t Flash_EraseChip(void)
{
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c0023b6:	f06f 0003 	mvn.w	r0, #3
 c0023ba:	4770      	bx	lr

0c0023bc <Flash_GetStatus>:

static ARM_FLASH_STATUS Flash_GetStatus(void)
{
  return ARM_FLASH0_STATUS;
 c0023bc:	4b01      	ldr	r3, [pc, #4]	; (c0023c4 <Flash_GetStatus+0x8>)
 c0023be:	6818      	ldr	r0, [r3, #0]
}
 c0023c0:	4770      	bx	lr
 c0023c2:	bf00      	nop
 c0023c4:	300301c4 	.word	0x300301c4

0c0023c8 <Flash_GetInfo>:
#endif
static ARM_FLASH_INFO *Flash_GetInfo(void)
{
  return ARM_FLASH0_DEV.data;
}
 c0023c8:	4800      	ldr	r0, [pc, #0]	; (c0023cc <Flash_GetInfo+0x4>)
 c0023ca:	4770      	bx	lr
 c0023cc:	0c00a248 	.word	0x0c00a248

0c0023d0 <Flash_Initialize>:
{
 c0023d0:	b508      	push	{r3, lr}
  FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0023d2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c0023d6:	f000 fe3f 	bl	c003058 <FLASH_WaitForLastOperation>
}
 c0023da:	2000      	movs	r0, #0
 c0023dc:	bd08      	pop	{r3, pc}

0c0023de <is_range_secure.isra.0>:
static bool is_range_secure(struct arm_flash_dev_t *flash_dev,
 c0023de:	b570      	push	{r4, r5, r6, lr}
  if (!vect->range)
 c0023e0:	6944      	ldr	r4, [r0, #20]
 c0023e2:	b194      	cbz	r4, c00240a <is_range_secure.isra.0+0x2c>
  for (nb = 0; nb < vect->nb; nb++)
 c0023e4:	2300      	movs	r3, #0
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c0023e6:	3a01      	subs	r2, #1
  for (nb = 0; nb < vect->nb; nb++)
 c0023e8:	6900      	ldr	r0, [r0, #16]
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c0023ea:	440a      	add	r2, r1
 c0023ec:	1d25      	adds	r5, r4, #4
  for (nb = 0; nb < vect->nb; nb++)
 c0023ee:	4283      	cmp	r3, r0
 c0023f0:	d101      	bne.n	c0023f6 <is_range_secure.isra.0+0x18>
  return false;
 c0023f2:	2000      	movs	r0, #0
}
 c0023f4:	bd70      	pop	{r4, r5, r6, pc}
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c0023f6:	f854 6033 	ldr.w	r6, [r4, r3, lsl #3]
 c0023fa:	428e      	cmp	r6, r1
 c0023fc:	d803      	bhi.n	c002406 <is_range_secure.isra.0+0x28>
 c0023fe:	f855 6033 	ldr.w	r6, [r5, r3, lsl #3]
 c002402:	42b2      	cmp	r2, r6
 c002404:	d901      	bls.n	c00240a <is_range_secure.isra.0+0x2c>
  for (nb = 0; nb < vect->nb; nb++)
 c002406:	3301      	adds	r3, #1
 c002408:	e7f1      	b.n	c0023ee <is_range_secure.isra.0+0x10>
    return true;
 c00240a:	2001      	movs	r0, #1
 c00240c:	e7f2      	b.n	c0023f4 <is_range_secure.isra.0+0x16>
	...

0c002410 <Flash_ProgramData>:
{
 c002410:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c002414:	4c30      	ldr	r4, [pc, #192]	; (c0024d8 <Flash_ProgramData+0xc8>)
{
 c002416:	4606      	mov	r6, r0
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c002418:	6823      	ldr	r3, [r4, #0]
{
 c00241a:	4617      	mov	r7, r2
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c00241c:	f36f 0341 	bfc	r3, #1, #1
{
 c002420:	4688      	mov	r8, r1
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c002422:	4601      	mov	r1, r0
 c002424:	482d      	ldr	r0, [pc, #180]	; (c0024dc <Flash_ProgramData+0xcc>)
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c002426:	6023      	str	r3, [r4, #0]
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c002428:	f7ff ffd9 	bl	c0023de <is_range_secure.isra.0>
    write_type = FLASH_TYPEPROGRAM_DOUBLEWORD_NS;
 c00242c:	4b2c      	ldr	r3, [pc, #176]	; (c0024e0 <Flash_ProgramData+0xd0>)
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c00242e:	1e7a      	subs	r2, r7, #1
    write_type = FLASH_TYPEPROGRAM_DOUBLEWORD_NS;
 c002430:	2800      	cmp	r0, #0
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c002432:	4432      	add	r2, r6
    write_type = FLASH_TYPEPROGRAM_DOUBLEWORD_NS;
 c002434:	bf15      	itete	ne
 c002436:	f04f 0901 	movne.w	r9, #1
 c00243a:	4699      	moveq	r9, r3
 c00243c:	f04f 6a40 	movne.w	sl, #201326592	; 0xc000000
 c002440:	f04f 6a00 	moveq.w	sl, #134217728	; 0x8000000
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c002444:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
 c002448:	d20c      	bcs.n	c002464 <Flash_ProgramData+0x54>
  return ((param % flash_dev->data->program_unit) != 0) ? (false) : (true);
 c00244a:	ea46 0507 	orr.w	r5, r6, r7
      (!is_write_aligned(&ARM_FLASH0_DEV, addr))     ||
 c00244e:	f015 0507 	ands.w	r5, r5, #7
 c002452:	d107      	bne.n	c002464 <Flash_ProgramData+0x54>
  for (nb = 0; nb < vect->nb; nb++)
 c002454:	4b21      	ldr	r3, [pc, #132]	; (c0024dc <Flash_ProgramData+0xcc>)
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c002456:	e9d3 c002 	ldrd	ip, r0, [r3, #8]
  for (nb = 0; nb < vect->nb; nb++)
 c00245a:	462b      	mov	r3, r5
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c00245c:	f100 0e04 	add.w	lr, r0, #4
  for (nb = 0; nb < vect->nb; nb++)
 c002460:	4563      	cmp	r3, ip
 c002462:	d108      	bne.n	c002476 <Flash_ProgramData+0x66>
    return ARM_DRIVER_ERROR_PARAMETER;
 c002464:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c002468:	6823      	ldr	r3, [r4, #0]
 c00246a:	f043 0302 	orr.w	r3, r3, #2
 c00246e:	6023      	str	r3, [r4, #0]
}
 c002470:	b002      	add	sp, #8
 c002472:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c002476:	f850 1033 	ldr.w	r1, [r0, r3, lsl #3]
 c00247a:	428e      	cmp	r6, r1
 c00247c:	d303      	bcc.n	c002486 <Flash_ProgramData+0x76>
 c00247e:	f85e 1033 	ldr.w	r1, [lr, r3, lsl #3]
 c002482:	428a      	cmp	r2, r1
 c002484:	d91f      	bls.n	c0024c6 <Flash_ProgramData+0xb6>
  for (nb = 0; nb < vect->nb; nb++)
 c002486:	3301      	adds	r3, #1
 c002488:	e7ea      	b.n	c002460 <Flash_ProgramData+0x50>
  } while ((loop != cnt) && (err == HAL_OK));
 c00248a:	b988      	cbnz	r0, c0024b0 <Flash_ProgramData+0xa0>
    memcpy(&dword, (void *)((uint32_t)data + loop), sizeof(dword));
 c00248c:	466b      	mov	r3, sp
 c00248e:	eb08 0205 	add.w	r2, r8, r5
 c002492:	f858 0005 	ldr.w	r0, [r8, r5]
 c002496:	6851      	ldr	r1, [r2, #4]
 c002498:	c303      	stmia	r3!, {r0, r1}
    err = HAL_FLASH_Program(write_type, (flash_base + addr), dword);
 c00249a:	eb0a 0105 	add.w	r1, sl, r5
 c00249e:	4648      	mov	r0, r9
 c0024a0:	e9dd 2300 	ldrd	r2, r3, [sp]
 c0024a4:	f000 fe16 	bl	c0030d4 <HAL_FLASH_Program>
    loop += sizeof(dword);
 c0024a8:	3508      	adds	r5, #8
  } while ((loop != cnt) && (err == HAL_OK));
 c0024aa:	42af      	cmp	r7, r5
    err = HAL_FLASH_Program(write_type, (flash_base + addr), dword);
 c0024ac:	4606      	mov	r6, r0
  } while ((loop != cnt) && (err == HAL_OK));
 c0024ae:	d1ec      	bne.n	c00248a <Flash_ProgramData+0x7a>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c0024b0:	6823      	ldr	r3, [r4, #0]
 c0024b2:	f36f 0300 	bfc	r3, #0, #1
 c0024b6:	6023      	str	r3, [r4, #0]
  HAL_FLASH_Lock();
 c0024b8:	f000 fd9e 	bl	c002ff8 <HAL_FLASH_Lock>
  return (err == HAL_OK) ? ARM_DRIVER_OK : ARM_DRIVER_ERROR;
 c0024bc:	1e30      	subs	r0, r6, #0
 c0024be:	bf18      	it	ne
 c0024c0:	2001      	movne	r0, #1
 c0024c2:	4240      	negs	r0, r0
 c0024c4:	e7d4      	b.n	c002470 <Flash_ProgramData+0x60>
  HAL_FLASH_Unlock();
 c0024c6:	f000 fd77 	bl	c002fb8 <HAL_FLASH_Unlock>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c0024ca:	6823      	ldr	r3, [r4, #0]
    err = HAL_FLASH_Program(write_type, (flash_base + addr), dword);
 c0024cc:	44b2      	add	sl, r6
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c0024ce:	f043 0301 	orr.w	r3, r3, #1
 c0024d2:	6023      	str	r3, [r4, #0]
 c0024d4:	e7da      	b.n	c00248c <Flash_ProgramData+0x7c>
 c0024d6:	bf00      	nop
 c0024d8:	300301c4 	.word	0x300301c4
 c0024dc:	30030008 	.word	0x30030008
 c0024e0:	80000001 	.word	0x80000001

0c0024e4 <Flash_EraseSector>:
{
 c0024e4:	b530      	push	{r4, r5, lr}
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c0024e6:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
{
 c0024ea:	4601      	mov	r1, r0
 c0024ec:	b087      	sub	sp, #28
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c0024ee:	d208      	bcs.n	c002502 <Flash_EraseSector+0x1e>
  return ((param % (flash_dev->data->sector_size)) != 0) ? (false) : (true);
 c0024f0:	f3c0 030b 	ubfx	r3, r0, #0, #12
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c0024f4:	b92b      	cbnz	r3, c002502 <Flash_EraseSector+0x1e>
  for (nb = 0; nb < vect->nb; nb++)
 c0024f6:	4a26      	ldr	r2, [pc, #152]	; (c002590 <Flash_EraseSector+0xac>)
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 c0024f8:	e9d2 0200 	ldrd	r0, r2, [r2]
 c0024fc:	1d14      	adds	r4, r2, #4
  for (nb = 0; nb < vect->nb; nb++)
 c0024fe:	4283      	cmp	r3, r0
 c002500:	d108      	bne.n	c002514 <Flash_EraseSector+0x30>
    return ARM_DRIVER_ERROR_PARAMETER;
 c002502:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c002506:	4a23      	ldr	r2, [pc, #140]	; (c002594 <Flash_EraseSector+0xb0>)
 c002508:	6813      	ldr	r3, [r2, #0]
 c00250a:	f043 0302 	orr.w	r3, r3, #2
 c00250e:	6013      	str	r3, [r2, #0]
}
 c002510:	b007      	add	sp, #28
 c002512:	bd30      	pop	{r4, r5, pc}
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 c002514:	f852 5033 	ldr.w	r5, [r2, r3, lsl #3]
 c002518:	42a9      	cmp	r1, r5
 c00251a:	d303      	bcc.n	c002524 <Flash_EraseSector+0x40>
 c00251c:	f854 5033 	ldr.w	r5, [r4, r3, lsl #3]
 c002520:	42a9      	cmp	r1, r5
 c002522:	d901      	bls.n	c002528 <Flash_EraseSector+0x44>
  for (nb = 0; nb < vect->nb; nb++)
 c002524:	3301      	adds	r3, #1
 c002526:	e7ea      	b.n	c0024fe <Flash_EraseSector+0x1a>
  if (is_range_secure(&ARM_FLASH0_DEV, addr, 4))
 c002528:	2204      	movs	r2, #4
 c00252a:	4819      	ldr	r0, [pc, #100]	; (c002590 <Flash_EraseSector+0xac>)
 c00252c:	f7ff ff57 	bl	c0023de <is_range_secure.isra.0>
    EraseInit.TypeErase = FLASH_TYPEERASE_PAGES_NS;
 c002530:	2800      	cmp	r0, #0
 c002532:	4b19      	ldr	r3, [pc, #100]	; (c002598 <Flash_EraseSector+0xb4>)
 c002534:	bf18      	it	ne
 c002536:	2302      	movne	r3, #2
  return ((param >= (FLASH_TOTAL_SIZE / 2)) ? 2 : 1);
 c002538:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 c00253c:	9302      	str	r3, [sp, #8]
 c00253e:	bf2c      	ite	cs
 c002540:	2302      	movcs	r3, #2
 c002542:	2301      	movcc	r3, #1
  EraseInit.Banks = bank_number(&ARM_FLASH0_DEV, addr);
 c002544:	9303      	str	r3, [sp, #12]
  EraseInit.NbPages = 2;
 c002546:	2302      	movs	r3, #2
  page = ((page > (flash_dev->data->sector_count))) ? page - ((flash_dev->data->sector_count)) : page;
 c002548:	f5b1 2f81 	cmp.w	r1, #264192	; 0x40800
  EraseInit.NbPages = 2;
 c00254c:	9305      	str	r3, [sp, #20]
  uint32_t page = param / flash_dev->data->page_size ;
 c00254e:	ea4f 23d1 	mov.w	r3, r1, lsr #11
  page = ((page > (flash_dev->data->sector_count))) ? page - ((flash_dev->data->sector_count)) : page;
 c002552:	d300      	bcc.n	c002556 <Flash_EraseSector+0x72>
 c002554:	3b80      	subs	r3, #128	; 0x80
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c002556:	4d0f      	ldr	r5, [pc, #60]	; (c002594 <Flash_EraseSector+0xb0>)
  EraseInit.Page = page_number(&ARM_FLASH0_DEV, addr);
 c002558:	9304      	str	r3, [sp, #16]
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c00255a:	682b      	ldr	r3, [r5, #0]
 c00255c:	f36f 0341 	bfc	r3, #1, #1
 c002560:	602b      	str	r3, [r5, #0]
  HAL_FLASH_Unlock();
 c002562:	f000 fd29 	bl	c002fb8 <HAL_FLASH_Unlock>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c002566:	682b      	ldr	r3, [r5, #0]
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 c002568:	a901      	add	r1, sp, #4
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c00256a:	f043 0301 	orr.w	r3, r3, #1
 c00256e:	602b      	str	r3, [r5, #0]
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 c002570:	a802      	add	r0, sp, #8
 c002572:	f001 f80d 	bl	c003590 <HAL_FLASHEx_Erase>
 c002576:	4604      	mov	r4, r0
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c002578:	682b      	ldr	r3, [r5, #0]
 c00257a:	f36f 0300 	bfc	r3, #0, #1
 c00257e:	602b      	str	r3, [r5, #0]
  HAL_FLASH_Lock();
 c002580:	f000 fd3a 	bl	c002ff8 <HAL_FLASH_Lock>
  return (err == HAL_OK) ? ARM_DRIVER_OK : ARM_DRIVER_ERROR;
 c002584:	1e20      	subs	r0, r4, #0
 c002586:	bf18      	it	ne
 c002588:	2001      	movne	r0, #1
 c00258a:	4240      	negs	r0, r0
 c00258c:	e7c0      	b.n	c002510 <Flash_EraseSector+0x2c>
 c00258e:	bf00      	nop
 c002590:	30030008 	.word	0x30030008
 c002594:	300301c4 	.word	0x300301c4
 c002598:	80000002 	.word	0x80000002

0c00259c <Flash_ReadData>:
{
 c00259c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c00259e:	4b1c      	ldr	r3, [pc, #112]	; (c002610 <Flash_ReadData+0x74>)
{
 c0025a0:	460e      	mov	r6, r1
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c0025a2:	6819      	ldr	r1, [r3, #0]
{
 c0025a4:	4604      	mov	r4, r0
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c0025a6:	f36f 0141 	bfc	r1, #1, #1
 c0025aa:	6019      	str	r1, [r3, #0]
  is_valid = is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1);
 c0025ac:	1e51      	subs	r1, r2, #1
 c0025ae:	4401      	add	r1, r0
  if (is_valid != true)
 c0025b0:	f5b1 2f00 	cmp.w	r1, #524288	; 0x80000
{
 c0025b4:	4617      	mov	r7, r2
  if (is_valid != true)
 c0025b6:	d30f      	bcc.n	c0025d8 <Flash_ReadData+0x3c>
    if (ARM_FLASH0_DEV.dev->read_error)
 c0025b8:	4916      	ldr	r1, [pc, #88]	; (c002614 <Flash_ReadData+0x78>)
 c0025ba:	698c      	ldr	r4, [r1, #24]
 c0025bc:	b134      	cbz	r4, c0025cc <Flash_ReadData+0x30>
      return ARM_DRIVER_ERROR_PARAMETER;
 c0025be:	f06f 0004 	mvn.w	r0, #4
      ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c0025c2:	681a      	ldr	r2, [r3, #0]
 c0025c4:	f042 0202 	orr.w	r2, r2, #2
 c0025c8:	601a      	str	r2, [r3, #0]
}
 c0025ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset(data, 0xff, cnt);
 c0025cc:	21ff      	movs	r1, #255	; 0xff
 c0025ce:	4630      	mov	r0, r6
 c0025d0:	f006 fae9 	bl	c008ba6 <memset>
    return ARM_DRIVER_OK;
 c0025d4:	4620      	mov	r0, r4
 c0025d6:	e7f8      	b.n	c0025ca <Flash_ReadData+0x2e>
  DoubleECC_Error_Counter = 0U;
 c0025d8:	2300      	movs	r3, #0
 c0025da:	4d0f      	ldr	r5, [pc, #60]	; (c002618 <Flash_ReadData+0x7c>)
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c0025dc:	4601      	mov	r1, r0
 c0025de:	480d      	ldr	r0, [pc, #52]	; (c002614 <Flash_ReadData+0x78>)
  DoubleECC_Error_Counter = 0U;
 c0025e0:	602b      	str	r3, [r5, #0]
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c0025e2:	f7ff fefc 	bl	c0023de <is_range_secure.isra.0>
    memcpy(data, (void *)((uint32_t)addr + FLASH_BASE), cnt);
 c0025e6:	463a      	mov	r2, r7
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c0025e8:	b170      	cbz	r0, c002608 <Flash_ReadData+0x6c>
    memcpy(data, (void *)((uint32_t)addr + FLASH_BASE), cnt);
 c0025ea:	f104 6140 	add.w	r1, r4, #201326592	; 0xc000000
    memcpy(data, (void *)((uint32_t)addr + FLASH_BASE_NS), cnt);
 c0025ee:	4630      	mov	r0, r6
 c0025f0:	f006 facc 	bl	c008b8c <memcpy>
  if (DoubleECC_Error_Counter == 0U)
 c0025f4:	682b      	ldr	r3, [r5, #0]
    ret = ARM_DRIVER_OK;
 c0025f6:	2b00      	cmp	r3, #0
  DoubleECC_Error_Counter = 0U;
 c0025f8:	f04f 0300 	mov.w	r3, #0
    ret = ARM_DRIVER_OK;
 c0025fc:	bf14      	ite	ne
 c0025fe:	f06f 0005 	mvnne.w	r0, #5
 c002602:	2000      	moveq	r0, #0
  DoubleECC_Error_Counter = 0U;
 c002604:	602b      	str	r3, [r5, #0]
  return ret;
 c002606:	e7e0      	b.n	c0025ca <Flash_ReadData+0x2e>
    memcpy(data, (void *)((uint32_t)addr + FLASH_BASE_NS), cnt);
 c002608:	f104 6100 	add.w	r1, r4, #134217728	; 0x8000000
 c00260c:	e7ef      	b.n	c0025ee <Flash_ReadData+0x52>
 c00260e:	bf00      	nop
 c002610:	300301c4 	.word	0x300301c4
 c002614:	30030008 	.word	0x30030008
 c002618:	300301c8 	.word	0x300301c8

0c00261c <NMI_Handler>:
void NMI_Handler(void)
{
  uint32_t *p_sp;
  uint32_t lr;
  uint16_t opcode_msb;
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD))
 c00261c:	4b17      	ldr	r3, [pc, #92]	; (c00267c <NMI_Handler+0x60>)
 c00261e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 c002620:	f002 4220 	and.w	r2, r2, #2684354560	; 0xa0000000
 c002624:	f1b2 4f20 	cmp.w	r2, #2684354560	; 0xa0000000
 c002628:	d127      	bne.n	c00267a <NMI_Handler+0x5e>
  {
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ECCD);
 c00262a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 c00262c:	f042 4220 	orr.w	r2, r2, #2684354560	; 0xa0000000
 c002630:	631a      	str	r2, [r3, #48]	; 0x30
    /* Memorize error to ignore the read value */
    DoubleECC_Error_Counter++;
 c002632:	4a13      	ldr	r2, [pc, #76]	; (c002680 <NMI_Handler+0x64>)
 c002634:	6813      	ldr	r3, [r2, #0]
 c002636:	3301      	adds	r3, #1
 c002638:	6013      	str	r3, [r2, #0]
  __ASM volatile("MOV %0, LR" : "=r"(result));
 c00263a:	4673      	mov	r3, lr

    lr = __get_LR();

    /* Check EXC_RETURN value in LR to know which SP was used prior entering exception */
    if (((lr) & (0xFU)) == 0xDU)
 c00263c:	f003 030f 	and.w	r3, r3, #15
 c002640:	2b0d      	cmp	r3, #13
 c002642:	d114      	bne.n	c00266e <NMI_Handler+0x52>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 c002644:	f3ef 8209 	mrs	r2, PSP
      /* interrupted code was using Main Stack Pointer */
      p_sp = (uint32_t *)__get_MSP();
    }

    /* Test caller mode T bit from CPSR in stack */
    if ((*(p_sp + 7U) & (1U << xPSR_T_Pos)) != 0U)
 c002648:	e9d2 3106 	ldrd	r3, r1, [r2, #24]
 c00264c:	01c9      	lsls	r1, r1, #7
 c00264e:	d50c      	bpl.n	c00266a <NMI_Handler+0x4e>
         Test PC in stack.
         If bits [15:11] of the halfword being decoded take any of the following values,
         the halfword is the first halfword of a 32-bit instruction: 0b11101, 0b11110, 0b11111.
         Otherwise, the halfword is a 16-bit instruction.
      */
      opcode_msb = (*(uint16_t *)(*(p_sp + 6) & 0xFFFFFFFEU) & 0xF800U);
 c002650:	f023 0101 	bic.w	r1, r3, #1
 c002654:	8809      	ldrh	r1, [r1, #0]
      if ((opcode_msb == 0xE800U) || (opcode_msb == 0xF000U) || (opcode_msb == 0xF800U))
 c002656:	f401 4068 	and.w	r0, r1, #59392	; 0xe800
 c00265a:	f5b0 4f68 	cmp.w	r0, #59392	; 0xe800
 c00265e:	d004      	beq.n	c00266a <NMI_Handler+0x4e>
 c002660:	f401 4178 	and.w	r1, r1, #63488	; 0xf800
 c002664:	f5b1 4f70 	cmp.w	r1, #61440	; 0xf000
 c002668:	d104      	bne.n	c002674 <NMI_Handler+0x58>
      }
    }
    else
    {
      /* ARM mode execute next instruction PC +4 */
      *(p_sp + 6U) += 4U;
 c00266a:	3304      	adds	r3, #4
 c00266c:	e003      	b.n	c002676 <NMI_Handler+0x5a>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 c00266e:	f3ef 8208 	mrs	r2, MSP
  return(result);
 c002672:	e7e9      	b.n	c002648 <NMI_Handler+0x2c>
        *(p_sp + 6U) += 2U;
 c002674:	3302      	adds	r3, #2
      *(p_sp + 6U) += 4U;
 c002676:	6193      	str	r3, [r2, #24]
  else
  {
    /* This exception occurs for another reason than flash double ECC errors */
    while (1U);
  }
}
 c002678:	4770      	bx	lr
    while (1U);
 c00267a:	e7fe      	b.n	c00267a <NMI_Handler+0x5e>
 c00267c:	50022000 	.word	0x50022000
 c002680:	300301c8 	.word	0x300301c8

0c002684 <mbedtls_sha256_init>:
static void mbedtls_zeroize(void *v, size_t n)
{
    volatile unsigned char *p = (unsigned char *)v;
    while (n--)
    {
        *p++ = 0;
 c002684:	2200      	movs	r2, #0
    }
}

void mbedtls_sha256_init(mbedtls_sha256_context *ctx)
{
 c002686:	b082      	sub	sp, #8
 c002688:	f500 73b8 	add.w	r3, r0, #368	; 0x170
    while (n--)
 c00268c:	4298      	cmp	r0, r3
 c00268e:	d10b      	bne.n	c0026a8 <mbedtls_sha256_init+0x24>
    mbedtls_zeroize(ctx, sizeof(mbedtls_sha256_context));

    /* Enable HASH clock */
    __HAL_RCC_HASH_CLK_ENABLE();
 c002690:	4b07      	ldr	r3, [pc, #28]	; (c0026b0 <mbedtls_sha256_init+0x2c>)
 c002692:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c002694:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 c002698:	64da      	str	r2, [r3, #76]	; 0x4c
 c00269a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 c00269c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 c0026a0:	9301      	str	r3, [sp, #4]
 c0026a2:	9b01      	ldr	r3, [sp, #4]
}
 c0026a4:	b002      	add	sp, #8
 c0026a6:	4770      	bx	lr
        *p++ = 0;
 c0026a8:	f800 2b01 	strb.w	r2, [r0], #1
 c0026ac:	e7ee      	b.n	c00268c <mbedtls_sha256_init+0x8>
 c0026ae:	bf00      	nop
 c0026b0:	50021000 	.word	0x50021000

0c0026b4 <mbedtls_sha256_free>:

void mbedtls_sha256_free(mbedtls_sha256_context *ctx)
{
    if (ctx == NULL)
 c0026b4:	b120      	cbz	r0, c0026c0 <mbedtls_sha256_free+0xc>
        *p++ = 0;
 c0026b6:	2200      	movs	r2, #0
 c0026b8:	f500 73b8 	add.w	r3, r0, #368	; 0x170
    while (n--)
 c0026bc:	4298      	cmp	r0, r3
 c0026be:	d100      	bne.n	c0026c2 <mbedtls_sha256_free+0xe>
    {
        return;
    }
    mbedtls_zeroize(ctx, sizeof(mbedtls_sha256_context));
}
 c0026c0:	4770      	bx	lr
        *p++ = 0;
 c0026c2:	f800 2b01 	strb.w	r2, [r0], #1
 c0026c6:	e7f9      	b.n	c0026bc <mbedtls_sha256_free+0x8>

0c0026c8 <mbedtls_sha256_clone>:

void mbedtls_sha256_clone(mbedtls_sha256_context *dst,
                          const mbedtls_sha256_context *src)
{
 c0026c8:	b508      	push	{r3, lr}
    *dst = *src;
 c0026ca:	f44f 72b8 	mov.w	r2, #368	; 0x170
 c0026ce:	f006 fa5d 	bl	c008b8c <memcpy>
}
 c0026d2:	bd08      	pop	{r3, pc}

0c0026d4 <mbedtls_sha256_starts_ret>:

int mbedtls_sha256_starts_ret(mbedtls_sha256_context *ctx, int is224)
{
 c0026d4:	b570      	push	{r4, r5, r6, lr}
    /* HASH Configuration */
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c0026d6:	1d06      	adds	r6, r0, #4
{
 c0026d8:	4604      	mov	r4, r0
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c0026da:	4630      	mov	r0, r6
{
 c0026dc:	460d      	mov	r5, r1
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c0026de:	f001 f98a 	bl	c0039f6 <HAL_HASH_DeInit>
 c0026e2:	b110      	cbz	r0, c0026ea <mbedtls_sha256_starts_ret+0x16>
    {
        return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c0026e4:	f06f 006f 	mvn.w	r0, #111	; 0x6f
    /* save hw context */
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    return 0;
}
 c0026e8:	bd70      	pop	{r4, r5, r6, pc}
    ctx->hhash.Init.DataType = HASH_DATATYPE_8B;
 c0026ea:	2320      	movs	r3, #32
    if (HAL_HASH_Init(&ctx->hhash) != HAL_OK)
 c0026ec:	4630      	mov	r0, r6
    ctx->hhash.Init.DataType = HASH_DATATYPE_8B;
 c0026ee:	6063      	str	r3, [r4, #4]
    if (HAL_HASH_Init(&ctx->hhash) != HAL_OK)
 c0026f0:	f001 f952 	bl	c003998 <HAL_HASH_Init>
 c0026f4:	2800      	cmp	r0, #0
 c0026f6:	d1f5      	bne.n	c0026e4 <mbedtls_sha256_starts_ret+0x10>
    ctx->is224 = is224;
 c0026f8:	6025      	str	r5, [r4, #0]
    return 0;
 c0026fa:	e7f5      	b.n	c0026e8 <mbedtls_sha256_starts_ret+0x14>

0c0026fc <mbedtls_internal_sha256_process>:

int mbedtls_internal_sha256_process( mbedtls_sha256_context *ctx, const unsigned char data[ST_SHA256_BLOCK_SIZE] )
{
 c0026fc:	b508      	push	{r3, lr}
#ifdef ST_HW_CONTEXT_SAVING
    /* restore hw context */
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    if (ctx->is224 == 0) {
 c0026fe:	f850 3b04 	ldr.w	r3, [r0], #4
        if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *) data, ST_SHA256_BLOCK_SIZE) != 0) {
 c002702:	2240      	movs	r2, #64	; 0x40
    if (ctx->is224 == 0) {
 c002704:	b93b      	cbnz	r3, c002716 <mbedtls_internal_sha256_process+0x1a>
        if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *) data, ST_SHA256_BLOCK_SIZE) != 0) {
 c002706:	f001 fa85 	bl	c003c14 <HAL_HASHEx_SHA256_Accmlt>
 c00270a:	b110      	cbz	r0, c002712 <mbedtls_internal_sha256_process+0x16>
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c00270c:	f06f 006f 	mvn.w	r0, #111	; 0x6f
    /* save hw context */
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    return 0;
}
 c002710:	bd08      	pop	{r3, pc}
    return 0;
 c002712:	2000      	movs	r0, #0
 c002714:	e7fc      	b.n	c002710 <mbedtls_internal_sha256_process+0x14>
        if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *) data, ST_SHA256_BLOCK_SIZE) != 0) {
 c002716:	f001 fa6b 	bl	c003bf0 <HAL_HASHEx_SHA224_Accmlt>
 c00271a:	e7f6      	b.n	c00270a <mbedtls_internal_sha256_process+0xe>

0c00271c <mbedtls_sha256_update_ret>:

int mbedtls_sha256_update_ret(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen)
{
 c00271c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c002720:	4605      	mov	r5, r0
#ifdef ST_HW_CONTEXT_SAVING
    /* restore hw context */
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    if (currentlen < (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len))
 c002722:	f890 0088 	ldrb.w	r0, [r0, #136]	; 0x88
 c002726:	f105 0848 	add.w	r8, r5, #72	; 0x48
 c00272a:	f1c0 0340 	rsb	r3, r0, #64	; 0x40
 c00272e:	4293      	cmp	r3, r2
{
 c002730:	4689      	mov	r9, r1
 c002732:	4616      	mov	r6, r2
 c002734:	4440      	add	r0, r8
    if (currentlen < (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len))
 c002736:	d908      	bls.n	c00274a <mbedtls_sha256_update_ret+0x2e>
    {
        /* only store input data in context buffer */
        memcpy(ctx->sbuf + ctx->sbuf_len, input, currentlen);
 c002738:	f006 fa28 	bl	c008b8c <memcpy>
        ctx->sbuf_len += currentlen;
 c00273c:	f895 2088 	ldrb.w	r2, [r5, #136]	; 0x88
 c002740:	4416      	add	r6, r2
 c002742:	f885 6088 	strb.w	r6, [r5, #136]	; 0x88

#ifdef ST_HW_CONTEXT_SAVING
    /* save hw context */
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */
    return 0;
 c002746:	2000      	movs	r0, #0
 c002748:	e033      	b.n	c0027b2 <mbedtls_sha256_update_ret+0x96>
        memcpy(ctx->sbuf + ctx->sbuf_len, input, (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len));
 c00274a:	462f      	mov	r7, r5
 c00274c:	461a      	mov	r2, r3
 c00274e:	f006 fa1d 	bl	c008b8c <memcpy>
        currentlen -= (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len);
 c002752:	f895 2088 	ldrb.w	r2, [r5, #136]	; 0x88
        if (ctx->is224 == 0)
 c002756:	f857 3b04 	ldr.w	r3, [r7], #4
        currentlen -= (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len);
 c00275a:	4432      	add	r2, r6
 c00275c:	f1a2 0440 	sub.w	r4, r2, #64	; 0x40
            if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE) != 0)
 c002760:	4641      	mov	r1, r8
 c002762:	2240      	movs	r2, #64	; 0x40
 c002764:	4638      	mov	r0, r7
        if (ctx->is224 == 0)
 c002766:	b98b      	cbnz	r3, c00278c <mbedtls_sha256_update_ret+0x70>
            if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE) != 0)
 c002768:	f001 fa54 	bl	c003c14 <HAL_HASHEx_SHA256_Accmlt>
 c00276c:	b9f8      	cbnz	r0, c0027ae <mbedtls_sha256_update_ret+0x92>
        if (iter != 0)
 c00276e:	2c3f      	cmp	r4, #63	; 0x3f
 c002770:	d80f      	bhi.n	c002792 <mbedtls_sha256_update_ret+0x76>
        ctx->sbuf_len = currentlen % ST_SHA256_BLOCK_SIZE;
 c002772:	f004 023f 	and.w	r2, r4, #63	; 0x3f
 c002776:	f885 2088 	strb.w	r2, [r5, #136]	; 0x88
        if (ctx->sbuf_len != 0)
 c00277a:	2a00      	cmp	r2, #0
 c00277c:	d0e3      	beq.n	c002746 <mbedtls_sha256_update_ret+0x2a>
            memcpy(ctx->sbuf, input + ilen - ctx->sbuf_len, ctx->sbuf_len);
 c00277e:	1ab6      	subs	r6, r6, r2
 c002780:	4640      	mov	r0, r8
 c002782:	eb09 0106 	add.w	r1, r9, r6
 c002786:	f006 fa01 	bl	c008b8c <memcpy>
 c00278a:	e7dc      	b.n	c002746 <mbedtls_sha256_update_ret+0x2a>
            if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE) != 0)
 c00278c:	f001 fa30 	bl	c003bf0 <HAL_HASHEx_SHA224_Accmlt>
 c002790:	e7ec      	b.n	c00276c <mbedtls_sha256_update_ret+0x50>
            if (ctx->is224 == 0)
 c002792:	f895 1088 	ldrb.w	r1, [r5, #136]	; 0x88
 c002796:	682b      	ldr	r3, [r5, #0]
 c002798:	f1c1 0140 	rsb	r1, r1, #64	; 0x40
                if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c00279c:	4638      	mov	r0, r7
 c00279e:	4449      	add	r1, r9
 c0027a0:	f024 023f 	bic.w	r2, r4, #63	; 0x3f
            if (ctx->is224 == 0)
 c0027a4:	b93b      	cbnz	r3, c0027b6 <mbedtls_sha256_update_ret+0x9a>
                if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c0027a6:	f001 fa35 	bl	c003c14 <HAL_HASHEx_SHA256_Accmlt>
                if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c0027aa:	2800      	cmp	r0, #0
 c0027ac:	d0e1      	beq.n	c002772 <mbedtls_sha256_update_ret+0x56>
                return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c0027ae:	f06f 006f 	mvn.w	r0, #111	; 0x6f
}
 c0027b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c0027b6:	f001 fa1b 	bl	c003bf0 <HAL_HASHEx_SHA224_Accmlt>
 c0027ba:	e7f6      	b.n	c0027aa <mbedtls_sha256_update_ret+0x8e>

0c0027bc <mbedtls_sha256_finish_ret>:

int mbedtls_sha256_finish_ret(mbedtls_sha256_context *ctx, unsigned char output[32])
{
 c0027bc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c0027be:	4604      	mov	r4, r0
 c0027c0:	2503      	movs	r5, #3
    /* restore hw context */
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    /* Last accumulation for pending bytes in sbuf_len, then trig processing and get digest */
    if (ctx->is224 == 0)
 c0027c2:	6826      	ldr	r6, [r4, #0]
{
 c0027c4:	460b      	mov	r3, r1
 c0027c6:	f894 2088 	ldrb.w	r2, [r4, #136]	; 0x88
 c0027ca:	3004      	adds	r0, #4
 c0027cc:	f104 0148 	add.w	r1, r4, #72	; 0x48
    {
        if (HAL_HASHEx_SHA256_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c0027d0:	9500      	str	r5, [sp, #0]
    if (ctx->is224 == 0)
 c0027d2:	b956      	cbnz	r6, c0027ea <mbedtls_sha256_finish_ret+0x2e>
        if (HAL_HASHEx_SHA256_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c0027d4:	f001 fa24 	bl	c003c20 <HAL_HASHEx_SHA256_Accmlt_End>
 c0027d8:	b920      	cbnz	r0, c0027e4 <mbedtls_sha256_finish_ret+0x28>
        {
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
        }
    }

    ctx->sbuf_len = 0;
 c0027da:	2000      	movs	r0, #0
 c0027dc:	f884 0088 	strb.w	r0, [r4, #136]	; 0x88

    return 0;
}
 c0027e0:	b002      	add	sp, #8
 c0027e2:	bd70      	pop	{r4, r5, r6, pc}
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c0027e4:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 c0027e8:	e7fa      	b.n	c0027e0 <mbedtls_sha256_finish_ret+0x24>
        if (HAL_HASHEx_SHA224_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c0027ea:	f001 fa05 	bl	c003bf8 <HAL_HASHEx_SHA224_Accmlt_End>
 c0027ee:	e7f3      	b.n	c0027d8 <mbedtls_sha256_finish_ret+0x1c>

0c0027f0 <SystemInit>:
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c0027f0:	4a22      	ldr	r2, [pc, #136]	; (c00287c <SystemInit+0x8c>)

  /* Enable voltage range 0 mode for frequency above 80 Mhz */
  RCC->APB1ENR1 |= RCC_APB1ENR1_PWREN;
  tmp = RCC->APB1ENR1;
  UNUSED(tmp);
  PWR->CR1 &= ~PWR_CR1_VOS;  /* voltage range 0 */
 c0027f2:	4923      	ldr	r1, [pc, #140]	; (c002880 <SystemInit+0x90>)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c0027f4:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
{
 c0027f8:	b082      	sub	sp, #8
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c0027fa:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 c0027fe:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  RCC->APB1ENR1 |= RCC_APB1ENR1_PWREN;
 c002802:	4b20      	ldr	r3, [pc, #128]	; (c002884 <SystemInit+0x94>)
 c002804:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c002806:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c00280a:	659a      	str	r2, [r3, #88]	; 0x58
  tmp = RCC->APB1ENR1;
 c00280c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c00280e:	9201      	str	r2, [sp, #4]
  UNUSED(tmp);
 c002810:	9a01      	ldr	r2, [sp, #4]
  PWR->CR1 &= ~PWR_CR1_VOS;  /* voltage range 0 */
 c002812:	680a      	ldr	r2, [r1, #0]
 c002814:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 c002818:	600a      	str	r2, [r1, #0]

  /* Set Flash latency prior to system clock change */
  FLASH->ACR = 5U;
 c00281a:	2105      	movs	r1, #5
 c00281c:	4a1a      	ldr	r2, [pc, #104]	; (c002888 <SystemInit+0x98>)
 c00281e:	6011      	str	r1, [r2, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY) != 5U)
 c002820:	6811      	ldr	r1, [r2, #0]
 c002822:	f001 010f 	and.w	r1, r1, #15
 c002826:	2905      	cmp	r1, #5
 c002828:	d1fa      	bne.n	c002820 <SystemInit+0x30>
  {
  }

  /* Configure and enable the main PLL */
  /* PLLSRC=MSI, PLLM=1, PLLN=55, PLLR=2, PLLREN=1 */
  RCC->PLLCFGR = RCC_PLLCFGR_PLLSRC_0 | (55 << RCC_PLLCFGR_PLLN_Pos) | RCC_PLLCFGR_PLLREN;
 c00282a:	4a18      	ldr	r2, [pc, #96]	; (c00288c <SystemInit+0x9c>)
 c00282c:	60da      	str	r2, [r3, #12]
  RCC->CR |= RCC_CR_PLLON;
 c00282e:	681a      	ldr	r2, [r3, #0]
 c002830:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 c002834:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_PLLRDY) != RCC_CR_PLLRDY)
 c002836:	4b13      	ldr	r3, [pc, #76]	; (c002884 <SystemInit+0x94>)
 c002838:	461a      	mov	r2, r3
 c00283a:	6819      	ldr	r1, [r3, #0]
 c00283c:	0189      	lsls	r1, r1, #6
 c00283e:	d5fc      	bpl.n	c00283a <SystemInit+0x4a>
  {
  }

  /* Sysclk activation on the main PLL */
  /* Intermediate AHB prescaler 2 when target frequency clock is higher than 80 MHz */
  RCC->CFGR = RCC_CFGR_HPRE_3 | RCC_CFGR_SW;
 c002840:	2183      	movs	r1, #131	; 0x83
 c002842:	6099      	str	r1, [r3, #8]
  /* Wait till the main PLL is used as system clock source */
  while ((RCC->CFGR & RCC_CFGR_SW) != RCC_CFGR_SW)
 c002844:	6893      	ldr	r3, [r2, #8]
 c002846:	f003 0303 	and.w	r3, r3, #3
 c00284a:	2b03      	cmp	r3, #3
 c00284c:	d1fa      	bne.n	c002844 <SystemInit+0x54>
  {
  }

  /* Insure 1µs transition state at intermediate medium speed clock based on DWT*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 c00284e:	4a10      	ldr	r2, [pc, #64]	; (c002890 <SystemInit+0xa0>)
 c002850:	68d3      	ldr	r3, [r2, #12]
 c002852:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 c002856:	60d3      	str	r3, [r2, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 c002858:	4b0e      	ldr	r3, [pc, #56]	; (c002894 <SystemInit+0xa4>)
 c00285a:	681a      	ldr	r2, [r3, #0]
 c00285c:	f042 0201 	orr.w	r2, r2, #1
 c002860:	601a      	str	r2, [r3, #0]
  DWT->CYCCNT = 0;
 c002862:	2200      	movs	r2, #0
 c002864:	605a      	str	r2, [r3, #4]
  while(DWT->CYCCNT < 100);
 c002866:	685a      	ldr	r2, [r3, #4]
 c002868:	2a63      	cmp	r2, #99	; 0x63
 c00286a:	d9fc      	bls.n	c002866 <SystemInit+0x76>

  /* AHB prescaler 1 */
  RCC->CFGR &= ~RCC_CFGR_HPRE_3;
 c00286c:	4a05      	ldr	r2, [pc, #20]	; (c002884 <SystemInit+0x94>)
 c00286e:	6893      	ldr	r3, [r2, #8]
 c002870:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 c002874:	6093      	str	r3, [r2, #8]
}
 c002876:	b002      	add	sp, #8
 c002878:	4770      	bx	lr
 c00287a:	bf00      	nop
 c00287c:	e000ed00 	.word	0xe000ed00
 c002880:	50007000 	.word	0x50007000
 c002884:	50021000 	.word	0x50021000
 c002888:	50022000 	.word	0x50022000
 c00288c:	01003701 	.word	0x01003701
 c002890:	e000edf0 	.word	0xe000edf0
 c002894:	e0001000 	.word	0xe0001000

0c002898 <SystemCoreClockUpdate>:
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c002898:	4a23      	ldr	r2, [pc, #140]	; (c002928 <SystemCoreClockUpdate+0x90>)
  msirange = MSIRangeTable[msirange];
 c00289a:	4924      	ldr	r1, [pc, #144]	; (c00292c <SystemCoreClockUpdate+0x94>)
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c00289c:	6813      	ldr	r3, [r2, #0]
{
 c00289e:	b510      	push	{r4, lr}
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c0028a0:	071b      	lsls	r3, r3, #28
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 c0028a2:	bf54      	ite	pl
 c0028a4:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 c0028a8:	6813      	ldrmi	r3, [r2, #0]
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c0028aa:	6890      	ldr	r0, [r2, #8]
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 c0028ac:	bf58      	it	pl
 c0028ae:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c0028b2:	f000 000c 	and.w	r0, r0, #12
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 c0028b6:	bf48      	it	mi
 c0028b8:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c0028bc:	2808      	cmp	r0, #8
  msirange = MSIRangeTable[msirange];
 c0028be:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c0028c2:	491b      	ldr	r1, [pc, #108]	; (c002930 <SystemCoreClockUpdate+0x98>)
 c0028c4:	d003      	beq.n	c0028ce <SystemCoreClockUpdate+0x36>
 c0028c6:	280c      	cmp	r0, #12
 c0028c8:	d00d      	beq.n	c0028e6 <SystemCoreClockUpdate+0x4e>
 c0028ca:	2804      	cmp	r0, #4
 c0028cc:	d129      	bne.n	c002922 <SystemCoreClockUpdate+0x8a>
      SystemCoreClock = HSI_VALUE;
 c0028ce:	4b19      	ldr	r3, [pc, #100]	; (c002934 <SystemCoreClockUpdate+0x9c>)
      SystemCoreClock = pllvco/pllr;
 c0028d0:	600b      	str	r3, [r1, #0]
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 c0028d2:	4b15      	ldr	r3, [pc, #84]	; (c002928 <SystemCoreClockUpdate+0x90>)
 c0028d4:	4a18      	ldr	r2, [pc, #96]	; (c002938 <SystemCoreClockUpdate+0xa0>)
 c0028d6:	689b      	ldr	r3, [r3, #8]
 c0028d8:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c0028dc:	5cd2      	ldrb	r2, [r2, r3]
  SystemCoreClock >>= tmp;
 c0028de:	680b      	ldr	r3, [r1, #0]
 c0028e0:	40d3      	lsrs	r3, r2
 c0028e2:	600b      	str	r3, [r1, #0]
}
 c0028e4:	bd10      	pop	{r4, pc}
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c0028e6:	68d0      	ldr	r0, [r2, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 c0028e8:	68d3      	ldr	r3, [r2, #12]
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c0028ea:	f000 0203 	and.w	r2, r0, #3
 c0028ee:	3a02      	subs	r2, #2
 c0028f0:	2a01      	cmp	r2, #1
          pllvco = (HSE_VALUE / pllm);
 c0028f2:	bf98      	it	ls
 c0028f4:	4a0f      	ldrls	r2, [pc, #60]	; (c002934 <SystemCoreClockUpdate+0x9c>)
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 c0028f6:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c0028fa:	f103 0301 	add.w	r3, r3, #1
          pllvco = (HSE_VALUE / pllm);
 c0028fe:	bf94      	ite	ls
 c002900:	fbb2 f3f3 	udivls	r3, r2, r3
          pllvco = (msirange / pllm);
 c002904:	fbb4 f3f3 	udivhi	r3, r4, r3
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 c002908:	4a07      	ldr	r2, [pc, #28]	; (c002928 <SystemCoreClockUpdate+0x90>)
 c00290a:	68d0      	ldr	r0, [r2, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 c00290c:	68d2      	ldr	r2, [r2, #12]
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 c00290e:	f3c0 2006 	ubfx	r0, r0, #8, #7
 c002912:	4343      	muls	r3, r0
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 c002914:	f3c2 6241 	ubfx	r2, r2, #25, #2
 c002918:	3201      	adds	r2, #1
 c00291a:	0052      	lsls	r2, r2, #1
      SystemCoreClock = pllvco/pllr;
 c00291c:	fbb3 f3f2 	udiv	r3, r3, r2
 c002920:	e7d6      	b.n	c0028d0 <SystemCoreClockUpdate+0x38>
      SystemCoreClock = msirange;
 c002922:	600c      	str	r4, [r1, #0]
      break;
 c002924:	e7d5      	b.n	c0028d2 <SystemCoreClockUpdate+0x3a>
 c002926:	bf00      	nop
 c002928:	50021000 	.word	0x50021000
 c00292c:	0c00a2a8 	.word	0x0c00a2a8
 c002930:	3003004c 	.word	0x3003004c
 c002934:	00f42400 	.word	0x00f42400
 c002938:	0c00a290 	.word	0x0c00a290

0c00293c <TFM_LL_SECU_SetLoaderCodeSecure>:
{
 c00293c:	b530      	push	{r4, r5, lr}
    uint32_t regwrite=0x0, index;
 c00293e:	2200      	movs	r2, #0
    for (index = block_start & ~0x1f; index < (8<<5) ; index++)
 c002940:	23e0      	movs	r3, #224	; 0xe0
        regwrite = regwrite | ( 1 << (index & 0x1f));
 c002942:	2401      	movs	r4, #1
        *ptr =  regwrite;
 c002944:	480d      	ldr	r0, [pc, #52]	; (c00297c <TFM_LL_SECU_SetLoaderCodeSecure+0x40>)
      if (!(index & 0x1f)){
 c002946:	f013 011f 	ands.w	r1, r3, #31
 c00294a:	d011      	beq.n	c002970 <TFM_LL_SECU_SetLoaderCodeSecure+0x34>
      if ((index >= block_start) && (index <= block_end))
 c00294c:	2bef      	cmp	r3, #239	; 0xef
 c00294e:	d904      	bls.n	c00295a <TFM_LL_SECU_SetLoaderCodeSecure+0x1e>
 c002950:	2bf5      	cmp	r3, #245	; 0xf5
 c002952:	d802      	bhi.n	c00295a <TFM_LL_SECU_SetLoaderCodeSecure+0x1e>
        regwrite = regwrite | ( 1 << (index & 0x1f));
 c002954:	fa04 f501 	lsl.w	r5, r4, r1
 c002958:	432a      	orrs	r2, r5
      if ((index & 0x1f ) == 0x1f) {
 c00295a:	291f      	cmp	r1, #31
        *ptr =  regwrite;
 c00295c:	4611      	mov	r1, r2
 c00295e:	bf08      	it	eq
 c002960:	6002      	streq	r2, [r0, #0]
    for (index = block_start & ~0x1f; index < (8<<5) ; index++)
 c002962:	3301      	adds	r3, #1
 c002964:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 c002968:	d100      	bne.n	c00296c <TFM_LL_SECU_SetLoaderCodeSecure+0x30>
}
 c00296a:	bd30      	pop	{r4, r5, pc}
 c00296c:	460a      	mov	r2, r1
 c00296e:	e7ea      	b.n	c002946 <TFM_LL_SECU_SetLoaderCodeSecure+0xa>
      if ((index >= block_start) && (index <= block_end))
 c002970:	2bef      	cmp	r3, #239	; 0xef
 c002972:	d9f6      	bls.n	c002962 <TFM_LL_SECU_SetLoaderCodeSecure+0x26>
 c002974:	2bf5      	cmp	r3, #245	; 0xf5
 c002976:	d8f4      	bhi.n	c002962 <TFM_LL_SECU_SetLoaderCodeSecure+0x26>
         regwrite=0x0;
 c002978:	460a      	mov	r2, r1
 c00297a:	e7eb      	b.n	c002954 <TFM_LL_SECU_SetLoaderCodeSecure+0x18>
 c00297c:	500220ac 	.word	0x500220ac

0c002980 <TFM_LL_SECU_ApplyRunTimeProtections>:
  GTZC_MPCBB1_S->VCTR[0] = 0xfffffffe;
 c002980:	f06f 0201 	mvn.w	r2, #1
{
 c002984:	b510      	push	{r4, lr}
  GTZC_MPCBB1_S->VCTR[0] = 0xfffffffe;
 c002986:	4b84      	ldr	r3, [pc, #528]	; (c002b98 <TFM_LL_SECU_ApplyRunTimeProtections+0x218>)
{
 c002988:	b088      	sub	sp, #32
  GTZC_MPCBB1_S->VCTR[0] = 0xfffffffe;
 c00298a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 c00298e:	4b83      	ldr	r3, [pc, #524]	; (c002b9c <TFM_LL_SECU_ApplyRunTimeProtections+0x21c>)
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c002990:	4a83      	ldr	r2, [pc, #524]	; (c002ba0 <TFM_LL_SECU_ApplyRunTimeProtections+0x220>)
  struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 c002992:	9301      	str	r3, [sp, #4]
  struct mpu_armv8m_dev_t dev_mpu_ns = { MPU_BASE_NS};
 c002994:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 c002998:	9302      	str	r3, [sp, #8]
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c00299a:	2300      	movs	r3, #0
 c00299c:	e9cd 3203 	strd	r3, r2, [sp, #12]
  region_cfg.region_limit = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET + FLASH_S_PARTITION_SIZE - 1;
 c0029a0:	f502 42ff 	add.w	r2, r2, #32640	; 0x7f80
 c0029a4:	327f      	adds	r2, #127	; 0x7f
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c0029a6:	2401      	movs	r4, #1
  region_cfg.region_limit = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET + FLASH_S_PARTITION_SIZE - 1;
 c0029a8:	9205      	str	r2, [sp, #20]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c0029aa:	2203      	movs	r2, #3
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0029ac:	a903      	add	r1, sp, #12
 c0029ae:	a801      	add	r0, sp, #4
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c0029b0:	9206      	str	r2, [sp, #24]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c0029b2:	f8ad 401c 	strh.w	r4, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c0029b6:	f88d 301e 	strb.w	r3, [sp, #30]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0029ba:	f009 ff39 	bl	c00c830 <mpu_armv8m_region_enable>
 c0029be:	b108      	cbz	r0, c0029c4 <TFM_LL_SECU_ApplyRunTimeProtections+0x44>
    Error_Handler();
 c0029c0:	f009 ffbe 	bl	c00c940 <Error_Handler>
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET + FLASH_S_PARTITION_SIZE ;
 c0029c4:	4b77      	ldr	r3, [pc, #476]	; (c002ba4 <TFM_LL_SECU_ApplyRunTimeProtections+0x224>)
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0029c6:	a903      	add	r1, sp, #12
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET + FLASH_S_PARTITION_SIZE ;
 c0029c8:	9304      	str	r3, [sp, #16]
   region_cfg.region_limit = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET + FLASH_S_PARTITION_SIZE + FLASH_NS_PARTITION_SIZE - 1;
 c0029ca:	f503 23c5 	add.w	r3, r3, #403456	; 0x62800
 c0029ce:	f203 73ff 	addw	r3, r3, #2047	; 0x7ff
 c0029d2:	9305      	str	r3, [sp, #20]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c0029d4:	2303      	movs	r3, #3
 c0029d6:	9306      	str	r3, [sp, #24]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c0029d8:	2300      	movs	r3, #0
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0029da:	a801      	add	r0, sp, #4
  region_cfg.region_nr = 1;
 c0029dc:	9403      	str	r4, [sp, #12]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c0029de:	f8ad 401c 	strh.w	r4, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c0029e2:	f88d 301e 	strb.w	r3, [sp, #30]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c0029e6:	f009 ff23 	bl	c00c830 <mpu_armv8m_region_enable>
 c0029ea:	b108      	cbz	r0, c0029f0 <TFM_LL_SECU_ApplyRunTimeProtections+0x70>
    Error_Handler();
 c0029ec:	f009 ffa8 	bl	c00c940 <Error_Handler>
  region_cfg.region_base = FLASH_BASE_S;
 c0029f0:	f04f 6340 	mov.w	r3, #201326592	; 0xc000000
 c0029f4:	2202      	movs	r2, #2
 c0029f6:	e9cd 2303 	strd	r2, r3, [sp, #12]
  region_cfg.region_limit = FLASH_BASE_S + FLASH_AREA_BL2_OFFSET - 1;
 c0029fa:	f503 53bf 	add.w	r3, r3, #6112	; 0x17e0
 c0029fe:	331f      	adds	r3, #31
 c002a00:	9305      	str	r3, [sp, #20]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002a02:	2301      	movs	r3, #1
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c002a04:	2403      	movs	r4, #3
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002a06:	f8ad 301c 	strh.w	r3, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c002a0a:	2300      	movs	r3, #0
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c002a0c:	a903      	add	r1, sp, #12
 c002a0e:	a801      	add	r0, sp, #4
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c002a10:	9406      	str	r4, [sp, #24]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c002a12:	f88d 301e 	strb.w	r3, [sp, #30]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c002a16:	f009 ff0b 	bl	c00c830 <mpu_armv8m_region_enable>
 c002a1a:	b108      	cbz	r0, c002a20 <TFM_LL_SECU_ApplyRunTimeProtections+0xa0>
    Error_Handler();
 c002a1c:	f009 ff90 	bl	c00c940 <Error_Handler>
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_BL2_NOHDP_OFFSET + FLASH_AREA_BL2_NOHDP_SIZE;
 c002a20:	4b5f      	ldr	r3, [pc, #380]	; (c002ba0 <TFM_LL_SECU_ApplyRunTimeProtections+0x220>)
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c002a22:	a903      	add	r1, sp, #12
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_BL2_NOHDP_OFFSET + FLASH_AREA_BL2_NOHDP_SIZE;
 c002a24:	9304      	str	r3, [sp, #16]
  region_cfg.region_limit = FLASH_BASE_S + FLASH_AREA_0_OFFSET - 1;
 c002a26:	3b01      	subs	r3, #1
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c002a28:	e9cd 3405 	strd	r3, r4, [sp, #20]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002a2c:	2301      	movs	r3, #1
 c002a2e:	f8ad 301c 	strh.w	r3, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c002a32:	2300      	movs	r3, #0
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c002a34:	a801      	add	r0, sp, #4
  region_cfg.region_nr = 3;
 c002a36:	9403      	str	r4, [sp, #12]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c002a38:	f88d 301e 	strb.w	r3, [sp, #30]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c002a3c:	f009 fef8 	bl	c00c830 <mpu_armv8m_region_enable>
 c002a40:	b108      	cbz	r0, c002a46 <TFM_LL_SECU_ApplyRunTimeProtections+0xc6>
    Error_Handler();
 c002a42:	f009 ff7d 	bl	c00c940 <Error_Handler>
  region_cfg.region_base = SRAM1_BASE_S ;
 c002a46:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
 c002a4a:	f04f 0c04 	mov.w	ip, #4
 c002a4e:	e9cd c303 	strd	ip, r3, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c002a52:	2302      	movs	r3, #2
 c002a54:	f8df e168 	ldr.w	lr, [pc, #360]	; c002bc0 <TFM_LL_SECU_ApplyRunTimeProtections+0x240>
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c002a58:	a903      	add	r1, sp, #12
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c002a5a:	e9cd e305 	strd	lr, r3, [sp, #20]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002a5e:	2301      	movs	r3, #1
 c002a60:	f8ad 301c 	strh.w	r3, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c002a64:	2300      	movs	r3, #0
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c002a66:	a801      	add	r0, sp, #4
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c002a68:	f88d 301e 	strb.w	r3, [sp, #30]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c002a6c:	f009 fee0 	bl	c00c830 <mpu_armv8m_region_enable>
 c002a70:	b108      	cbz	r0, c002a76 <TFM_LL_SECU_ApplyRunTimeProtections+0xf6>
    Error_Handler();
 c002a72:	f009 ff65 	bl	c00c940 <Error_Handler>
  region_cfg.region_base = PERIPH_BASE_S;
 c002a76:	2005      	movs	r0, #5
 c002a78:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c002a7c:	f06f 4420 	mvn.w	r4, #2684354560	; 0xa0000000
  region_cfg.region_base = PERIPH_BASE_S;
 c002a80:	e9cd 0303 	strd	r0, r3, [sp, #12]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002a84:	2201      	movs	r2, #1
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c002a86:	2300      	movs	r3, #0
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c002a88:	a903      	add	r1, sp, #12
 c002a8a:	a801      	add	r0, sp, #4
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c002a8c:	e9cd 4305 	strd	r4, r3, [sp, #20]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002a90:	f8ad 201c 	strh.w	r2, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c002a94:	f88d 301e 	strb.w	r3, [sp, #30]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c002a98:	f009 feca 	bl	c00c830 <mpu_armv8m_region_enable>
 c002a9c:	b108      	cbz	r0, c002aa2 <TFM_LL_SECU_ApplyRunTimeProtections+0x122>
    Error_Handler();
 c002a9e:	f009 ff4f 	bl	c00c940 <Error_Handler>
  mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
 c002aa2:	2201      	movs	r2, #1
 c002aa4:	a801      	add	r0, sp, #4
 c002aa6:	4611      	mov	r1, r2
 c002aa8:	f009 feaa 	bl	c00c800 <mpu_armv8m_enable>
  region_cfg.region_base = FLASH_BASE_NS + NS_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c002aac:	2300      	movs	r3, #0
 c002aae:	4a3e      	ldr	r2, [pc, #248]	; (c002ba8 <TFM_LL_SECU_ApplyRunTimeProtections+0x228>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c002ab0:	a903      	add	r1, sp, #12
  region_cfg.region_base = FLASH_BASE_NS + NS_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c002ab2:	e9cd 3203 	strd	r3, r2, [sp, #12]
  region_cfg.region_limit = FLASH_BASE_NS + NS_IMAGE_PRIMARY_PARTITION_OFFSET + FLASH_NS_PARTITION_SIZE - 1;
 c002ab6:	f502 22c5 	add.w	r2, r2, #403456	; 0x62800
 c002aba:	f202 72ff 	addw	r2, r2, #2047	; 0x7ff
 c002abe:	9205      	str	r2, [sp, #20]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c002ac0:	2203      	movs	r2, #3
 c002ac2:	9206      	str	r2, [sp, #24]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002ac4:	2201      	movs	r2, #1
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c002ac6:	a802      	add	r0, sp, #8
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002ac8:	f8ad 201c 	strh.w	r2, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c002acc:	f88d 301e 	strb.w	r3, [sp, #30]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c002ad0:	f009 feae 	bl	c00c830 <mpu_armv8m_region_enable>
 c002ad4:	b108      	cbz	r0, c002ada <TFM_LL_SECU_ApplyRunTimeProtections+0x15a>
    Error_Handler();
 c002ad6:	f009 ff33 	bl	c00c940 <Error_Handler>
  region_cfg.region_base = SRAM1_BASE_NS + (~MPU_RBAR_BASE_Msk) + 1;
 c002ada:	2302      	movs	r3, #2
 c002adc:	4a33      	ldr	r2, [pc, #204]	; (c002bac <TFM_LL_SECU_ApplyRunTimeProtections+0x22c>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c002ade:	a903      	add	r1, sp, #12
  region_cfg.region_base = SRAM1_BASE_NS + (~MPU_RBAR_BASE_Msk) + 1;
 c002ae0:	e9cd 3203 	strd	r3, r2, [sp, #12]
  region_cfg.region_limit = SRAM1_BASE_NS + TOTAL_RAM_SIZE - 1;
 c002ae4:	4a32      	ldr	r2, [pc, #200]	; (c002bb0 <TFM_LL_SECU_ApplyRunTimeProtections+0x230>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c002ae6:	a802      	add	r0, sp, #8
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c002ae8:	e9cd 2305 	strd	r2, r3, [sp, #20]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002aec:	2301      	movs	r3, #1
 c002aee:	f8ad 301c 	strh.w	r3, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c002af2:	2300      	movs	r3, #0
 c002af4:	f88d 301e 	strb.w	r3, [sp, #30]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c002af8:	f009 fe9a 	bl	c00c830 <mpu_armv8m_region_enable>
 c002afc:	b108      	cbz	r0, c002b02 <TFM_LL_SECU_ApplyRunTimeProtections+0x182>
    Error_Handler();
 c002afe:	f009 ff1f 	bl	c00c940 <Error_Handler>
  region_cfg.region_base = PERIPH_BASE_NS;
 c002b02:	2203      	movs	r2, #3
 c002b04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c002b08:	f06f 4130 	mvn.w	r1, #2952790016	; 0xb0000000
  region_cfg.region_base = PERIPH_BASE_NS;
 c002b0c:	e9cd 2303 	strd	r2, r3, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c002b10:	2300      	movs	r3, #0
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002b12:	2201      	movs	r2, #1
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c002b14:	e9cd 1305 	strd	r1, r3, [sp, #20]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c002b18:	a802      	add	r0, sp, #8
 c002b1a:	a903      	add	r1, sp, #12
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c002b1c:	f8ad 201c 	strh.w	r2, [sp, #28]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c002b20:	f88d 301e 	strb.w	r3, [sp, #30]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c002b24:	f009 fe84 	bl	c00c830 <mpu_armv8m_region_enable>
 c002b28:	b108      	cbz	r0, c002b2e <TFM_LL_SECU_ApplyRunTimeProtections+0x1ae>
    Error_Handler();
 c002b2a:	f009 ff09 	bl	c00c940 <Error_Handler>
  mpu_armv8m_enable(&dev_mpu_ns, PRIVILEGED_DEFAULT_ENABLE,
 c002b2e:	2201      	movs	r2, #1
 c002b30:	a802      	add	r0, sp, #8
 c002b32:	4611      	mov	r1, r2
 c002b34:	f009 fe64 	bl	c00c800 <mpu_armv8m_enable>
    SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);
 c002b38:	4b1e      	ldr	r3, [pc, #120]	; (c002bb4 <TFM_LL_SECU_ApplyRunTimeProtections+0x234>)
  SAU->RNR  = 1;
 c002b3a:	2001      	movs	r0, #1
 c002b3c:	681a      	ldr	r2, [r3, #0]
 c002b3e:	f022 0201 	bic.w	r2, r2, #1
 c002b42:	601a      	str	r2, [r3, #0]
  SAU->RNR  = 0;
 c002b44:	2200      	movs	r2, #0
 c002b46:	609a      	str	r2, [r3, #8]
  SAU->RBAR = (SRAM1_BASE_NS & SAU_RBAR_BADDR_Msk);
 c002b48:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 c002b4c:	60da      	str	r2, [r3, #12]
  SAU->RLAR = ((SRAM1_BASE_NS + NS_NO_INIT_DATA_SIZE - 1) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c002b4e:	32e1      	adds	r2, #225	; 0xe1
 c002b50:	611a      	str	r2, [r3, #16]
  SAU->RBAR = ((uint32_t)FLASH_NS & SAU_RBAR_BADDR_Msk);
 c002b52:	4a19      	ldr	r2, [pc, #100]	; (c002bb8 <TFM_LL_SECU_ApplyRunTimeProtections+0x238>)
  SAU->RNR  = 1;
 c002b54:	6098      	str	r0, [r3, #8]
  SAU->RBAR = ((uint32_t)FLASH_NS & SAU_RBAR_BADDR_Msk);
 c002b56:	60da      	str	r2, [r3, #12]
  SAU->RLAR = (((uint32_t)FLASH_NS + 0xffff) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c002b58:	f502 427f 	add.w	r2, r2, #65280	; 0xff00
 c002b5c:	32e1      	adds	r2, #225	; 0xe1
 c002b5e:	611a      	str	r2, [r3, #16]
  SAU->RNR  = 2;
 c002b60:	2202      	movs	r2, #2
 c002b62:	609a      	str	r2, [r3, #8]
  SAU->RBAR = ((uint32_t)FLASH_BASE_NS + NS_IMAGE_PRIMARY_PARTITION_OFFSET) & SAU_RBAR_BADDR_Msk;
 c002b64:	4a10      	ldr	r2, [pc, #64]	; (c002ba8 <TFM_LL_SECU_ApplyRunTimeProtections+0x228>)
 c002b66:	60da      	str	r2, [r3, #12]
  SAU->RLAR = (((uint32_t)FLASH_BASE_NS + NS_IMAGE_PRIMARY_PARTITION_OFFSET
 c002b68:	f502 22c5 	add.w	r2, r2, #403456	; 0x62800
 c002b6c:	f202 72e1 	addw	r2, r2, #2017	; 0x7e1
 c002b70:	611a      	str	r2, [r3, #16]
  SAU->RNR  = 3;
 c002b72:	2203      	movs	r2, #3
 c002b74:	609a      	str	r2, [r3, #8]
  SAU->RBAR = LOADER_NS_ROM_ALIAS(FLASH_AREA_LOADER_OFFSET) & SAU_RBAR_BADDR_Msk;
 c002b76:	4a11      	ldr	r2, [pc, #68]	; (c002bbc <TFM_LL_SECU_ApplyRunTimeProtections+0x23c>)
 c002b78:	60da      	str	r2, [r3, #12]
  SAU->RLAR = LOADER_NS_ROM_ALIAS(FLASH_TOTAL_SIZE-1) & SAU_RBAR_BADDR_Msk;
 c002b7a:	f502 42ff 	add.w	r2, r2, #32640	; 0x7f80
 c002b7e:	3260      	adds	r2, #96	; 0x60
 c002b80:	611a      	str	r2, [r3, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 c002b82:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c002b86:	f3bf 8f6f 	isb	sy
    SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);
 c002b8a:	681a      	ldr	r2, [r3, #0]
 c002b8c:	4302      	orrs	r2, r0
 c002b8e:	601a      	str	r2, [r3, #0]
  HAL_FLASHEx_ConfigPrivMode(FLASH_PRIV_DENIED);
 c002b90:	f000 fcbe 	bl	c003510 <HAL_FLASHEx_ConfigPrivMode>
}
 c002b94:	b008      	add	sp, #32
 c002b96:	bd10      	pop	{r4, pc}
 c002b98:	50032c00 	.word	0x50032c00
 c002b9c:	e000ed90 	.word	0xe000ed90
 c002ba0:	0c00d000 	.word	0x0c00d000
 c002ba4:	0c015000 	.word	0x0c015000
 c002ba8:	08015000 	.word	0x08015000
 c002bac:	20000020 	.word	0x20000020
 c002bb0:	2003ffff 	.word	0x2003ffff
 c002bb4:	e000edd0 	.word	0xe000edd0
 c002bb8:	40022000 	.word	0x40022000
 c002bbc:	08078000 	.word	0x08078000
 c002bc0:	3003ffff 	.word	0x3003ffff

0c002bc4 <TFM_LL_SECU_CheckStaticProtections>:
{
 c002bc4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  flash_option_bytes_bank1.WRPArea = OB_WRPAREA_BANK1_AREAA;
 c002bc6:	2301      	movs	r3, #1
  flash_option_bytes_bank1.BootAddrConfig = OB_BOOTADDR_SEC0;
 c002bc8:	2604      	movs	r6, #4
  flash_option_bytes_bank1.WRPArea = OB_WRPAREA_BANK1_AREAA;
 c002bca:	4ca9      	ldr	r4, [pc, #676]	; (c002e70 <TFM_LL_SECU_CheckStaticProtections+0x2ac>)
  flash_option_bytes_bank2.WRPArea = OB_WRPAREA_BANK2_AREAA;
 c002bcc:	4da9      	ldr	r5, [pc, #676]	; (c002e74 <TFM_LL_SECU_CheckStaticProtections+0x2b0>)
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank1);
 c002bce:	4620      	mov	r0, r4
  flash_option_bytes_bank1.WRPArea = OB_WRPAREA_BANK1_AREAA;
 c002bd0:	6063      	str	r3, [r4, #4]
  flash_option_bytes_bank1.WMSecConfig = OB_WMSEC_AREA1;
 c002bd2:	61e3      	str	r3, [r4, #28]
  flash_option_bytes_bank1.BootAddrConfig = OB_BOOTADDR_SEC0;
 c002bd4:	6326      	str	r6, [r4, #48]	; 0x30
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank1);
 c002bd6:	f000 fc17 	bl	c003408 <HAL_FLASHEx_OBGetConfig>
  flash_option_bytes_bank2.WMSecConfig = OB_WMSEC_AREA2;
 c002bda:	2302      	movs	r3, #2
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank2);
 c002bdc:	4628      	mov	r0, r5
  flash_option_bytes_bank2.WMSecConfig = OB_WMSEC_AREA2;
 c002bde:	61eb      	str	r3, [r5, #28]
  flash_option_bytes_bank2.WRPArea = OB_WRPAREA_BANK2_AREAA;
 c002be0:	606e      	str	r6, [r5, #4]
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank2);
 c002be2:	f000 fc11 	bl	c003408 <HAL_FLASHEx_OBGetConfig>
  flash_option_bytes_bank1.OptionType = 0;
 c002be6:	2300      	movs	r3, #0
  flash_option_bytes_bank2.WRPArea = 0;
 c002be8:	e9c5 3300 	strd	r3, r3, [r5]
  flash_option_bytes_bank1.OptionType = 0;
 c002bec:	6023      	str	r3, [r4, #0]
  flash_option_bytes_bank1.WRPArea = 0;
 c002bee:	6063      	str	r3, [r4, #4]
  if ((flash_option_bytes_bank1.USERConfig & FLASH_OPTR_TZEN) != FLASH_OPTR_TZEN)
 c002bf0:	69a3      	ldr	r3, [r4, #24]
 c002bf2:	2b00      	cmp	r3, #0
 c002bf4:	db04      	blt.n	c002c00 <TFM_LL_SECU_CheckStaticProtections+0x3c>
    BOOT_LOG_ERR("Unexpected value for TZEN value");
 c002bf6:	48a0      	ldr	r0, [pc, #640]	; (c002e78 <TFM_LL_SECU_CheckStaticProtections+0x2b4>)
 c002bf8:	f006 f90e 	bl	c008e18 <puts>
    Error_Handler();
 c002bfc:	f009 fea0 	bl	c00c940 <Error_Handler>
  if ((flash_option_bytes_bank1.USERConfig & FLASH_OPTR_DBANK) != FLASH_OPTR_DBANK)
 c002c00:	69a3      	ldr	r3, [r4, #24]
 c002c02:	0258      	lsls	r0, r3, #9
 c002c04:	d404      	bmi.n	c002c10 <TFM_LL_SECU_CheckStaticProtections+0x4c>
    BOOT_LOG_ERR("Unexpected value for dual bank configuration");
 c002c06:	489d      	ldr	r0, [pc, #628]	; (c002e7c <TFM_LL_SECU_CheckStaticProtections+0x2b8>)
 c002c08:	f006 f906 	bl	c008e18 <puts>
    Error_Handler();
 c002c0c:	f009 fe98 	bl	c00c940 <Error_Handler>
  if ((flash_option_bytes_bank1.USERConfig & FLASH_OPTR_SWAP_BANK) != 0)
 c002c10:	69a3      	ldr	r3, [r4, #24]
 c002c12:	02d9      	lsls	r1, r3, #11
 c002c14:	d504      	bpl.n	c002c20 <TFM_LL_SECU_CheckStaticProtections+0x5c>
    BOOT_LOG_ERR("Unexpected value for swap bank configuration");
 c002c16:	489a      	ldr	r0, [pc, #616]	; (c002e80 <TFM_LL_SECU_CheckStaticProtections+0x2bc>)
 c002c18:	f006 f8fe 	bl	c008e18 <puts>
    Error_Handler();
 c002c1c:	f009 fe90 	bl	c00c940 <Error_Handler>
  if (flash_option_bytes_bank1.BootAddr != SBSFU_BOOT_VTOR_ADDR)
 c002c20:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c002c22:	4b98      	ldr	r3, [pc, #608]	; (c002e84 <TFM_LL_SECU_CheckStaticProtections+0x2c0>)
 c002c24:	4299      	cmp	r1, r3
 c002c26:	d007      	beq.n	c002c38 <TFM_LL_SECU_CheckStaticProtections+0x74>
    BOOT_LOG_INF("BootAddr 0x%x", flash_option_bytes_bank1.BootAddr);
 c002c28:	4897      	ldr	r0, [pc, #604]	; (c002e88 <TFM_LL_SECU_CheckStaticProtections+0x2c4>)
 c002c2a:	f006 f86f 	bl	c008d0c <iprintf>
    BOOT_LOG_ERR("Unexpected value for SEC BOOT Address");
 c002c2e:	4897      	ldr	r0, [pc, #604]	; (c002e8c <TFM_LL_SECU_CheckStaticProtections+0x2c8>)
 c002c30:	f006 f8f2 	bl	c008e18 <puts>
    Error_Handler();
 c002c34:	f009 fe84 	bl	c00c940 <Error_Handler>
  if ((start != flash_option_bytes_bank1.WMSecStartPage)
 c002c38:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 c002c3c:	b90b      	cbnz	r3, c002c42 <TFM_LL_SECU_CheckStaticProtections+0x7e>
      || (end != flash_option_bytes_bank1.WMSecEndPage))
 c002c3e:	2a29      	cmp	r2, #41	; 0x29
 c002c40:	d014      	beq.n	c002c6c <TFM_LL_SECU_CheckStaticProtections+0xa8>
    BOOT_LOG_INF("BANK 1 secure flash [%d, %d] : OB [%d, %d]",
 c002c42:	2100      	movs	r1, #0
 c002c44:	9200      	str	r2, [sp, #0]
 c002c46:	4892      	ldr	r0, [pc, #584]	; (c002e90 <TFM_LL_SECU_CheckStaticProtections+0x2cc>)
 c002c48:	2229      	movs	r2, #41	; 0x29
 c002c4a:	f006 f85f 	bl	c008d0c <iprintf>
    BOOT_LOG_ERR("Unexpected value for secure flash protection: set wmsec1");
 c002c4e:	4891      	ldr	r0, [pc, #580]	; (c002e94 <TFM_LL_SECU_CheckStaticProtections+0x2d0>)
 c002c50:	f006 f8e2 	bl	c008e18 <puts>
    flash_option_bytes_bank1.WMSecEndPage = end;
 c002c54:	2329      	movs	r3, #41	; 0x29
 c002c56:	2200      	movs	r2, #0
 c002c58:	e9c4 2308 	strd	r2, r3, [r4, #32]
    flash_option_bytes_bank1.OptionType |= OPTIONBYTE_WMSEC;
 c002c5c:	6823      	ldr	r3, [r4, #0]
 c002c5e:	f043 0310 	orr.w	r3, r3, #16
 c002c62:	6023      	str	r3, [r4, #0]
    flash_option_bytes_bank1.WMSecConfig |= OB_WMSEC_AREA1 | OB_WMSEC_SECURE_AREA_CONFIG;
 c002c64:	69e3      	ldr	r3, [r4, #28]
 c002c66:	f043 0311 	orr.w	r3, r3, #17
 c002c6a:	61e3      	str	r3, [r4, #28]
  else if (flash_option_bytes_bank2.WMSecEndPage >= flash_option_bytes_bank2.WMSecStartPage)
 c002c6c:	e9d5 3208 	ldrd	r3, r2, [r5, #32]
 c002c70:	429a      	cmp	r2, r3
 c002c72:	d310      	bcc.n	c002c96 <TFM_LL_SECU_CheckStaticProtections+0xd2>
    BOOT_LOG_INF("BANK 2 secure flash [%d, %d] : OB [%d, %d]", 127, 0, flash_option_bytes_bank2.WMSecStartPage,
 c002c74:	9200      	str	r2, [sp, #0]
 c002c76:	217f      	movs	r1, #127	; 0x7f
 c002c78:	2200      	movs	r2, #0
 c002c7a:	4887      	ldr	r0, [pc, #540]	; (c002e98 <TFM_LL_SECU_CheckStaticProtections+0x2d4>)
 c002c7c:	f006 f846 	bl	c008d0c <iprintf>
    flash_option_bytes_bank2.WMSecEndPage = 0;
 c002c80:	2300      	movs	r3, #0
 c002c82:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
 c002c86:	e9c5 e308 	strd	lr, r3, [r5, #32]
    flash_option_bytes_bank2.OptionType = OPTIONBYTE_WMSEC;
 c002c8a:	2310      	movs	r3, #16
 c002c8c:	602b      	str	r3, [r5, #0]
    flash_option_bytes_bank2.WMSecConfig |= OB_WMSEC_AREA2 | OB_WMSEC_SECURE_AREA_CONFIG ;
 c002c8e:	69eb      	ldr	r3, [r5, #28]
 c002c90:	f043 0312 	orr.w	r3, r3, #18
 c002c94:	61eb      	str	r3, [r5, #28]
  if ((flash_option_bytes_bank1.WRPStartOffset > flash_option_bytes_bank1.WRPEndOffset)
 c002c96:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 c002c9a:	4293      	cmp	r3, r2
 c002c9c:	d803      	bhi.n	c002ca6 <TFM_LL_SECU_CheckStaticProtections+0xe2>
      || (start != flash_option_bytes_bank1.WRPStartOffset)
 c002c9e:	2b02      	cmp	r3, #2
 c002ca0:	d101      	bne.n	c002ca6 <TFM_LL_SECU_CheckStaticProtections+0xe2>
      || (end != flash_option_bytes_bank1.WRPEndOffset))
 c002ca2:	2a19      	cmp	r2, #25
 c002ca4:	d015      	beq.n	c002cd2 <TFM_LL_SECU_CheckStaticProtections+0x10e>
    BOOT_LOG_INF("BANK 1 flash write protection [%d, %d] : OB [%d, %d]", start, end,
 c002ca6:	2102      	movs	r1, #2
 c002ca8:	9200      	str	r2, [sp, #0]
 c002caa:	487c      	ldr	r0, [pc, #496]	; (c002e9c <TFM_LL_SECU_CheckStaticProtections+0x2d8>)
 c002cac:	2219      	movs	r2, #25
 c002cae:	f006 f82d 	bl	c008d0c <iprintf>
    flash_option_bytes_bank1.WRPEndOffset = end;
 c002cb2:	f04f 0c02 	mov.w	ip, #2
 c002cb6:	2319      	movs	r3, #25
 c002cb8:	e9c4 c302 	strd	ip, r3, [r4, #8]
    flash_option_bytes_bank1.WRPArea |= OB_WRPAREA_BANK1_AREAA;
 c002cbc:	6863      	ldr	r3, [r4, #4]
    BOOT_LOG_ERR("Unexpected value for write protection : set wrp1");
 c002cbe:	4878      	ldr	r0, [pc, #480]	; (c002ea0 <TFM_LL_SECU_CheckStaticProtections+0x2dc>)
    flash_option_bytes_bank1.WRPArea |= OB_WRPAREA_BANK1_AREAA;
 c002cc0:	f043 0301 	orr.w	r3, r3, #1
 c002cc4:	6063      	str	r3, [r4, #4]
    BOOT_LOG_ERR("Unexpected value for write protection : set wrp1");
 c002cc6:	f006 f8a7 	bl	c008e18 <puts>
    flash_option_bytes_bank1.OptionType |= OPTIONBYTE_WRP;
 c002cca:	6823      	ldr	r3, [r4, #0]
 c002ccc:	f043 0301 	orr.w	r3, r3, #1
 c002cd0:	6023      	str	r3, [r4, #0]
  if ((flash_option_bytes_bank2.WRPStartOffset > flash_option_bytes_bank2.WRPEndOffset)
 c002cd2:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
 c002cd6:	4293      	cmp	r3, r2
 c002cd8:	d803      	bhi.n	c002ce2 <TFM_LL_SECU_CheckStaticProtections+0x11e>
      || (start != flash_option_bytes_bank2.WRPStartOffset)
 c002cda:	2b70      	cmp	r3, #112	; 0x70
 c002cdc:	d101      	bne.n	c002ce2 <TFM_LL_SECU_CheckStaticProtections+0x11e>
      || (end != flash_option_bytes_bank2.WRPEndOffset))
 c002cde:	2a7f      	cmp	r2, #127	; 0x7f
 c002ce0:	d014      	beq.n	c002d0c <TFM_LL_SECU_CheckStaticProtections+0x148>
    BOOT_LOG_INF("BANK 2 flash write protection [%d, %d] : OB [%d, %d]", start, end,
 c002ce2:	2170      	movs	r1, #112	; 0x70
 c002ce4:	9200      	str	r2, [sp, #0]
 c002ce6:	486f      	ldr	r0, [pc, #444]	; (c002ea4 <TFM_LL_SECU_CheckStaticProtections+0x2e0>)
 c002ce8:	227f      	movs	r2, #127	; 0x7f
 c002cea:	f006 f80f 	bl	c008d0c <iprintf>
    flash_option_bytes_bank2.WRPEndOffset = end;
 c002cee:	2670      	movs	r6, #112	; 0x70
 c002cf0:	237f      	movs	r3, #127	; 0x7f
 c002cf2:	e9c5 6302 	strd	r6, r3, [r5, #8]
    flash_option_bytes_bank2.WRPArea |= OB_WRPAREA_BANK2_AREAA;
 c002cf6:	686b      	ldr	r3, [r5, #4]
    BOOT_LOG_ERR("Unexpected value for write protection : set wrp2");
 c002cf8:	486b      	ldr	r0, [pc, #428]	; (c002ea8 <TFM_LL_SECU_CheckStaticProtections+0x2e4>)
    flash_option_bytes_bank2.WRPArea |= OB_WRPAREA_BANK2_AREAA;
 c002cfa:	f043 0304 	orr.w	r3, r3, #4
 c002cfe:	606b      	str	r3, [r5, #4]
    BOOT_LOG_ERR("Unexpected value for write protection : set wrp2");
 c002d00:	f006 f88a 	bl	c008e18 <puts>
    flash_option_bytes_bank2.OptionType |= OPTIONBYTE_WRP;
 c002d04:	682b      	ldr	r3, [r5, #0]
 c002d06:	f043 0301 	orr.w	r3, r3, #1
 c002d0a:	602b      	str	r3, [r5, #0]
    (flash_option_bytes_bank1.WMSecStartPage > flash_option_bytes_bank1.WMHDPEndPage)
 c002d0c:	6a23      	ldr	r3, [r4, #32]
 c002d0e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  if (
 c002d10:	4293      	cmp	r3, r2
 c002d12:	d806      	bhi.n	c002d22 <TFM_LL_SECU_CheckStaticProtections+0x15e>
    || (end > flash_option_bytes_bank1.WMHDPEndPage)
 c002d14:	2a17      	cmp	r2, #23
 c002d16:	d904      	bls.n	c002d22 <TFM_LL_SECU_CheckStaticProtections+0x15e>
    || (flash_option_bytes_bank1.WMSecConfig & OB_WMSEC_HDP_AREA_DISABLE))
 c002d18:	69e1      	ldr	r1, [r4, #28]
 c002d1a:	f401 7180 	and.w	r1, r1, #256	; 0x100
 c002d1e:	4319      	orrs	r1, r3
 c002d20:	d016      	beq.n	c002d50 <TFM_LL_SECU_CheckStaticProtections+0x18c>
    BOOT_LOG_INF("BANK 1 secure user flash [%d, %d] : OB [%d, %d]",
 c002d22:	2100      	movs	r1, #0
 c002d24:	9200      	str	r2, [sp, #0]
 c002d26:	4861      	ldr	r0, [pc, #388]	; (c002eac <TFM_LL_SECU_CheckStaticProtections+0x2e8>)
 c002d28:	2218      	movs	r2, #24
 c002d2a:	f005 ffef 	bl	c008d0c <iprintf>
    BOOT_LOG_ERR("Unexpected value for secure user flash protection : set hdp1");
 c002d2e:	4860      	ldr	r0, [pc, #384]	; (c002eb0 <TFM_LL_SECU_CheckStaticProtections+0x2ec>)
 c002d30:	f006 f872 	bl	c008e18 <puts>
    flash_option_bytes_bank1.WMSecStartPage = start;
 c002d34:	2300      	movs	r3, #0
 c002d36:	6223      	str	r3, [r4, #32]
    flash_option_bytes_bank1.WMHDPEndPage = end;
 c002d38:	2318      	movs	r3, #24
 c002d3a:	62a3      	str	r3, [r4, #40]	; 0x28
    flash_option_bytes_bank1.OptionType |= OPTIONBYTE_WMSEC;
 c002d3c:	6823      	ldr	r3, [r4, #0]
 c002d3e:	f043 0310 	orr.w	r3, r3, #16
 c002d42:	6023      	str	r3, [r4, #0]
    flash_option_bytes_bank1.WMSecConfig &= ~OB_WMSEC_HDP_AREA_DISABLE;
 c002d44:	69e3      	ldr	r3, [r4, #28]
 c002d46:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    flash_option_bytes_bank1.WMSecConfig |= OB_WMSEC_AREA1;
 c002d4a:	f043 03a1 	orr.w	r3, r3, #161	; 0xa1
 c002d4e:	61e3      	str	r3, [r4, #28]
  if ((flash_option_bytes_bank1.USERConfig & FLASH_OPTR_SRAM2_RST) != 0)
 c002d50:	69a3      	ldr	r3, [r4, #24]
 c002d52:	0199      	lsls	r1, r3, #6
 c002d54:	d504      	bpl.n	c002d60 <TFM_LL_SECU_CheckStaticProtections+0x19c>
    BOOT_LOG_ERR("Unexpected value for SRAM2 ERASE at Reset");
 c002d56:	4857      	ldr	r0, [pc, #348]	; (c002eb4 <TFM_LL_SECU_CheckStaticProtections+0x2f0>)
 c002d58:	f006 f85e 	bl	c008e18 <puts>
    Error_Handler();
 c002d5c:	f009 fdf0 	bl	c00c940 <Error_Handler>
  if ((flash_option_bytes_bank1.OptionType != 0) || (flash_option_bytes_bank2.OptionType != 0))
 c002d60:	6822      	ldr	r2, [r4, #0]
 c002d62:	682b      	ldr	r3, [r5, #0]
 c002d64:	4313      	orrs	r3, r2
 c002d66:	d045      	beq.n	c002df4 <TFM_LL_SECU_CheckStaticProtections+0x230>
    HAL_FLASH_Unlock();
 c002d68:	f000 f926 	bl	c002fb8 <HAL_FLASH_Unlock>
    HAL_FLASH_OB_Unlock();
 c002d6c:	f000 f958 	bl	c003020 <HAL_FLASH_OB_Unlock>
    if ((flash_option_bytes_bank1.OptionType & OPTIONBYTE_RDP) != 0)
 c002d70:	6823      	ldr	r3, [r4, #0]
 c002d72:	079a      	lsls	r2, r3, #30
 c002d74:	d504      	bpl.n	c002d80 <TFM_LL_SECU_CheckStaticProtections+0x1bc>
      BOOT_LOG_ERR("Unexpected value for OB RDP to program");
 c002d76:	4850      	ldr	r0, [pc, #320]	; (c002eb8 <TFM_LL_SECU_CheckStaticProtections+0x2f4>)
 c002d78:	f006 f84e 	bl	c008e18 <puts>
      Error_Handler();
 c002d7c:	f009 fde0 	bl	c00c940 <Error_Handler>
    if ((flash_option_bytes_bank2.OptionType & OPTIONBYTE_RDP) != 0)
 c002d80:	682b      	ldr	r3, [r5, #0]
 c002d82:	079b      	lsls	r3, r3, #30
 c002d84:	d504      	bpl.n	c002d90 <TFM_LL_SECU_CheckStaticProtections+0x1cc>
      BOOT_LOG_ERR("Unexpected value for OB RDP to program");
 c002d86:	484c      	ldr	r0, [pc, #304]	; (c002eb8 <TFM_LL_SECU_CheckStaticProtections+0x2f4>)
 c002d88:	f006 f846 	bl	c008e18 <puts>
      Error_Handler();
 c002d8c:	f009 fdd8 	bl	c00c940 <Error_Handler>
    if ((flash_option_bytes_bank2.WRPArea & ~OB_WRPAREA_BANK2_AREAA) != 0)
 c002d90:	686b      	ldr	r3, [r5, #4]
 c002d92:	f033 0304 	bics.w	r3, r3, #4
 c002d96:	d004      	beq.n	c002da2 <TFM_LL_SECU_CheckStaticProtections+0x1de>
      BOOT_LOG_ERR("Unexpected value for bank 2 OB WRP AREA to program");
 c002d98:	4848      	ldr	r0, [pc, #288]	; (c002ebc <TFM_LL_SECU_CheckStaticProtections+0x2f8>)
 c002d9a:	f006 f83d 	bl	c008e18 <puts>
      Error_Handler();
 c002d9e:	f009 fdcf 	bl	c00c940 <Error_Handler>
    if ((flash_option_bytes_bank1.WRPArea & ~OB_WRPAREA_BANK1_AREAA) != 0)
 c002da2:	6863      	ldr	r3, [r4, #4]
 c002da4:	f033 0301 	bics.w	r3, r3, #1
 c002da8:	d004      	beq.n	c002db4 <TFM_LL_SECU_CheckStaticProtections+0x1f0>
      BOOT_LOG_ERR("Unexpected value for bank 1 OB WRP AREA to program");
 c002daa:	4845      	ldr	r0, [pc, #276]	; (c002ec0 <TFM_LL_SECU_CheckStaticProtections+0x2fc>)
 c002dac:	f006 f834 	bl	c008e18 <puts>
      Error_Handler();
 c002db0:	f009 fdc6 	bl	c00c940 <Error_Handler>
    if ((flash_option_bytes_bank1.OptionType) != 0)
 c002db4:	6823      	ldr	r3, [r4, #0]
 c002db6:	b143      	cbz	r3, c002dca <TFM_LL_SECU_CheckStaticProtections+0x206>
      ret = HAL_FLASHEx_OBProgram(&flash_option_bytes_bank1);
 c002db8:	482d      	ldr	r0, [pc, #180]	; (c002e70 <TFM_LL_SECU_CheckStaticProtections+0x2ac>)
 c002dba:	f000 f9f3 	bl	c0031a4 <HAL_FLASHEx_OBProgram>
      if (ret != HAL_OK)
 c002dbe:	b120      	cbz	r0, c002dca <TFM_LL_SECU_CheckStaticProtections+0x206>
        BOOT_LOG_ERR("Error while setting OB Bank1 config");
 c002dc0:	4840      	ldr	r0, [pc, #256]	; (c002ec4 <TFM_LL_SECU_CheckStaticProtections+0x300>)
 c002dc2:	f006 f829 	bl	c008e18 <puts>
        Error_Handler();
 c002dc6:	f009 fdbb 	bl	c00c940 <Error_Handler>
    if ((flash_option_bytes_bank2.OptionType) != 0)
 c002dca:	682b      	ldr	r3, [r5, #0]
 c002dcc:	b143      	cbz	r3, c002de0 <TFM_LL_SECU_CheckStaticProtections+0x21c>
      ret = HAL_FLASHEx_OBProgram(&flash_option_bytes_bank2);
 c002dce:	4829      	ldr	r0, [pc, #164]	; (c002e74 <TFM_LL_SECU_CheckStaticProtections+0x2b0>)
 c002dd0:	f000 f9e8 	bl	c0031a4 <HAL_FLASHEx_OBProgram>
      if (ret != HAL_OK)
 c002dd4:	b120      	cbz	r0, c002de0 <TFM_LL_SECU_CheckStaticProtections+0x21c>
        BOOT_LOG_ERR("Error while setting OB Bank1 config");
 c002dd6:	483b      	ldr	r0, [pc, #236]	; (c002ec4 <TFM_LL_SECU_CheckStaticProtections+0x300>)
 c002dd8:	f006 f81e 	bl	c008e18 <puts>
        Error_Handler();
 c002ddc:	f009 fdb0 	bl	c00c940 <Error_Handler>
    ret = HAL_FLASH_OB_Launch();
 c002de0:	f000 f930 	bl	c003044 <HAL_FLASH_OB_Launch>
    if (ret != HAL_OK)
 c002de4:	b120      	cbz	r0, c002df0 <TFM_LL_SECU_CheckStaticProtections+0x22c>
      BOOT_LOG_ERR("Error while execution OB_Launch");
 c002de6:	4838      	ldr	r0, [pc, #224]	; (c002ec8 <TFM_LL_SECU_CheckStaticProtections+0x304>)
 c002de8:	f006 f816 	bl	c008e18 <puts>
      Error_Handler();
 c002dec:	f009 fda8 	bl	c00c940 <Error_Handler>
    HAL_NVIC_SystemReset();
 c002df0:	f000 f8b2 	bl	c002f58 <HAL_NVIC_SystemReset>
  if (flash_option_bytes_bank1.BootLock != TFM_OB_BOOT_LOCK)
 c002df4:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 c002df6:	b139      	cbz	r1, c002e08 <TFM_LL_SECU_CheckStaticProtections+0x244>
    BOOT_LOG_INF("BootLock 0x%x", flash_option_bytes_bank1.BootLock);
 c002df8:	4834      	ldr	r0, [pc, #208]	; (c002ecc <TFM_LL_SECU_CheckStaticProtections+0x308>)
 c002dfa:	f005 ff87 	bl	c008d0c <iprintf>
    BOOT_LOG_ERR("Unexpected value for SEC BOOT LOCK");
 c002dfe:	4834      	ldr	r0, [pc, #208]	; (c002ed0 <TFM_LL_SECU_CheckStaticProtections+0x30c>)
 c002e00:	f006 f80a 	bl	c008e18 <puts>
    Error_Handler();
 c002e04:	f009 fd9c 	bl	c00c940 <Error_Handler>
  if (flash_option_bytes_bank1.RDPLevel != TFM_OB_RDP_LEVEL_VALUE)
 c002e08:	6921      	ldr	r1, [r4, #16]
 c002e0a:	29bb      	cmp	r1, #187	; 0xbb
 c002e0c:	d02d      	beq.n	c002e6a <TFM_LL_SECU_CheckStaticProtections+0x2a6>
    BOOT_LOG_INF("RDPLevel 0x%x (0x%x)", flash_option_bytes_bank1.RDPLevel, TFM_OB_RDP_LEVEL_VALUE);
 c002e0e:	22bb      	movs	r2, #187	; 0xbb
 c002e10:	4830      	ldr	r0, [pc, #192]	; (c002ed4 <TFM_LL_SECU_CheckStaticProtections+0x310>)
 c002e12:	f005 ff7b 	bl	c008d0c <iprintf>
    BOOT_LOG_ERR("Unexpected value for RDP level");
 c002e16:	4830      	ldr	r0, [pc, #192]	; (c002ed8 <TFM_LL_SECU_CheckStaticProtections+0x314>)
 c002e18:	f005 fffe 	bl	c008e18 <puts>
  flash_option_bytes_bank.OptionType = OPTIONBYTE_RDP;
 c002e1c:	2302      	movs	r3, #2
  flash_option_bytes_bank.RDPLevel = rdplevel;
 c002e1e:	21bb      	movs	r1, #187	; 0xbb
  flash_option_bytes_bank.OptionType = OPTIONBYTE_RDP;
 c002e20:	4c2e      	ldr	r4, [pc, #184]	; (c002edc <TFM_LL_SECU_CheckStaticProtections+0x318>)
  BOOT_LOG_INF("Programming RDP to %x", rdplevel);
 c002e22:	482f      	ldr	r0, [pc, #188]	; (c002ee0 <TFM_LL_SECU_CheckStaticProtections+0x31c>)
  flash_option_bytes_bank.OptionType = OPTIONBYTE_RDP;
 c002e24:	6023      	str	r3, [r4, #0]
  flash_option_bytes_bank.RDPLevel = rdplevel;
 c002e26:	6121      	str	r1, [r4, #16]
  BOOT_LOG_INF("Programming RDP to %x", rdplevel);
 c002e28:	f005 ff70 	bl	c008d0c <iprintf>
  BOOT_LOG_INF("Unplug/Plug jumper JP5 (IDD)");
 c002e2c:	482d      	ldr	r0, [pc, #180]	; (c002ee4 <TFM_LL_SECU_CheckStaticProtections+0x320>)
 c002e2e:	f005 fff3 	bl	c008e18 <puts>
  HAL_FLASH_Unlock();
 c002e32:	f000 f8c1 	bl	c002fb8 <HAL_FLASH_Unlock>
  HAL_FLASH_OB_Unlock();
 c002e36:	f000 f8f3 	bl	c003020 <HAL_FLASH_OB_Unlock>
  ret = HAL_FLASHEx_OBProgram(&flash_option_bytes_bank);
 c002e3a:	4620      	mov	r0, r4
 c002e3c:	f000 f9b2 	bl	c0031a4 <HAL_FLASHEx_OBProgram>
  if (ret != HAL_OK)
 c002e40:	b120      	cbz	r0, c002e4c <TFM_LL_SECU_CheckStaticProtections+0x288>
    BOOT_LOG_ERR("Error while setting RDP level");
 c002e42:	4829      	ldr	r0, [pc, #164]	; (c002ee8 <TFM_LL_SECU_CheckStaticProtections+0x324>)
 c002e44:	f005 ffe8 	bl	c008e18 <puts>
    Error_Handler();
 c002e48:	f009 fd7a 	bl	c00c940 <Error_Handler>
  ret = HAL_FLASH_OB_Launch();
 c002e4c:	f000 f8fa 	bl	c003044 <HAL_FLASH_OB_Launch>
  if (ret != HAL_OK)
 c002e50:	b120      	cbz	r0, c002e5c <TFM_LL_SECU_CheckStaticProtections+0x298>
    BOOT_LOG_ERR("Error while execution OB_Launch");
 c002e52:	481d      	ldr	r0, [pc, #116]	; (c002ec8 <TFM_LL_SECU_CheckStaticProtections+0x304>)
 c002e54:	f005 ffe0 	bl	c008e18 <puts>
    Error_Handler();
 c002e58:	f009 fd72 	bl	c00c940 <Error_Handler>
  HAL_NVIC_SystemReset();
 c002e5c:	f000 f87c 	bl	c002f58 <HAL_NVIC_SystemReset>
}
 c002e60:	b002      	add	sp, #8
 c002e62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Error_Handler();
 c002e66:	f009 bd6b 	b.w	c00c940 <Error_Handler>
}
 c002e6a:	b002      	add	sp, #8
 c002e6c:	bd70      	pop	{r4, r5, r6, pc}
 c002e6e:	bf00      	nop
 c002e70:	30030204 	.word	0x30030204
 c002e74:	3003023c 	.word	0x3003023c
 c002e78:	0c00a2e8 	.word	0x0c00a2e8
 c002e7c:	0c00a30f 	.word	0x0c00a30f
 c002e80:	0c00a343 	.word	0x0c00a343
 c002e84:	0c001800 	.word	0x0c001800
 c002e88:	0c00a377 	.word	0x0c00a377
 c002e8c:	0c00a38d 	.word	0x0c00a38d
 c002e90:	0c00a3ba 	.word	0x0c00a3ba
 c002e94:	0c00a3ed 	.word	0x0c00a3ed
 c002e98:	0c00a42d 	.word	0x0c00a42d
 c002e9c:	0c00a460 	.word	0x0c00a460
 c002ea0:	0c00a49d 	.word	0x0c00a49d
 c002ea4:	0c00a4d5 	.word	0x0c00a4d5
 c002ea8:	0c00a512 	.word	0x0c00a512
 c002eac:	0c00a54a 	.word	0x0c00a54a
 c002eb0:	0c00a582 	.word	0x0c00a582
 c002eb4:	0c00a5c6 	.word	0x0c00a5c6
 c002eb8:	0c00a5f7 	.word	0x0c00a5f7
 c002ebc:	0c00a625 	.word	0x0c00a625
 c002ec0:	0c00a65f 	.word	0x0c00a65f
 c002ec4:	0c00a699 	.word	0x0c00a699
 c002ec8:	0c00a6c4 	.word	0x0c00a6c4
 c002ecc:	0c00a6eb 	.word	0x0c00a6eb
 c002ed0:	0c00a701 	.word	0x0c00a701
 c002ed4:	0c00a72b 	.word	0x0c00a72b
 c002ed8:	0c00a748 	.word	0x0c00a748
 c002edc:	300301cc 	.word	0x300301cc
 c002ee0:	0c00a76e 	.word	0x0c00a76e
 c002ee4:	0c00a78c 	.word	0x0c00a78c
 c002ee8:	0c00a7b0 	.word	0x0c00a7b0

0c002eec <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 c002eec:	4770      	bx	lr

0c002eee <HAL_Init>:
{
 c002eee:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 c002ef0:	2004      	movs	r0, #4
 c002ef2:	f000 f81f 	bl	c002f34 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
 c002ef6:	f7ff fccf 	bl	c002898 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 c002efa:	2007      	movs	r0, #7
 c002efc:	f7ff f8f6 	bl	c0020ec <HAL_InitTick>
 c002f00:	4604      	mov	r4, r0
 c002f02:	b918      	cbnz	r0, c002f0c <HAL_Init+0x1e>
    HAL_MspInit();
 c002f04:	f7ff fff2 	bl	c002eec <HAL_MspInit>
}
 c002f08:	4620      	mov	r0, r4
 c002f0a:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 c002f0c:	2401      	movs	r4, #1
 c002f0e:	e7fb      	b.n	c002f08 <HAL_Init+0x1a>

0c002f10 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 c002f10:	b538      	push	{r3, r4, r5, lr}
 c002f12:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 c002f14:	f7ff f8f8 	bl	c002108 <HAL_GetTick>
 c002f18:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 c002f1a:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)uwTickFreq;
 c002f1c:	bf1e      	ittt	ne
 c002f1e:	4b04      	ldrne	r3, [pc, #16]	; (c002f30 <HAL_Delay+0x20>)
 c002f20:	781b      	ldrbne	r3, [r3, #0]
 c002f22:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 c002f24:	f7ff f8f0 	bl	c002108 <HAL_GetTick>
 c002f28:	1b43      	subs	r3, r0, r5
 c002f2a:	42a3      	cmp	r3, r4
 c002f2c:	d3fa      	bcc.n	c002f24 <HAL_Delay+0x14>
  {
  }
}
 c002f2e:	bd38      	pop	{r3, r4, r5, pc}
 c002f30:	3003005c 	.word	0x3003005c

0c002f34 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 c002f34:	4907      	ldr	r1, [pc, #28]	; (c002f54 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 c002f36:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 c002f38:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 c002f3a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 c002f3e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 c002f42:	0412      	lsls	r2, r2, #16
 c002f44:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 c002f46:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 c002f48:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 c002f4c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 c002f50:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 c002f52:	4770      	bx	lr
 c002f54:	e000ed00 	.word	0xe000ed00

0c002f58 <HAL_NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 c002f58:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 c002f5c:	4905      	ldr	r1, [pc, #20]	; (c002f74 <HAL_NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 c002f5e:	4b06      	ldr	r3, [pc, #24]	; (c002f78 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 c002f60:	68ca      	ldr	r2, [r1, #12]
 c002f62:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 c002f66:	4313      	orrs	r3, r2
 c002f68:	60cb      	str	r3, [r1, #12]
 c002f6a:	f3bf 8f4f 	dsb	sy
    __NOP();
 c002f6e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 c002f70:	e7fd      	b.n	c002f6e <HAL_NVIC_SystemReset+0x16>
 c002f72:	bf00      	nop
 c002f74:	e000ed00 	.word	0xe000ed00
 c002f78:	05fa0004 	.word	0x05fa0004

0c002f7c <FLASH_Program_DoubleWord>:
  __IO uint32_t *reg;
  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c002f7c:	490b      	ldr	r1, [pc, #44]	; (c002fac <FLASH_Program_DoubleWord+0x30>)
{
 c002f7e:	b530      	push	{r4, r5, lr}
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c002f80:	688d      	ldr	r5, [r1, #8]
 c002f82:	4c0b      	ldr	r4, [pc, #44]	; (c002fb0 <FLASH_Program_DoubleWord+0x34>)
 c002f84:	490b      	ldr	r1, [pc, #44]	; (c002fb4 <FLASH_Program_DoubleWord+0x38>)
 c002f86:	ea31 0125 	bics.w	r1, r1, r5, asr #32
 c002f8a:	bf28      	it	cs
 c002f8c:	4621      	movcs	r1, r4
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c002f8e:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c002f92:	b672      	cpsid	i
  /* Disable interrupts to avoid any interruption during the double word programming */
  primask_bit = __get_PRIMASK();
  __disable_irq();

  /* Set PG bit */
  SET_BIT((*reg), FLASH_NSCR_NSPG);
 c002f94:	680c      	ldr	r4, [r1, #0]
 c002f96:	f044 0401 	orr.w	r4, r4, #1
 c002f9a:	600c      	str	r4, [r1, #0]

  /* Program first word */
  *(uint32_t*)Address = (uint32_t)Data;
 c002f9c:	6002      	str	r2, [r0, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c002f9e:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t*)(Address+4U) = (uint32_t)(Data >> 32U);
 c002fa2:	6043      	str	r3, [r0, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c002fa4:	f385 8810 	msr	PRIMASK, r5

  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
}
 c002fa8:	bd30      	pop	{r4, r5, pc}
 c002faa:	bf00      	nop
 c002fac:	30030060 	.word	0x30030060
 c002fb0:	40022028 	.word	0x40022028
 c002fb4:	5002202c 	.word	0x5002202c

0c002fb8 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c002fb8:	4b0d      	ldr	r3, [pc, #52]	; (c002ff0 <HAL_FLASH_Unlock+0x38>)
 c002fba:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 c002fbc:	2a00      	cmp	r2, #0
 c002fbe:	461a      	mov	r2, r3
 c002fc0:	db04      	blt.n	c002fcc <HAL_FLASH_Unlock+0x14>
    if(READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c002fc2:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 c002fc4:	2b00      	cmp	r3, #0
 c002fc6:	db0b      	blt.n	c002fe0 <HAL_FLASH_Unlock+0x28>
 c002fc8:	2000      	movs	r0, #0
 c002fca:	4770      	bx	lr
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
 c002fcc:	4909      	ldr	r1, [pc, #36]	; (c002ff4 <HAL_FLASH_Unlock+0x3c>)
 c002fce:	6099      	str	r1, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
 c002fd0:	f101 3188 	add.w	r1, r1, #2290649224	; 0x88888888
 c002fd4:	6099      	str	r1, [r3, #8]
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c002fd6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 c002fd8:	2b00      	cmp	r3, #0
 c002fda:	daf2      	bge.n	c002fc2 <HAL_FLASH_Unlock+0xa>
      status = HAL_ERROR;
 c002fdc:	2001      	movs	r0, #1
}
 c002fde:	4770      	bx	lr
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY1);
 c002fe0:	4b04      	ldr	r3, [pc, #16]	; (c002ff4 <HAL_FLASH_Unlock+0x3c>)
 c002fe2:	60d3      	str	r3, [r2, #12]
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY2);
 c002fe4:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
 c002fe8:	60d3      	str	r3, [r2, #12]
      if (READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c002fea:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
      status = HAL_ERROR;
 c002fec:	0fc0      	lsrs	r0, r0, #31
 c002fee:	4770      	bx	lr
 c002ff0:	50022000 	.word	0x50022000
 c002ff4:	45670123 	.word	0x45670123

0c002ff8 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c002ff8:	4b08      	ldr	r3, [pc, #32]	; (c00301c <HAL_FLASH_Lock+0x24>)
 c002ffa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 c002ffc:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 c003000:	629a      	str	r2, [r3, #40]	; 0x28
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c003002:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 c003004:	2a00      	cmp	r2, #0
    SET_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK);
 c003006:	bfbf      	itttt	lt
 c003008:	6ada      	ldrlt	r2, [r3, #44]	; 0x2c
    status = HAL_OK;
 c00300a:	2000      	movlt	r0, #0
    SET_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK);
 c00300c:	f042 4200 	orrlt.w	r2, r2, #2147483648	; 0x80000000
 c003010:	62da      	strlt	r2, [r3, #44]	; 0x2c
  HAL_StatusTypeDef status = HAL_ERROR;
 c003012:	bfac      	ite	ge
 c003014:	2001      	movge	r0, #1
    if (READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c003016:	6adb      	ldrlt	r3, [r3, #44]	; 0x2c
}
 c003018:	4770      	bx	lr
 c00301a:	bf00      	nop
 c00301c:	50022000 	.word	0x50022000

0c003020 <HAL_FLASH_OB_Unlock>:
  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_OPTLOCK) != 0u)
 c003020:	4b06      	ldr	r3, [pc, #24]	; (c00303c <HAL_FLASH_OB_Unlock+0x1c>)
 c003022:	6a98      	ldr	r0, [r3, #40]	; 0x28
 c003024:	f010 4080 	ands.w	r0, r0, #1073741824	; 0x40000000
 c003028:	d007      	beq.n	c00303a <HAL_FLASH_OB_Unlock+0x1a>
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
 c00302a:	4a05      	ldr	r2, [pc, #20]	; (c003040 <HAL_FLASH_OB_Unlock+0x20>)
 c00302c:	611a      	str	r2, [r3, #16]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
 c00302e:	f102 3244 	add.w	r2, r2, #1145324612	; 0x44444444
 c003032:	611a      	str	r2, [r3, #16]
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_OPTLOCK) != 0u)
 c003034:	6a98      	ldr	r0, [r3, #40]	; 0x28
      return HAL_ERROR;
 c003036:	f3c0 7080 	ubfx	r0, r0, #30, #1
}
 c00303a:	4770      	bx	lr
 c00303c:	50022000 	.word	0x50022000
 c003040:	08192a3b 	.word	0x08192a3b

0c003044 <HAL_FLASH_OB_Launch>:
  SET_BIT(FLASH->NSCR, FLASH_NSCR_OBL_LAUNCH);
 c003044:	4a03      	ldr	r2, [pc, #12]	; (c003054 <HAL_FLASH_OB_Launch+0x10>)
}
 c003046:	2001      	movs	r0, #1
  SET_BIT(FLASH->NSCR, FLASH_NSCR_OBL_LAUNCH);
 c003048:	6a93      	ldr	r3, [r2, #40]	; 0x28
 c00304a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 c00304e:	6293      	str	r3, [r2, #40]	; 0x28
}
 c003050:	4770      	bx	lr
 c003052:	bf00      	nop
 c003054:	50022000 	.word	0x50022000

0c003058 <FLASH_WaitForLastOperation>:
{
 c003058:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 c00305a:	4f1a      	ldr	r7, [pc, #104]	; (c0030c4 <FLASH_WaitForLastOperation+0x6c>)
{
 c00305c:	4604      	mov	r4, r0
  uint32_t timeout = HAL_GetTick() + Timeout;
 c00305e:	f7ff f853 	bl	c002108 <HAL_GetTick>
 c003062:	463d      	mov	r5, r7
 c003064:	1906      	adds	r6, r0, r4
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 c003066:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 c003068:	03da      	lsls	r2, r3, #15
 c00306a:	d41a      	bmi.n	c0030a2 <FLASH_WaitForLastOperation+0x4a>
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);
 c00306c:	4b16      	ldr	r3, [pc, #88]	; (c0030c8 <FLASH_WaitForLastOperation+0x70>)
 c00306e:	4a17      	ldr	r2, [pc, #92]	; (c0030cc <FLASH_WaitForLastOperation+0x74>)
 c003070:	6898      	ldr	r0, [r3, #8]
 c003072:	4917      	ldr	r1, [pc, #92]	; (c0030d0 <FLASH_WaitForLastOperation+0x78>)
 c003074:	ea31 0120 	bics.w	r1, r1, r0, asr #32
 c003078:	bf28      	it	cs
 c00307a:	4611      	movcs	r1, r2
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 c00307c:	680a      	ldr	r2, [r1, #0]
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c00307e:	6a28      	ldr	r0, [r5, #32]
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 c003080:	f002 02fa 	and.w	r2, r2, #250	; 0xfa
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c003084:	f400 5000 	and.w	r0, r0, #8192	; 0x2000
  if(error != 0u)
 c003088:	4302      	orrs	r2, r0
 c00308a:	d012      	beq.n	c0030b2 <FLASH_WaitForLastOperation+0x5a>
    pFlash.ErrorCode |= error;
 c00308c:	6858      	ldr	r0, [r3, #4]
 c00308e:	4310      	orrs	r0, r2
 c003090:	6058      	str	r0, [r3, #4]
    if ((error & FLASH_FLAG_OPTWERR) != 0U)
 c003092:	0493      	lsls	r3, r2, #18
    (*reg_sr) = error;
 c003094:	600a      	str	r2, [r1, #0]
    if ((error & FLASH_FLAG_OPTWERR) != 0U)
 c003096:	d502      	bpl.n	c00309e <FLASH_WaitForLastOperation+0x46>
      FLASH->NSSR = FLASH_FLAG_OPTWERR;
 c003098:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 c00309c:	622b      	str	r3, [r5, #32]
    return HAL_ERROR;
 c00309e:	2001      	movs	r0, #1
 c0030a0:	e00e      	b.n	c0030c0 <FLASH_WaitForLastOperation+0x68>
    if(Timeout != HAL_MAX_DELAY)
 c0030a2:	1c61      	adds	r1, r4, #1
 c0030a4:	d0df      	beq.n	c003066 <FLASH_WaitForLastOperation+0xe>
      if(HAL_GetTick() >= timeout)
 c0030a6:	f7ff f82f 	bl	c002108 <HAL_GetTick>
 c0030aa:	42b0      	cmp	r0, r6
 c0030ac:	d3db      	bcc.n	c003066 <FLASH_WaitForLastOperation+0xe>
        return HAL_TIMEOUT;
 c0030ae:	2003      	movs	r0, #3
 c0030b0:	e006      	b.n	c0030c0 <FLASH_WaitForLastOperation+0x68>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 c0030b2:	6808      	ldr	r0, [r1, #0]
 c0030b4:	f010 0001 	ands.w	r0, r0, #1
 c0030b8:	d002      	beq.n	c0030c0 <FLASH_WaitForLastOperation+0x68>
    (*reg_sr) = FLASH_FLAG_EOP;
 c0030ba:	2301      	movs	r3, #1
  return HAL_OK;
 c0030bc:	4610      	mov	r0, r2
    (*reg_sr) = FLASH_FLAG_EOP;
 c0030be:	600b      	str	r3, [r1, #0]
}
 c0030c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c0030c2:	bf00      	nop
 c0030c4:	50022000 	.word	0x50022000
 c0030c8:	30030060 	.word	0x30030060
 c0030cc:	40022020 	.word	0x40022020
 c0030d0:	50022024 	.word	0x50022024

0c0030d4 <HAL_FLASH_Program>:
{
 c0030d4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __HAL_LOCK(&pFlash);
 c0030d6:	4c17      	ldr	r4, [pc, #92]	; (c003134 <HAL_FLASH_Program+0x60>)
{
 c0030d8:	460e      	mov	r6, r1
  __HAL_LOCK(&pFlash);
 c0030da:	7821      	ldrb	r1, [r4, #0]
{
 c0030dc:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 c0030de:	2901      	cmp	r1, #1
{
 c0030e0:	e9cd 3200 	strd	r3, r2, [sp]
  __HAL_LOCK(&pFlash);
 c0030e4:	d023      	beq.n	c00312e <HAL_FLASH_Program+0x5a>
 c0030e6:	2101      	movs	r1, #1
 c0030e8:	7021      	strb	r1, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0030ea:	2100      	movs	r1, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0030ec:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0030f0:	6061      	str	r1, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0030f2:	f7ff ffb1 	bl	c003058 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 c0030f6:	b9b0      	cbnz	r0, c003126 <HAL_FLASH_Program+0x52>
    FLASH_Program_DoubleWord(Address, Data);
 c0030f8:	e9dd 3200 	ldrd	r3, r2, [sp]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0030fc:	490e      	ldr	r1, [pc, #56]	; (c003138 <HAL_FLASH_Program+0x64>)
 c0030fe:	480f      	ldr	r0, [pc, #60]	; (c00313c <HAL_FLASH_Program+0x68>)
    pFlash.ProcedureOnGoing = TypeProgram;
 c003100:	60a5      	str	r5, [r4, #8]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c003102:	ea31 0525 	bics.w	r5, r1, r5, asr #32
 c003106:	bf28      	it	cs
 c003108:	4605      	movcs	r5, r0
    FLASH_Program_DoubleWord(Address, Data);
 c00310a:	4630      	mov	r0, r6
 c00310c:	f7ff ff36 	bl	c002f7c <FLASH_Program_DoubleWord>
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c003110:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c003114:	f7ff ffa0 	bl	c003058 <FLASH_WaitForLastOperation>
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 c003118:	68a2      	ldr	r2, [r4, #8]
 c00311a:	682b      	ldr	r3, [r5, #0]
 c00311c:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 c003120:	ea23 0302 	bic.w	r3, r3, r2
 c003124:	602b      	str	r3, [r5, #0]
  __HAL_UNLOCK(&pFlash);
 c003126:	2300      	movs	r3, #0
 c003128:	7023      	strb	r3, [r4, #0]
}
 c00312a:	b002      	add	sp, #8
 c00312c:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(&pFlash);
 c00312e:	2002      	movs	r0, #2
 c003130:	e7fb      	b.n	c00312a <HAL_FLASH_Program+0x56>
 c003132:	bf00      	nop
 c003134:	30030060 	.word	0x30030060
 c003138:	5002202c 	.word	0x5002202c
 c00313c:	40022028 	.word	0x40022028

0c003140 <FLASH_MassErase>:
  *            @arg FLASH_BANK_2: Bank2 to be erased
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  * @retval None
  */
static void FLASH_MassErase(uint32_t Banks)
{
 c003140:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c003142:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c003146:	b672      	cpsid	i
  primask_bit = __get_PRIMASK();
  __disable_irq();
#endif
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c003148:	4b12      	ldr	r3, [pc, #72]	; (c003194 <FLASH_MassErase+0x54>)
 c00314a:	4a13      	ldr	r2, [pc, #76]	; (c003198 <FLASH_MassErase+0x58>)
 c00314c:	689c      	ldr	r4, [r3, #8]
 c00314e:	4b13      	ldr	r3, [pc, #76]	; (c00319c <FLASH_MassErase+0x5c>)
 c003150:	ea33 0324 	bics.w	r3, r3, r4, asr #32
 c003154:	bf28      	it	cs
 c003156:	4613      	movcs	r3, r2

  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
 c003158:	4a11      	ldr	r2, [pc, #68]	; (c0031a0 <FLASH_MassErase+0x60>)
 c00315a:	6c12      	ldr	r2, [r2, #64]	; 0x40
 c00315c:	0252      	lsls	r2, r2, #9
 c00315e:	d512      	bpl.n	c003186 <FLASH_MassErase+0x46>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Banks));

    /* Set the Mass Erase Bit for the bank 1 if requested */
    if((Banks & FLASH_BANK_1) != 0U)
 c003160:	07c4      	lsls	r4, r0, #31
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER1);
 c003162:	bf42      	ittt	mi
 c003164:	681a      	ldrmi	r2, [r3, #0]
 c003166:	f042 0204 	orrmi.w	r2, r2, #4
 c00316a:	601a      	strmi	r2, [r3, #0]
    }

    /* Set the Mass Erase Bit for the bank 2 if requested */
    if((Banks & FLASH_BANK_2) != 0U)
 c00316c:	0782      	lsls	r2, r0, #30
 c00316e:	d503      	bpl.n	c003178 <FLASH_MassErase+0x38>
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER2);
 c003170:	681a      	ldr	r2, [r3, #0]
 c003172:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    }
  }
  else
  {
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 c003176:	601a      	str	r2, [r3, #0]
  }

  /* Proceed to erase all sectors */
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 c003178:	681a      	ldr	r2, [r3, #0]
 c00317a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 c00317e:	601a      	str	r2, [r3, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c003180:	f381 8810 	msr	PRIMASK, r1

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 c003184:	bd10      	pop	{r4, pc}
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 c003186:	681a      	ldr	r2, [r3, #0]
 c003188:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 c00318c:	f042 0204 	orr.w	r2, r2, #4
 c003190:	e7f1      	b.n	c003176 <FLASH_MassErase+0x36>
 c003192:	bf00      	nop
 c003194:	30030060 	.word	0x30030060
 c003198:	40022028 	.word	0x40022028
 c00319c:	5002202c 	.word	0x5002202c
 c0031a0:	50022000 	.word	0x50022000

0c0031a4 <HAL_FLASHEx_OBProgram>:
{
 c0031a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 c0031a6:	4e96      	ldr	r6, [pc, #600]	; (c003400 <HAL_FLASHEx_OBProgram+0x25c>)
{
 c0031a8:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 c0031aa:	7833      	ldrb	r3, [r6, #0]
 c0031ac:	2b01      	cmp	r3, #1
 c0031ae:	f000 8124 	beq.w	c0033fa <HAL_FLASHEx_OBProgram+0x256>
 c0031b2:	2301      	movs	r3, #1
 c0031b4:	7033      	strb	r3, [r6, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0031b6:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0031b8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0031bc:	6073      	str	r3, [r6, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0031be:	f7ff ff4b 	bl	c003058 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 c0031c2:	2800      	cmp	r0, #0
 c0031c4:	f040 80db 	bne.w	c00337e <HAL_FLASHEx_OBProgram+0x1da>
    if((pOBInit->OptionType & OPTIONBYTE_WRP) != 0U)
 c0031c8:	6828      	ldr	r0, [r5, #0]
 c0031ca:	07c1      	lsls	r1, r0, #31
 c0031cc:	d50d      	bpl.n	c0031ea <HAL_FLASHEx_OBProgram+0x46>
      FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset);
 c0031ce:	e9d5 2401 	ldrd	r2, r4, [r5, #4]
  assert_param(IS_OB_WRPAREA(WRPArea));
  assert_param(IS_FLASH_PAGE(WRPStartOffset));
  assert_param(IS_FLASH_PAGE(WRPEndOffset));

  /* Configure the write protected area */
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c0031d2:	2a01      	cmp	r2, #1
      FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset);
 c0031d4:	68e9      	ldr	r1, [r5, #12]
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c0031d6:	4b8b      	ldr	r3, [pc, #556]	; (c003404 <HAL_FLASHEx_OBProgram+0x260>)
 c0031d8:	f040 80d4 	bne.w	c003384 <HAL_FLASHEx_OBProgram+0x1e0>
  {
    MODIFY_REG(FLASH->WRP1AR, (FLASH_WRP1AR_WRP1A_PSTRT | FLASH_WRP1AR_WRP1A_PEND),
 c0031dc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c0031de:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c0031e2:	4322      	orrs	r2, r4
 c0031e4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c0031e8:	659a      	str	r2, [r3, #88]	; 0x58
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
 c0031ea:	0782      	lsls	r2, r0, #30
 c0031ec:	d506      	bpl.n	c0031fc <HAL_FLASHEx_OBProgram+0x58>
{
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTR, FLASH_OPTR_RDP, RDPLevel);
 c0031ee:	4a85      	ldr	r2, [pc, #532]	; (c003404 <HAL_FLASHEx_OBProgram+0x260>)
 c0031f0:	6929      	ldr	r1, [r5, #16]
 c0031f2:	6c13      	ldr	r3, [r2, #64]	; 0x40
 c0031f4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 c0031f8:	430b      	orrs	r3, r1
 c0031fa:	6413      	str	r3, [r2, #64]	; 0x40
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
 c0031fc:	0743      	lsls	r3, r0, #29
 c0031fe:	d579      	bpl.n	c0032f4 <HAL_FLASHEx_OBProgram+0x150>
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
 c003200:	e9d5 4105 	ldrd	r4, r1, [r5, #20]
  uint32_t optr_reg_mask = 0;

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  if((UserType & OB_USER_BOR_LEV) != 0U)
 c003204:	f014 0301 	ands.w	r3, r4, #1
  uint32_t optr_reg_mask = 0;
 c003208:	bf0e      	itee	eq
 c00320a:	461a      	moveq	r2, r3
    /* BOR level option byte should be modified */
    assert_param(IS_OB_USER_BOR_LEVEL(UserConfig & FLASH_OPTR_BOR_LEV));

    /* Set value and mask for BOR level option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_BOR_LEV);
    optr_reg_mask |= FLASH_OPTR_BOR_LEV;
 c00320c:	f44f 62e0 	movne.w	r2, #1792	; 0x700
    optr_reg_val |= (UserConfig & FLASH_OPTR_BOR_LEV);
 c003210:	f401 63e0 	andne.w	r3, r1, #1792	; 0x700
  }

  if((UserType & OB_USER_nRST_STOP) != 0U)
 c003214:	07a7      	lsls	r7, r4, #30
  {
    /* nRST_STOP option byte should be modified */
    assert_param(IS_OB_USER_STOP(UserConfig & FLASH_OPTR_nRST_STOP));

    /* Set value and mask for nRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STOP);
 c003216:	bf42      	ittt	mi
 c003218:	f401 5780 	andmi.w	r7, r1, #4096	; 0x1000
 c00321c:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_nRST_STOP;
 c00321e:	f442 5280 	orrmi.w	r2, r2, #4096	; 0x1000
  }

  if((UserType & OB_USER_nRST_STDBY) != 0U)
 c003222:	0767      	lsls	r7, r4, #29
  {
    /* nRST_STDBY option byte should be modified */
    assert_param(IS_OB_USER_STANDBY(UserConfig & FLASH_OPTR_nRST_STDBY));

    /* Set value and mask for nRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STDBY);
 c003224:	bf42      	ittt	mi
 c003226:	f401 5700 	andmi.w	r7, r1, #8192	; 0x2000
 c00322a:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_nRST_STDBY;
 c00322c:	f442 5200 	orrmi.w	r2, r2, #8192	; 0x2000
  }

  if((UserType & OB_USER_nRST_SHDW) != 0U)
 c003230:	0727      	lsls	r7, r4, #28
  {
    /* nRST_SHDW option byte should be modified */
    assert_param(IS_OB_USER_SHUTDOWN(UserConfig & FLASH_OPTR_nRST_SHDW));

    /* Set value and mask for nRST_SHDW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_SHDW);
 c003232:	bf42      	ittt	mi
 c003234:	f401 4780 	andmi.w	r7, r1, #16384	; 0x4000
 c003238:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_nRST_SHDW;
 c00323a:	f442 4280 	orrmi.w	r2, r2, #16384	; 0x4000
  }

  if((UserType & OB_USER_IWDG_SW) != 0U)
 c00323e:	06e7      	lsls	r7, r4, #27
  {
    /* IWDG_SW option byte should be modified */
    assert_param(IS_OB_USER_IWDG(UserConfig & FLASH_OPTR_IWDG_SW));

    /* Set value and mask for IWDG_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_SW);
 c003240:	bf42      	ittt	mi
 c003242:	f401 3780 	andmi.w	r7, r1, #65536	; 0x10000
 c003246:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_IWDG_SW;
 c003248:	f442 3280 	orrmi.w	r2, r2, #65536	; 0x10000
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
 c00324c:	06a7      	lsls	r7, r4, #26
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTR_IWDG_STOP));

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STOP);
 c00324e:	bf42      	ittt	mi
 c003250:	f401 3700 	andmi.w	r7, r1, #131072	; 0x20000
 c003254:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_IWDG_STOP;
 c003256:	f442 3200 	orrmi.w	r2, r2, #131072	; 0x20000
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
 c00325a:	0667      	lsls	r7, r4, #25
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTR_IWDG_STDBY));

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STDBY);
 c00325c:	bf42      	ittt	mi
 c00325e:	f401 2780 	andmi.w	r7, r1, #262144	; 0x40000
 c003262:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_IWDG_STDBY;
 c003264:	f442 2280 	orrmi.w	r2, r2, #262144	; 0x40000
  }

  if((UserType & OB_USER_WWDG_SW) != 0U)
 c003268:	0627      	lsls	r7, r4, #24
  {
    /* WWDG_SW option byte should be modified */
    assert_param(IS_OB_USER_WWDG(UserConfig & FLASH_OPTR_WWDG_SW));

    /* Set value and mask for WWDG_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_WWDG_SW);
 c00326a:	bf42      	ittt	mi
 c00326c:	f401 2700 	andmi.w	r7, r1, #524288	; 0x80000
 c003270:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_WWDG_SW;
 c003272:	f442 2200 	orrmi.w	r2, r2, #524288	; 0x80000
  }

  if((UserType & OB_USER_SWAP_BANK) != 0U)
 c003276:	05e7      	lsls	r7, r4, #23
  {
    /* SWAP_BANK option byte should be modified */
    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTR_SWAP_BANK));

    /* Set value and mask for SWAP_BANK option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_SWAP_BANK);
 c003278:	bf42      	ittt	mi
 c00327a:	f401 1780 	andmi.w	r7, r1, #1048576	; 0x100000
 c00327e:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_SWAP_BANK;
 c003280:	f442 1280 	orrmi.w	r2, r2, #1048576	; 0x100000
  }

  if((UserType & OB_USER_DUALBANK) != 0U)
 c003284:	05a7      	lsls	r7, r4, #22
  {
    /* DUALBANK option byte should be modified */
    assert_param(IS_OB_USER_DUALBANK(UserConfig & FLASH_OPTR_DB256K));

    /* Set value and mask for DB256K option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_DB256K);
 c003286:	bf42      	ittt	mi
 c003288:	f401 1700 	andmi.w	r7, r1, #2097152	; 0x200000
 c00328c:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_DB256K;
 c00328e:	f442 1200 	orrmi.w	r2, r2, #2097152	; 0x200000
  }

  if((UserType & OB_USER_SRAM2_PE) != 0U)
 c003292:	0527      	lsls	r7, r4, #20
  {
    /* SRAM2_PAR option byte should be modified */
    assert_param(IS_OB_USER_SRAM2_PARITY(UserConfig & FLASH_OPTR_SRAM2_PE));

    /* Set value and mask for SRAM2_PAR option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM2_PE);
 c003294:	bf42      	ittt	mi
 c003296:	f001 7780 	andmi.w	r7, r1, #16777216	; 0x1000000
 c00329a:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_SRAM2_PE;
 c00329c:	f042 7280 	orrmi.w	r2, r2, #16777216	; 0x1000000
  }

  if((UserType & OB_USER_SRAM2_RST) != 0U)
 c0032a0:	04e7      	lsls	r7, r4, #19
  {
    /* SRAM2_RST option byte should be modified */
    assert_param(IS_OB_USER_SRAM2_RST(UserConfig & FLASH_OPTR_SRAM2_RST));

    /* Set value and mask for SRAM2_RST option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM2_RST);
 c0032a2:	bf42      	ittt	mi
 c0032a4:	f001 7700 	andmi.w	r7, r1, #33554432	; 0x2000000
 c0032a8:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_SRAM2_RST;
 c0032aa:	f042 7200 	orrmi.w	r2, r2, #33554432	; 0x2000000
  }

  if((UserType & OB_USER_nSWBOOT0) != 0U)
 c0032ae:	04a7      	lsls	r7, r4, #18
  {
    /* nSWBOOT0 option byte should be modified */
    assert_param(IS_OB_USER_SWBOOT0(UserConfig & FLASH_OPTR_nSWBOOT0));

    /* Set value and mask for nSWBOOT0 option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nSWBOOT0);
 c0032b0:	bf42      	ittt	mi
 c0032b2:	f001 6780 	andmi.w	r7, r1, #67108864	; 0x4000000
 c0032b6:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_nSWBOOT0;
 c0032b8:	f042 6280 	orrmi.w	r2, r2, #67108864	; 0x4000000
  }

  if((UserType & OB_USER_nBOOT0) != 0U)
 c0032bc:	0467      	lsls	r7, r4, #17
  {
    /* nBOOT0 option byte should be modified */
    assert_param(IS_OB_USER_BOOT0(UserConfig & FLASH_OPTR_nBOOT0));

    /* Set value and mask for nBOOT0 option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nBOOT0);
 c0032be:	bf42      	ittt	mi
 c0032c0:	f001 6700 	andmi.w	r7, r1, #134217728	; 0x8000000
 c0032c4:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_nBOOT0;
 c0032c6:	f042 6200 	orrmi.w	r2, r2, #134217728	; 0x8000000
  }

  if((UserType & OB_USER_PA15_PUPEN) != 0U)
 c0032ca:	0427      	lsls	r7, r4, #16
  {
    /* nBOOT0 option byte should be modified */
    assert_param(IS_OB_USER_PA15_PUPEN(UserConfig & FLASH_OPTR_PA15_PUPEN));

    /* Set value and mask for nBOOT0 option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_PA15_PUPEN);
 c0032cc:	bf42      	ittt	mi
 c0032ce:	f001 5780 	andmi.w	r7, r1, #268435456	; 0x10000000
 c0032d2:	433b      	orrmi	r3, r7
    optr_reg_mask |= FLASH_OPTR_PA15_PUPEN;
 c0032d4:	f042 5280 	orrmi.w	r2, r2, #268435456	; 0x10000000
  }

  if((UserType & OB_USER_TZEN) != 0U)
 c0032d8:	03e4      	lsls	r4, r4, #15
    optr_reg_val |= (UserConfig & FLASH_OPTR_TZEN);
    optr_reg_mask |= FLASH_OPTR_TZEN;
  }

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 c0032da:	4c4a      	ldr	r4, [pc, #296]	; (c003404 <HAL_FLASHEx_OBProgram+0x260>)
    optr_reg_val |= (UserConfig & FLASH_OPTR_TZEN);
 c0032dc:	bf44      	itt	mi
 c0032de:	f001 4100 	andmi.w	r1, r1, #2147483648	; 0x80000000
 c0032e2:	430b      	orrmi	r3, r1
  MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 c0032e4:	6c21      	ldr	r1, [r4, #64]	; 0x40
    optr_reg_mask |= FLASH_OPTR_TZEN;
 c0032e6:	bf48      	it	mi
 c0032e8:	f042 4200 	orrmi.w	r2, r2, #2147483648	; 0x80000000
  MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 c0032ec:	ea21 0202 	bic.w	r2, r1, r2
 c0032f0:	4313      	orrs	r3, r2
 c0032f2:	6423      	str	r3, [r4, #64]	; 0x40
    if((pOBInit->OptionType & OPTIONBYTE_WMSEC) != 0U)
 c0032f4:	06c3      	lsls	r3, r0, #27
 c0032f6:	d524      	bpl.n	c003342 <HAL_FLASHEx_OBProgram+0x19e>
      FLASH_OB_WMSECConfig(pOBInit->WMSecConfig, pOBInit->WMSecStartPage, pOBInit->WMSecEndPage, pOBInit->WMHDPEndPage);
 c0032f8:	e9d5 1407 	ldrd	r1, r4, [r5, #28]
 c0032fc:	e9d5 ec09 	ldrd	lr, ip, [r5, #36]	; 0x24
  assert_param(IS_FLASH_PAGE(WMSecStartPage));
  assert_param(IS_FLASH_PAGE(WMSecEndPage));
  assert_param(IS_FLASH_PAGE(WMHDPEndPage));

  /* Read SECWM registers */
  if ((WMSecConfig & OB_WMSEC_AREA1) != 0U)
 c003300:	f011 0701 	ands.w	r7, r1, #1
 c003304:	4b3f      	ldr	r3, [pc, #252]	; (c003404 <HAL_FLASHEx_OBProgram+0x260>)
 c003306:	d05c      	beq.n	c0033c2 <HAL_FLASHEx_OBProgram+0x21e>
  {
    tmp_secwm1 = FLASH->SECWM1R1;
 c003308:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    tmp_secwm2 = FLASH->SECWM1R2;
 c00330a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  {
    /* Nothing to do */
  }

  /* Configure Secure Area */
  if ((WMSecConfig & OB_WMSEC_SECURE_AREA_CONFIG) != 0U)
 c00330c:	f011 0f10 	tst.w	r1, #16
  {
    MODIFY_REG(tmp_secwm1, (FLASH_SECWM1R1_SECWM1_PSTRT | FLASH_SECWM1R1_SECWM1_PEND),
 c003310:	bf1e      	ittt	ne
 c003312:	ea44 440e 	orrne.w	r4, r4, lr, lsl #16
 c003316:	f022 127f 	bicne.w	r2, r2, #8323199	; 0x7f007f
 c00331a:	4322      	orrne	r2, r4
               ((WMSecEndPage << FLASH_SECWM1R1_SECWM1_PEND_Pos) | WMSecStartPage));
  }

  /* Configure Secure Hide Area */
  if ((WMSecConfig & OB_WMSEC_HDP_AREA_CONFIG) != 0U)
 c00331c:	068c      	lsls	r4, r1, #26
  {
    tmp_secwm2 &= (~(FLASH_SECWM1R2_HDP1_PEND));
 c00331e:	bf44      	itt	mi
 c003320:	f423 03fe 	bicmi.w	r3, r3, #8323072	; 0x7f0000
    tmp_secwm2 |= (WMHDPEndPage << FLASH_SECWM1R2_HDP1_PEND_Pos);
 c003324:	ea43 430c 	orrmi.w	r3, r3, ip, lsl #16
  }

  /* Enable Secure Hide Area */
  if ((WMSecConfig & OB_WMSEC_HDP_AREA_ENABLE) != 0U)
 c003328:	060c      	lsls	r4, r1, #24
  {
    tmp_secwm2 |= FLASH_SECWM1R2_HDP1EN;
 c00332a:	bf48      	it	mi
 c00332c:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
  }

  /* Disable Secure Hide Area */
  if ((WMSecConfig & OB_WMSEC_HDP_AREA_DISABLE) != 0U)
 c003330:	05cc      	lsls	r4, r1, #23
  {
    tmp_secwm2 &= (~FLASH_SECWM1R2_HDP1EN);
 c003332:	bf48      	it	mi
 c003334:	f023 4300 	bicmi.w	r3, r3, #2147483648	; 0x80000000
  }

  /* Write SECWM registers */
  if ((WMSecConfig & OB_WMSEC_AREA1) != 0U)
 c003338:	4c32      	ldr	r4, [pc, #200]	; (c003404 <HAL_FLASHEx_OBProgram+0x260>)
 c00333a:	2f00      	cmp	r7, #0
 c00333c:	d048      	beq.n	c0033d0 <HAL_FLASHEx_OBProgram+0x22c>
  {
    FLASH->SECWM1R1 = tmp_secwm1;
 c00333e:	6522      	str	r2, [r4, #80]	; 0x50
    FLASH->SECWM1R2 = tmp_secwm2;
 c003340:	6563      	str	r3, [r4, #84]	; 0x54
    if((pOBInit->OptionType & OPTIONBYTE_BOOT_LOCK) != 0U)
 c003342:	0682      	lsls	r2, r0, #26
 c003344:	d506      	bpl.n	c003354 <HAL_FLASHEx_OBProgram+0x1b0>
{
  /* Check the parameters */
  assert_param(IS_OB_BOOT_LOCK(BootLockConfig));

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->SECBOOTADD0R, FLASH_SECBOOTADD0R_BOOT_LOCK, BootLockConfig);
 c003346:	4a2f      	ldr	r2, [pc, #188]	; (c003404 <HAL_FLASHEx_OBProgram+0x260>)
 c003348:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 c00334a:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 c00334c:	f023 0301 	bic.w	r3, r3, #1
 c003350:	430b      	orrs	r3, r1
 c003352:	64d3      	str	r3, [r2, #76]	; 0x4c
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADDR) != 0U)
 c003354:	0703      	lsls	r3, r0, #28
 c003356:	d509      	bpl.n	c00336c <HAL_FLASHEx_OBProgram+0x1c8>
      FLASH_OB_BootAddrConfig(pOBInit->BootAddrConfig, pOBInit->BootAddr);
 c003358:	e9d5 210c 	ldrd	r2, r1, [r5, #48]	; 0x30
static void FLASH_OB_BootAddrConfig(uint32_t BootAddrConfig, uint32_t BootAddr)
{
  /* Check the parameters */
  assert_param(IS_OB_BOOTADDR_CONFIG(BootAddrConfig));

  if (BootAddrConfig == OB_BOOTADDR_NS0)
 c00335c:	2a01      	cmp	r2, #1
 c00335e:	4b29      	ldr	r3, [pc, #164]	; (c003404 <HAL_FLASHEx_OBProgram+0x260>)
 c003360:	d13b      	bne.n	c0033da <HAL_FLASHEx_OBProgram+0x236>
  {
    MODIFY_REG(FLASH->NSBOOTADD0R, FLASH_NSBOOTADD0R_NSBOOTADD0, BootAddr);
 c003362:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 c003364:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c003368:	430a      	orrs	r2, r1
 c00336a:	645a      	str	r2, [r3, #68]	; 0x44
    SET_BIT(FLASH->NSCR, FLASH_NSCR_OPTSTRT);
 c00336c:	4a25      	ldr	r2, [pc, #148]	; (c003404 <HAL_FLASHEx_OBProgram+0x260>)
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c00336e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    SET_BIT(FLASH->NSCR, FLASH_NSCR_OPTSTRT);
 c003372:	6a93      	ldr	r3, [r2, #40]	; 0x28
 c003374:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 c003378:	6293      	str	r3, [r2, #40]	; 0x28
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c00337a:	f7ff fe6d 	bl	c003058 <FLASH_WaitForLastOperation>
  __HAL_UNLOCK(&pFlash);
 c00337e:	2300      	movs	r3, #0
 c003380:	7033      	strb	r3, [r6, #0]
}
 c003382:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(WRPArea == OB_WRPAREA_BANK1_AREAB)
 c003384:	2a02      	cmp	r2, #2
 c003386:	d107      	bne.n	c003398 <HAL_FLASHEx_OBProgram+0x1f4>
    MODIFY_REG(FLASH->WRP1BR, (FLASH_WRP1BR_WRP1B_PSTRT | FLASH_WRP1BR_WRP1B_PEND),
 c003388:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 c00338a:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c00338e:	4322      	orrs	r2, r4
 c003390:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c003394:	65da      	str	r2, [r3, #92]	; 0x5c
 c003396:	e728      	b.n	c0031ea <HAL_FLASHEx_OBProgram+0x46>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAA)
 c003398:	2a04      	cmp	r2, #4
 c00339a:	d107      	bne.n	c0033ac <HAL_FLASHEx_OBProgram+0x208>
    MODIFY_REG(FLASH->WRP2AR, (FLASH_WRP2AR_WRP2A_PSTRT | FLASH_WRP2AR_WRP2A_PEND),
 c00339c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 c00339e:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c0033a2:	4322      	orrs	r2, r4
 c0033a4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c0033a8:	669a      	str	r2, [r3, #104]	; 0x68
 c0033aa:	e71e      	b.n	c0031ea <HAL_FLASHEx_OBProgram+0x46>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAB)
 c0033ac:	2a08      	cmp	r2, #8
 c0033ae:	f47f af1c 	bne.w	c0031ea <HAL_FLASHEx_OBProgram+0x46>
    MODIFY_REG(FLASH->WRP2BR, (FLASH_WRP2BR_WRP2B_PSTRT | FLASH_WRP2BR_WRP2B_PEND),
 c0033b2:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 c0033b4:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c0033b8:	4322      	orrs	r2, r4
 c0033ba:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c0033be:	66da      	str	r2, [r3, #108]	; 0x6c
 c0033c0:	e713      	b.n	c0031ea <HAL_FLASHEx_OBProgram+0x46>
  else if ((WMSecConfig & OB_WMSEC_AREA2) != 0U)
 c0033c2:	f011 0202 	ands.w	r2, r1, #2
    tmp_secwm1 = FLASH->SECWM2R1;
 c0033c6:	bf16      	itet	ne
 c0033c8:	6e1a      	ldrne	r2, [r3, #96]	; 0x60
  uint32_t tmp_secwm1 = 0U, tmp_secwm2 = 0U;
 c0033ca:	4613      	moveq	r3, r2
    tmp_secwm2 = FLASH->SECWM2R2;
 c0033cc:	6e5b      	ldrne	r3, [r3, #100]	; 0x64
 c0033ce:	e79d      	b.n	c00330c <HAL_FLASHEx_OBProgram+0x168>
  else if ((WMSecConfig & OB_WMSEC_AREA2) != 0U)
 c0033d0:	0789      	lsls	r1, r1, #30
    FLASH->SECWM2R1 = tmp_secwm1;
 c0033d2:	bf44      	itt	mi
 c0033d4:	6622      	strmi	r2, [r4, #96]	; 0x60
    FLASH->SECWM2R2 = tmp_secwm2;
 c0033d6:	6663      	strmi	r3, [r4, #100]	; 0x64
 c0033d8:	e7b3      	b.n	c003342 <HAL_FLASHEx_OBProgram+0x19e>
  }
  else if (BootAddrConfig == OB_BOOTADDR_NS1)
 c0033da:	2a02      	cmp	r2, #2
 c0033dc:	d105      	bne.n	c0033ea <HAL_FLASHEx_OBProgram+0x246>
  {
    MODIFY_REG(FLASH->NSBOOTADD1R, FLASH_NSBOOTADD1R_NSBOOTADD1, BootAddr);
 c0033de:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 c0033e0:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0033e4:	430a      	orrs	r2, r1
 c0033e6:	649a      	str	r2, [r3, #72]	; 0x48
 c0033e8:	e7c0      	b.n	c00336c <HAL_FLASHEx_OBProgram+0x1c8>
  }
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  else if (BootAddrConfig == OB_BOOTADDR_SEC0)
 c0033ea:	2a04      	cmp	r2, #4
  {
    MODIFY_REG(FLASH->SECBOOTADD0R, FLASH_SECBOOTADD0R_SECBOOTADD0, BootAddr);
 c0033ec:	bf01      	itttt	eq
 c0033ee:	6cda      	ldreq	r2, [r3, #76]	; 0x4c
 c0033f0:	f002 027f 	andeq.w	r2, r2, #127	; 0x7f
 c0033f4:	430a      	orreq	r2, r1
 c0033f6:	64da      	streq	r2, [r3, #76]	; 0x4c
 c0033f8:	e7b8      	b.n	c00336c <HAL_FLASHEx_OBProgram+0x1c8>
  __HAL_LOCK(&pFlash);
 c0033fa:	2002      	movs	r0, #2
 c0033fc:	e7c1      	b.n	c003382 <HAL_FLASHEx_OBProgram+0x1de>
 c0033fe:	bf00      	nop
 c003400:	30030060 	.word	0x30030060
 c003404:	50022000 	.word	0x50022000

0c003408 <HAL_FLASHEx_OBGetConfig>:
  pOBInit->OptionType = (OPTIONBYTE_RDP | OPTIONBYTE_USER);
 c003408:	2306      	movs	r3, #6
  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 c00340a:	6842      	ldr	r2, [r0, #4]
{
 c00340c:	b510      	push	{r4, lr}
  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 c00340e:	2a08      	cmp	r2, #8
  pOBInit->OptionType = (OPTIONBYTE_RDP | OPTIONBYTE_USER);
 c003410:	6003      	str	r3, [r0, #0]
  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 c003412:	d811      	bhi.n	c003438 <HAL_FLASHEx_OBGetConfig+0x30>
 c003414:	f44f 738b 	mov.w	r3, #278	; 0x116
 c003418:	40d3      	lsrs	r3, r2
 c00341a:	07db      	lsls	r3, r3, #31
 c00341c:	d50c      	bpl.n	c003438 <HAL_FLASHEx_OBGetConfig+0x30>
    pOBInit->OptionType |= OPTIONBYTE_WRP;
 c00341e:	2307      	movs	r3, #7
  * @retval None
  */
static void FLASH_OB_GetWRP(uint32_t WRPArea, uint32_t * WRPStartOffset, uint32_t * WRPEndOffset)
{
  /* Get the configuration of the write protected area */
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c003420:	2a01      	cmp	r2, #1
    pOBInit->OptionType |= OPTIONBYTE_WRP;
 c003422:	6003      	str	r3, [r0, #0]
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c003424:	4b39      	ldr	r3, [pc, #228]	; (c00350c <HAL_FLASHEx_OBGetConfig+0x104>)
 c003426:	d14e      	bne.n	c0034c6 <HAL_FLASHEx_OBGetConfig+0xbe>
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_PSTRT);
 c003428:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c00342a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c00342e:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_PEND) >> FLASH_WRP1AR_WRP1A_PEND_Pos);
 c003430:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    *WRPEndOffset = (READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PEND) >> FLASH_WRP2AR_WRP2A_PEND_Pos);
  }
  else if(WRPArea == OB_WRPAREA_BANK2_AREAB)
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PSTRT);
    *WRPEndOffset = (READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PEND) >> FLASH_WRP2BR_WRP2B_PEND_Pos);
 c003432:	f3c3 4306 	ubfx	r3, r3, #16, #7
 c003436:	60c3      	str	r3, [r0, #12]
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
  uint32_t rdp_level = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
 c003438:	4a34      	ldr	r2, [pc, #208]	; (c00350c <HAL_FLASHEx_OBGetConfig+0x104>)
 c00343a:	6c13      	ldr	r3, [r2, #64]	; 0x40
 c00343c:	b2db      	uxtb	r3, r3

  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_0_5) && (rdp_level != OB_RDP_LEVEL_2))
 c00343e:	2baa      	cmp	r3, #170	; 0xaa
 c003440:	d004      	beq.n	c00344c <HAL_FLASHEx_OBGetConfig+0x44>
 c003442:	2b55      	cmp	r3, #85	; 0x55
 c003444:	d002      	beq.n	c00344c <HAL_FLASHEx_OBGetConfig+0x44>
  {
    return (OB_RDP_LEVEL_1);
 c003446:	2bcc      	cmp	r3, #204	; 0xcc
 c003448:	bf18      	it	ne
 c00344a:	23bb      	movne	r3, #187	; 0xbb
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 c00344c:	6103      	str	r3, [r0, #16]
  *         @ref OB_USER_nSWBOOT0, @ref OB_USER_nBOOT0, @ref FLASH_OB_USER_PA15_PUPEN
  *         and @ref OB_USER_TZEN
  */
static uint32_t FLASH_OB_GetUser(void)
{
  uint32_t user_config = READ_REG(FLASH->OPTR);
 c00344e:	6c13      	ldr	r3, [r2, #64]	; 0x40
  CLEAR_BIT(user_config, FLASH_OPTR_RDP);
 c003450:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  pOBInit->USERConfig = FLASH_OB_GetUser();
 c003454:	6183      	str	r3, [r0, #24]
  if ((pOBInit->WMSecConfig == OB_WMSEC_AREA1) || (pOBInit->WMSecConfig == OB_WMSEC_AREA2))
 c003456:	69c3      	ldr	r3, [r0, #28]
 c003458:	1e59      	subs	r1, r3, #1
 c00345a:	2901      	cmp	r1, #1
 c00345c:	d81a      	bhi.n	c003494 <HAL_FLASHEx_OBGetConfig+0x8c>
    pOBInit->OptionType |= OPTIONBYTE_WMSEC;
 c00345e:	6801      	ldr	r1, [r0, #0]
  /* Check the parameters */
  assert_param(IS_OB_WMSEC_CONFIG(*WMSecConfig));
  assert_param(IS_FLASH_BANK_EXCLUSIVE((*WMSecConfig) & 0x3U));

  /* Read SECWM registers */
  if (((*WMSecConfig) & OB_WMSEC_AREA1) != 0U)
 c003460:	2b01      	cmp	r3, #1
    pOBInit->OptionType |= OPTIONBYTE_WMSEC;
 c003462:	f041 0110 	orr.w	r1, r1, #16
 c003466:	6001      	str	r1, [r0, #0]
  {
    tmp_secwm1 = FLASH->SECWM1R1;
 c003468:	bf0b      	itete	eq
 c00346a:	6d11      	ldreq	r1, [r2, #80]	; 0x50
    tmp_secwm2 = FLASH->SECWM1R2;
  }
  else if (((*WMSecConfig) & OB_WMSEC_AREA2) != 0U)
  {
    tmp_secwm1 = FLASH->SECWM2R1;
 c00346c:	6e11      	ldrne	r1, [r2, #96]	; 0x60
    tmp_secwm2 = FLASH->SECWM1R2;
 c00346e:	6d52      	ldreq	r2, [r2, #84]	; 0x54
    tmp_secwm2 = FLASH->SECWM2R2;
 c003470:	6e52      	ldrne	r2, [r2, #100]	; 0x64
  {
    /* Nothing to do */
  }

  /* Configuration of secure area */
  *WMSecStartPage = (tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PSTRT);
 c003472:	f001 047f 	and.w	r4, r1, #127	; 0x7f
  *WMSecEndPage = ((tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PEND) >> FLASH_SECWM1R1_SECWM1_PEND_Pos);

  /* Configuration of secure hide area */
  *WMHDPEndPage = ((tmp_secwm2 & FLASH_SECWM1R2_HDP1_PEND) >> FLASH_SECWM1R2_HDP1_PEND_Pos);

  if ((tmp_secwm2 & FLASH_SECWM1R2_HDP1EN) == 0U)
 c003476:	2a00      	cmp	r2, #0
  *WMSecEndPage = ((tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PEND) >> FLASH_SECWM1R1_SECWM1_PEND_Pos);
 c003478:	f3c1 4106 	ubfx	r1, r1, #16, #7
 c00347c:	6241      	str	r1, [r0, #36]	; 0x24
  {
    *WMSecConfig = ((*WMSecConfig) | OB_WMSEC_HDP_AREA_DISABLE);
 c00347e:	bfa8      	it	ge
 c003480:	f443 7380 	orrge.w	r3, r3, #256	; 0x100
  *WMHDPEndPage = ((tmp_secwm2 & FLASH_SECWM1R2_HDP1_PEND) >> FLASH_SECWM1R2_HDP1_PEND_Pos);
 c003484:	f3c2 4106 	ubfx	r1, r2, #16, #7
  }
  else
  {
    *WMSecConfig = ((*WMSecConfig) | OB_WMSEC_HDP_AREA_ENABLE);
 c003488:	bfb8      	it	lt
 c00348a:	f043 0380 	orrlt.w	r3, r3, #128	; 0x80
  *WMSecStartPage = (tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PSTRT);
 c00348e:	6204      	str	r4, [r0, #32]
  *WMHDPEndPage = ((tmp_secwm2 & FLASH_SECWM1R2_HDP1_PEND) >> FLASH_SECWM1R2_HDP1_PEND_Pos);
 c003490:	6281      	str	r1, [r0, #40]	; 0x28
    *WMSecConfig = ((*WMSecConfig) | OB_WMSEC_HDP_AREA_ENABLE);
 c003492:	61c3      	str	r3, [r0, #28]
  pOBInit->OptionType |= OPTIONBYTE_BOOT_LOCK;
 c003494:	6801      	ldr	r1, [r0, #0]
  *            @arg OB_BOOT_LOCK_DISABLE: Boot Lock mode deactivated
  *            @arg OB_BOOT_LOCK_ENABLE: Boot Lock mode activated
  */
static uint32_t FLASH_OB_GetBootLock(void)
{
  return (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_BOOT_LOCK);
 c003496:	4a1d      	ldr	r2, [pc, #116]	; (c00350c <HAL_FLASHEx_OBGetConfig+0x104>)
  pOBInit->OptionType |= OPTIONBYTE_BOOT_LOCK;
 c003498:	f041 0320 	orr.w	r3, r1, #32
 c00349c:	6003      	str	r3, [r0, #0]
  return (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_BOOT_LOCK);
 c00349e:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 c0034a0:	f003 0301 	and.w	r3, r3, #1
  pOBInit->BootLock = FLASH_OB_GetBootLock();
 c0034a4:	62c3      	str	r3, [r0, #44]	; 0x2c
  if ((pOBInit->BootAddrConfig == OB_BOOTADDR_NS0) || (pOBInit->BootAddrConfig == OB_BOOTADDR_NS1) ||
 c0034a6:	6b03      	ldr	r3, [r0, #48]	; 0x30
 c0034a8:	1e5c      	subs	r4, r3, #1
 c0034aa:	2c01      	cmp	r4, #1
 c0034ac:	d901      	bls.n	c0034b2 <HAL_FLASHEx_OBGetConfig+0xaa>
 c0034ae:	2b04      	cmp	r3, #4
 c0034b0:	d108      	bne.n	c0034c4 <HAL_FLASHEx_OBGetConfig+0xbc>
    pOBInit->OptionType |= OPTIONBYTE_BOOTADDR;
 c0034b2:	f041 0128 	orr.w	r1, r1, #40	; 0x28
  *
  * @retval None
  */
static void FLASH_OB_GetBootAddr(uint32_t BootAddrConfig, uint32_t * BootAddr)
{
  if (BootAddrConfig == OB_BOOTADDR_NS0)
 c0034b6:	2b01      	cmp	r3, #1
    pOBInit->OptionType |= OPTIONBYTE_BOOTADDR;
 c0034b8:	6001      	str	r1, [r0, #0]
  if (BootAddrConfig == OB_BOOTADDR_NS0)
 c0034ba:	d11c      	bne.n	c0034f6 <HAL_FLASHEx_OBGetConfig+0xee>
  {
    *BootAddr = (FLASH->NSBOOTADD0R & FLASH_NSBOOTADD0R_NSBOOTADD0);
 c0034bc:	6c53      	ldr	r3, [r2, #68]	; 0x44
    *BootAddr = (FLASH->NSBOOTADD1R & FLASH_NSBOOTADD1R_NSBOOTADD1);
  }
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  else if (BootAddrConfig == OB_BOOTADDR_SEC0)
  {
    *BootAddr = (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_SECBOOTADD0);
 c0034be:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 c0034c2:	6343      	str	r3, [r0, #52]	; 0x34
}
 c0034c4:	bd10      	pop	{r4, pc}
  else if(WRPArea == OB_WRPAREA_BANK1_AREAB)
 c0034c6:	2a02      	cmp	r2, #2
 c0034c8:	d105      	bne.n	c0034d6 <HAL_FLASHEx_OBGetConfig+0xce>
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_PSTRT);
 c0034ca:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 c0034cc:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0034d0:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_PEND) >> FLASH_WRP1BR_WRP1B_PEND_Pos);
 c0034d2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 c0034d4:	e7ad      	b.n	c003432 <HAL_FLASHEx_OBGetConfig+0x2a>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAA)
 c0034d6:	2a04      	cmp	r2, #4
 c0034d8:	d105      	bne.n	c0034e6 <HAL_FLASHEx_OBGetConfig+0xde>
    *WRPStartOffset = READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PSTRT);
 c0034da:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 c0034dc:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0034e0:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PEND) >> FLASH_WRP2AR_WRP2A_PEND_Pos);
 c0034e2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 c0034e4:	e7a5      	b.n	c003432 <HAL_FLASHEx_OBGetConfig+0x2a>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAB)
 c0034e6:	2a08      	cmp	r2, #8
 c0034e8:	d1a6      	bne.n	c003438 <HAL_FLASHEx_OBGetConfig+0x30>
    *WRPStartOffset = READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PSTRT);
 c0034ea:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 c0034ec:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0034f0:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PEND) >> FLASH_WRP2BR_WRP2B_PEND_Pos);
 c0034f2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 c0034f4:	e79d      	b.n	c003432 <HAL_FLASHEx_OBGetConfig+0x2a>
  else if (BootAddrConfig == OB_BOOTADDR_NS1)
 c0034f6:	2b02      	cmp	r3, #2
 c0034f8:	d102      	bne.n	c003500 <HAL_FLASHEx_OBGetConfig+0xf8>
    *BootAddr = (FLASH->NSBOOTADD1R & FLASH_NSBOOTADD1R_NSBOOTADD1);
 c0034fa:	4b04      	ldr	r3, [pc, #16]	; (c00350c <HAL_FLASHEx_OBGetConfig+0x104>)
 c0034fc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 c0034fe:	e7de      	b.n	c0034be <HAL_FLASHEx_OBGetConfig+0xb6>
  else if (BootAddrConfig == OB_BOOTADDR_SEC0)
 c003500:	2b04      	cmp	r3, #4
 c003502:	d1df      	bne.n	c0034c4 <HAL_FLASHEx_OBGetConfig+0xbc>
    *BootAddr = (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_SECBOOTADD0);
 c003504:	4b01      	ldr	r3, [pc, #4]	; (c00350c <HAL_FLASHEx_OBGetConfig+0x104>)
 c003506:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 c003508:	e7d9      	b.n	c0034be <HAL_FLASHEx_OBGetConfig+0xb6>
 c00350a:	bf00      	nop
 c00350c:	50022000 	.word	0x50022000

0c003510 <HAL_FLASHEx_ConfigPrivMode>:
  MODIFY_REG(FLASH->PRIVCFGR, FLASH_PRIVCFGR_PRIV, PrivMode);
 c003510:	4a04      	ldr	r2, [pc, #16]	; (c003524 <HAL_FLASHEx_ConfigPrivMode+0x14>)
 c003512:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 c003516:	f023 0301 	bic.w	r3, r3, #1
 c00351a:	4318      	orrs	r0, r3
 c00351c:	f8c2 00c4 	str.w	r0, [r2, #196]	; 0xc4
}
 c003520:	4770      	bx	lr
 c003522:	bf00      	nop
 c003524:	50022000 	.word	0x50022000

0c003528 <FLASH_PageErase>:
{
 c003528:	b530      	push	{r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c00352a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c00352e:	b672      	cpsid	i
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c003530:	4b13      	ldr	r3, [pc, #76]	; (c003580 <FLASH_PageErase+0x58>)
 c003532:	4a14      	ldr	r2, [pc, #80]	; (c003584 <FLASH_PageErase+0x5c>)
 c003534:	689d      	ldr	r5, [r3, #8]
 c003536:	4b14      	ldr	r3, [pc, #80]	; (c003588 <FLASH_PageErase+0x60>)
 c003538:	ea33 0325 	bics.w	r3, r3, r5, asr #32
 c00353c:	bf28      	it	cs
 c00353e:	4613      	movcs	r3, r2
  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 c003540:	4a12      	ldr	r2, [pc, #72]	; (c00358c <FLASH_PageErase+0x64>)
 c003542:	6c12      	ldr	r2, [r2, #64]	; 0x40
 c003544:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
    CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 c003548:	681a      	ldr	r2, [r3, #0]
  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 c00354a:	d113      	bne.n	c003574 <FLASH_PageErase+0x4c>
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 c00354c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 c003550:	601a      	str	r2, [r3, #0]
  MODIFY_REG((*reg), (FLASH_NSCR_NSPNB | FLASH_NSCR_NSPER), ((Page << FLASH_NSCR_NSPNB_Pos) | FLASH_NSCR_NSPER));
 c003552:	681a      	ldr	r2, [r3, #0]
 c003554:	f422 727e 	bic.w	r2, r2, #1016	; 0x3f8
 c003558:	f022 0202 	bic.w	r2, r2, #2
 c00355c:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
 c003560:	f040 0002 	orr.w	r0, r0, #2
 c003564:	6018      	str	r0, [r3, #0]
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 c003566:	681a      	ldr	r2, [r3, #0]
 c003568:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 c00356c:	601a      	str	r2, [r3, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c00356e:	f384 8810 	msr	PRIMASK, r4
}
 c003572:	bd30      	pop	{r4, r5, pc}
    if((Banks & FLASH_BANK_1) != 0U)
 c003574:	07c9      	lsls	r1, r1, #31
 c003576:	d4e9      	bmi.n	c00354c <FLASH_PageErase+0x24>
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 c003578:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 c00357c:	e7e8      	b.n	c003550 <FLASH_PageErase+0x28>
 c00357e:	bf00      	nop
 c003580:	30030060 	.word	0x30030060
 c003584:	40022028 	.word	0x40022028
 c003588:	5002202c 	.word	0x5002202c
 c00358c:	50022000 	.word	0x50022000

0c003590 <HAL_FLASHEx_Erase>:
{
 c003590:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __HAL_LOCK(&pFlash);
 c003594:	4d26      	ldr	r5, [pc, #152]	; (c003630 <HAL_FLASHEx_Erase+0xa0>)
{
 c003596:	4606      	mov	r6, r0
  __HAL_LOCK(&pFlash);
 c003598:	782b      	ldrb	r3, [r5, #0]
{
 c00359a:	4689      	mov	r9, r1
  __HAL_LOCK(&pFlash);
 c00359c:	2b01      	cmp	r3, #1
 c00359e:	d045      	beq.n	c00362c <HAL_FLASHEx_Erase+0x9c>
 c0035a0:	2301      	movs	r3, #1
 c0035a2:	702b      	strb	r3, [r5, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0035a4:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0035a6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0035aa:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0035ac:	f7ff fd54 	bl	c003058 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 c0035b0:	4604      	mov	r4, r0
 c0035b2:	b9f0      	cbnz	r0, c0035f2 <HAL_FLASHEx_Erase+0x62>
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 c0035b4:	6833      	ldr	r3, [r6, #0]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0035b6:	4a1f      	ldr	r2, [pc, #124]	; (c003634 <HAL_FLASHEx_Erase+0xa4>)
 c0035b8:	491f      	ldr	r1, [pc, #124]	; (c003638 <HAL_FLASHEx_Erase+0xa8>)
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 c0035ba:	60ab      	str	r3, [r5, #8]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0035bc:	ea31 0823 	bics.w	r8, r1, r3, asr #32
 c0035c0:	bf28      	it	cs
 c0035c2:	4690      	movcs	r8, r2
    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 c0035c4:	f248 0204 	movw	r2, #32772	; 0x8004
 c0035c8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 c0035cc:	4293      	cmp	r3, r2
 c0035ce:	d115      	bne.n	c0035fc <HAL_FLASHEx_Erase+0x6c>
      FLASH_MassErase(pEraseInit->Banks);
 c0035d0:	6870      	ldr	r0, [r6, #4]
 c0035d2:	f7ff fdb5 	bl	c003140 <FLASH_MassErase>
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0035d6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c0035da:	f7ff fd3d 	bl	c003058 <FLASH_WaitForLastOperation>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 c0035de:	4604      	mov	r4, r0
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 c0035e0:	68aa      	ldr	r2, [r5, #8]
 c0035e2:	f8d8 3000 	ldr.w	r3, [r8]
 c0035e6:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 c0035ea:	ea23 0302 	bic.w	r3, r3, r2
 c0035ee:	f8c8 3000 	str.w	r3, [r8]
  __HAL_UNLOCK(&pFlash);
 c0035f2:	2300      	movs	r3, #0
 c0035f4:	702b      	strb	r3, [r5, #0]
}
 c0035f6:	4620      	mov	r0, r4
 c0035f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      *PageError = 0xFFFFFFFFU;
 c0035fc:	f04f 33ff 	mov.w	r3, #4294967295
 c003600:	f8c9 3000 	str.w	r3, [r9]
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c003604:	68b7      	ldr	r7, [r6, #8]
 c003606:	e9d6 3202 	ldrd	r3, r2, [r6, #8]
 c00360a:	4413      	add	r3, r2
 c00360c:	42bb      	cmp	r3, r7
 c00360e:	d9e7      	bls.n	c0035e0 <HAL_FLASHEx_Erase+0x50>
        FLASH_PageErase(page_index, pEraseInit->Banks);
 c003610:	4638      	mov	r0, r7
 c003612:	6871      	ldr	r1, [r6, #4]
 c003614:	f7ff ff88 	bl	c003528 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 c003618:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c00361c:	f7ff fd1c 	bl	c003058 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 c003620:	b110      	cbz	r0, c003628 <HAL_FLASHEx_Erase+0x98>
          *PageError = page_index;
 c003622:	f8c9 7000 	str.w	r7, [r9]
 c003626:	e7da      	b.n	c0035de <HAL_FLASHEx_Erase+0x4e>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c003628:	3701      	adds	r7, #1
 c00362a:	e7ec      	b.n	c003606 <HAL_FLASHEx_Erase+0x76>
  __HAL_LOCK(&pFlash);
 c00362c:	2402      	movs	r4, #2
 c00362e:	e7e2      	b.n	c0035f6 <HAL_FLASHEx_Erase+0x66>
 c003630:	30030060 	.word	0x30030060
 c003634:	40022028 	.word	0x40022028
 c003638:	5002202c 	.word	0x5002202c

0c00363c <HAL_GPIO_Init>:
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0U;
 c00363c:	2300      	movs	r3, #0
{
 c00363e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
        EXTI->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 c003642:	4c5f      	ldr	r4, [pc, #380]	; (c0037c0 <HAL_GPIO_Init+0x184>)
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c003644:	f8df 8180 	ldr.w	r8, [pc, #384]	; c0037c8 <HAL_GPIO_Init+0x18c>
 c003648:	f8df 9180 	ldr.w	r9, [pc, #384]	; c0037cc <HAL_GPIO_Init+0x190>
  while (((GPIO_Init->Pin) >> position) != 0U)
 c00364c:	680a      	ldr	r2, [r1, #0]
 c00364e:	fa32 f503 	lsrs.w	r5, r2, r3
 c003652:	d101      	bne.n	c003658 <HAL_GPIO_Init+0x1c>
      }
    }

    position++;
  }
}
 c003654:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 c003658:	f04f 0c01 	mov.w	ip, #1
 c00365c:	fa0c fc03 	lsl.w	ip, ip, r3
    if(iocurrent != 0U)
 c003660:	ea1c 0202 	ands.w	r2, ip, r2
 c003664:	f000 809d 	beq.w	c0037a2 <HAL_GPIO_Init+0x166>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 c003668:	2603      	movs	r6, #3
 c00366a:	684d      	ldr	r5, [r1, #4]
 c00366c:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 c003670:	f025 0a10 	bic.w	sl, r5, #16
 c003674:	f10a 37ff 	add.w	r7, sl, #4294967295
 c003678:	fa06 f60e 	lsl.w	r6, r6, lr
 c00367c:	2f01      	cmp	r7, #1
 c00367e:	ea6f 0606 	mvn.w	r6, r6
 c003682:	d811      	bhi.n	c0036a8 <HAL_GPIO_Init+0x6c>
        temp = GPIOx->OSPEEDR;
 c003684:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 c003686:	ea07 0b06 	and.w	fp, r7, r6
        temp |= (GPIO_Init->Speed << (position * 2U));
 c00368a:	68cf      	ldr	r7, [r1, #12]
 c00368c:	fa07 f70e 	lsl.w	r7, r7, lr
 c003690:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
 c003694:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 c003696:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 c003698:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 c00369c:	f3c5 1700 	ubfx	r7, r5, #4, #1
 c0036a0:	409f      	lsls	r7, r3
 c0036a2:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->OTYPER = temp;
 c0036a6:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 c0036a8:	68c7      	ldr	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 c0036aa:	f1ba 0f02 	cmp.w	sl, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 c0036ae:	ea07 0c06 	and.w	ip, r7, r6
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 c0036b2:	688f      	ldr	r7, [r1, #8]
 c0036b4:	fa07 f70e 	lsl.w	r7, r7, lr
 c0036b8:	ea47 070c 	orr.w	r7, r7, ip
      GPIOx->PUPDR = temp;
 c0036bc:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 c0036be:	d116      	bne.n	c0036ee <HAL_GPIO_Init+0xb2>
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0036c0:	f04f 0c0f 	mov.w	ip, #15
        temp = GPIOx->AFR[position >> 3U];
 c0036c4:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 c0036c8:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0036cc:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 c0036d0:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0036d4:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 c0036d8:	fa0c fc0b 	lsl.w	ip, ip, fp
 c0036dc:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 c0036e0:	690f      	ldr	r7, [r1, #16]
 c0036e2:	fa07 f70b 	lsl.w	r7, r7, fp
 c0036e6:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->AFR[position >> 3U] = temp;
 c0036ea:	f8ca 7020 	str.w	r7, [sl, #32]
      temp = GPIOx->MODER;
 c0036ee:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 c0036f0:	403e      	ands	r6, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 c0036f2:	f005 0703 	and.w	r7, r5, #3
 c0036f6:	fa07 fe0e 	lsl.w	lr, r7, lr
 c0036fa:	ea4e 0606 	orr.w	r6, lr, r6
      GPIOx->MODER = temp;
 c0036fe:	6006      	str	r6, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 c003700:	00ee      	lsls	r6, r5, #3
 c003702:	d54e      	bpl.n	c0037a2 <HAL_GPIO_Init+0x166>
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 c003704:	f04f 0c0f 	mov.w	ip, #15
 c003708:	f023 0703 	bic.w	r7, r3, #3
 c00370c:	f107 47a0 	add.w	r7, r7, #1342177280	; 0x50000000
 c003710:	f507 373d 	add.w	r7, r7, #193536	; 0x2f400
 c003714:	f003 0e03 	and.w	lr, r3, #3
        temp = EXTI->EXTICR[position >> 2U];
 c003718:	6e3e      	ldr	r6, [r7, #96]	; 0x60
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 c00371a:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 c00371e:	fa0c fc0e 	lsl.w	ip, ip, lr
 c003722:	ea26 0c0c 	bic.w	ip, r6, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c003726:	4e27      	ldr	r6, [pc, #156]	; (c0037c4 <HAL_GPIO_Init+0x188>)
 c003728:	42b0      	cmp	r0, r6
 c00372a:	d03c      	beq.n	c0037a6 <HAL_GPIO_Init+0x16a>
 c00372c:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 c003730:	42b0      	cmp	r0, r6
 c003732:	d03a      	beq.n	c0037aa <HAL_GPIO_Init+0x16e>
 c003734:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 c003738:	42b0      	cmp	r0, r6
 c00373a:	d038      	beq.n	c0037ae <HAL_GPIO_Init+0x172>
 c00373c:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 c003740:	42b0      	cmp	r0, r6
 c003742:	d036      	beq.n	c0037b2 <HAL_GPIO_Init+0x176>
 c003744:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 c003748:	42b0      	cmp	r0, r6
 c00374a:	d034      	beq.n	c0037b6 <HAL_GPIO_Init+0x17a>
 c00374c:	4540      	cmp	r0, r8
 c00374e:	d034      	beq.n	c0037ba <HAL_GPIO_Init+0x17e>
 c003750:	4548      	cmp	r0, r9
 c003752:	bf0c      	ite	eq
 c003754:	2606      	moveq	r6, #6
 c003756:	2607      	movne	r6, #7
 c003758:	fa06 f60e 	lsl.w	r6, r6, lr
 c00375c:	ea46 060c 	orr.w	r6, r6, ip
        EXTI->EXTICR[position >> 2U] = temp;
 c003760:	663e      	str	r6, [r7, #96]	; 0x60
        temp &= ~(iocurrent);
 c003762:	43d7      	mvns	r7, r2
        temp = EXTI->IMR1;
 c003764:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 c003768:	f415 3f80 	tst.w	r5, #65536	; 0x10000
        temp &= ~(iocurrent);
 c00376c:	bf0c      	ite	eq
 c00376e:	403e      	andeq	r6, r7
          temp |= iocurrent;
 c003770:	4316      	orrne	r6, r2
        EXTI->IMR1 = temp;
 c003772:	f8c4 6080 	str.w	r6, [r4, #128]	; 0x80
        temp = EXTI->EMR1;
 c003776:	f8d4 6084 	ldr.w	r6, [r4, #132]	; 0x84
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 c00377a:	f415 3f00 	tst.w	r5, #131072	; 0x20000
        temp &= ~(iocurrent);
 c00377e:	bf0c      	ite	eq
 c003780:	403e      	andeq	r6, r7
          temp |= iocurrent;
 c003782:	4316      	orrne	r6, r2
        EXTI->EMR1 = temp;
 c003784:	f8c4 6084 	str.w	r6, [r4, #132]	; 0x84
        temp = EXTI->RTSR1;
 c003788:	6826      	ldr	r6, [r4, #0]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 c00378a:	f415 1f80 	tst.w	r5, #1048576	; 0x100000
        temp &= ~(iocurrent);
 c00378e:	bf0c      	ite	eq
 c003790:	403e      	andeq	r6, r7
          temp |= iocurrent;
 c003792:	4316      	orrne	r6, r2
        EXTI->RTSR1 = temp;
 c003794:	6026      	str	r6, [r4, #0]
        temp = EXTI->FTSR1;
 c003796:	6866      	ldr	r6, [r4, #4]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 c003798:	02ad      	lsls	r5, r5, #10
        temp &= ~(iocurrent);
 c00379a:	bf54      	ite	pl
 c00379c:	403e      	andpl	r6, r7
          temp |= iocurrent;
 c00379e:	4316      	orrmi	r6, r2
        EXTI->FTSR1 = temp;
 c0037a0:	6066      	str	r6, [r4, #4]
    position++;
 c0037a2:	3301      	adds	r3, #1
 c0037a4:	e752      	b.n	c00364c <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c0037a6:	2600      	movs	r6, #0
 c0037a8:	e7d6      	b.n	c003758 <HAL_GPIO_Init+0x11c>
 c0037aa:	2601      	movs	r6, #1
 c0037ac:	e7d4      	b.n	c003758 <HAL_GPIO_Init+0x11c>
 c0037ae:	2602      	movs	r6, #2
 c0037b0:	e7d2      	b.n	c003758 <HAL_GPIO_Init+0x11c>
 c0037b2:	2603      	movs	r6, #3
 c0037b4:	e7d0      	b.n	c003758 <HAL_GPIO_Init+0x11c>
 c0037b6:	2604      	movs	r6, #4
 c0037b8:	e7ce      	b.n	c003758 <HAL_GPIO_Init+0x11c>
 c0037ba:	2605      	movs	r6, #5
 c0037bc:	e7cc      	b.n	c003758 <HAL_GPIO_Init+0x11c>
 c0037be:	bf00      	nop
 c0037c0:	5002f400 	.word	0x5002f400
 c0037c4:	52020000 	.word	0x52020000
 c0037c8:	52021400 	.word	0x52021400
 c0037cc:	52021800 	.word	0x52021800

0c0037d0 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != 0U)
 c0037d0:	6903      	ldr	r3, [r0, #16]
 c0037d2:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 c0037d4:	bf14      	ite	ne
 c0037d6:	2001      	movne	r0, #1
 c0037d8:	2000      	moveq	r0, #0
 c0037da:	4770      	bx	lr

0c0037dc <HASH_WriteData>:
  *         processing is suspended when possible and the Peripheral feeding point reached at
  *         suspension time is stored in the handle for resumption later on.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_WriteData(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
 c0037dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c0037de:	4604      	mov	r4, r0
  uint32_t buffercounter;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
 c0037e0:	9101      	str	r1, [sp, #4]

  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 c0037e2:	2100      	movs	r1, #0
  {
    /* Write input data 4 bytes at a time */
    HASH->DIN = *(uint32_t*)inputaddr;
 c0037e4:	4d1c      	ldr	r5, [pc, #112]	; (c003858 <HASH_WriteData+0x7c>)
  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 c0037e6:	4291      	cmp	r1, r2
 c0037e8:	d221      	bcs.n	c00382e <HASH_WriteData+0x52>
    HASH->DIN = *(uint32_t*)inputaddr;
 c0037ea:	9b01      	ldr	r3, [sp, #4]
 c0037ec:	681b      	ldr	r3, [r3, #0]
 c0037ee:	606b      	str	r3, [r5, #4]
    inputaddr+=4U;
 c0037f0:	9b01      	ldr	r3, [sp, #4]

    /* If the suspension flag has been raised and if the processing is not about
    to end, suspend processing */
    if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter+4U) < Size))
 c0037f2:	f894 0036 	ldrb.w	r0, [r4, #54]	; 0x36
    inputaddr+=4U;
 c0037f6:	3304      	adds	r3, #4
    if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter+4U) < Size))
 c0037f8:	2801      	cmp	r0, #1
    inputaddr+=4U;
 c0037fa:	9301      	str	r3, [sp, #4]
    if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter+4U) < Size))
 c0037fc:	f101 0304 	add.w	r3, r1, #4
 c003800:	d127      	bne.n	c003852 <HASH_WriteData+0x76>
 c003802:	4293      	cmp	r3, r2
 c003804:	d225      	bcs.n	c003852 <HASH_WriteData+0x76>
    {
      /* Wait for DINIS = 1, which occurs when 16 32-bit locations are free
      in the input buffer */
      if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
 c003806:	6a6e      	ldr	r6, [r5, #36]	; 0x24
 c003808:	07f6      	lsls	r6, r6, #31
 c00380a:	d522      	bpl.n	c003852 <HASH_WriteData+0x76>
      {
        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c00380c:	2500      	movs	r5, #0

        /* Depending whether the key or the input data were fed to the Peripheral, the feeding point
        reached at suspension time is not saved in the same handle fields */
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 c00380e:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c003812:	f884 5036 	strb.w	r5, [r4, #54]	; 0x36
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 c003816:	2b02      	cmp	r3, #2
 c003818:	d001      	beq.n	c00381e <HASH_WriteData+0x42>
 c00381a:	2b04      	cmp	r3, #4
 c00381c:	d109      	bne.n	c003832 <HASH_WriteData+0x56>
        {
          /* Save current reading and writing locations of Input and Output buffers */
          hhash->pHashInBuffPtr =  (uint8_t *)inputaddr;
 c00381e:	9b01      	ldr	r3, [sp, #4]
          /* Save the number of bytes that remain to be processed at this point */
          hhash->HashInCount    =  Size - (buffercounter + 4U);
 c003820:	3a04      	subs	r2, #4
 c003822:	1a52      	subs	r2, r2, r1
          hhash->pHashInBuffPtr =  (uint8_t *)inputaddr;
 c003824:	60e3      	str	r3, [r4, #12]
          hhash->HashInCount    =  Size - (buffercounter + 4U);
 c003826:	6222      	str	r2, [r4, #32]
          __HAL_UNLOCK(hhash);
          return HAL_ERROR;
        }

        /* Set the HASH state to Suspended and exit to stop entering data */
        hhash->State = HAL_HASH_STATE_SUSPENDED;
 c003828:	2308      	movs	r3, #8
 c00382a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      } /* if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))  */
    } /* if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter+4) < Size)) */
  }   /* for(buffercounter = 0; buffercounter < Size; buffercounter+=4)                 */

  /* At this point, all the data have been entered to the Peripheral: exit */
  return  HAL_OK;
 c00382e:	2000      	movs	r0, #0
 c003830:	e00d      	b.n	c00384e <HASH_WriteData+0x72>
        else if ((hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3))
 c003832:	2b03      	cmp	r3, #3
 c003834:	d001      	beq.n	c00383a <HASH_WriteData+0x5e>
 c003836:	2b05      	cmp	r3, #5
 c003838:	d105      	bne.n	c003846 <HASH_WriteData+0x6a>
          hhash->pHashKeyBuffPtr  =  (uint8_t *)inputaddr;
 c00383a:	9b01      	ldr	r3, [sp, #4]
          hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 c00383c:	3a04      	subs	r2, #4
 c00383e:	1a52      	subs	r2, r2, r1
          hhash->pHashKeyBuffPtr  =  (uint8_t *)inputaddr;
 c003840:	6163      	str	r3, [r4, #20]
          hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 c003842:	62a2      	str	r2, [r4, #40]	; 0x28
 c003844:	e7f0      	b.n	c003828 <HASH_WriteData+0x4c>
          hhash->State = HAL_HASH_STATE_READY;
 c003846:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
          __HAL_UNLOCK(hhash);
 c00384a:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
}
 c00384e:	b002      	add	sp, #8
 c003850:	bd70      	pop	{r4, r5, r6, pc}
{
 c003852:	4619      	mov	r1, r3
 c003854:	e7c7      	b.n	c0037e6 <HASH_WriteData+0xa>
 c003856:	bf00      	nop
 c003858:	520c0400 	.word	0x520c0400

0c00385c <HASH_GetDigest>:
  */
static void HASH_GetDigest(uint8_t *pMsgDigest, uint8_t Size)
{
  uint32_t msgdigest = (uint32_t)pMsgDigest;

  switch(Size)
 c00385c:	291c      	cmp	r1, #28
 c00385e:	d027      	beq.n	c0038b0 <HASH_GetDigest+0x54>
 c003860:	d804      	bhi.n	c00386c <HASH_GetDigest+0x10>
 c003862:	2910      	cmp	r1, #16
 c003864:	d005      	beq.n	c003872 <HASH_GetDigest+0x16>
 c003866:	2914      	cmp	r1, #20
 c003868:	d011      	beq.n	c00388e <HASH_GetDigest+0x32>
 c00386a:	4770      	bx	lr
 c00386c:	2920      	cmp	r1, #32
 c00386e:	d037      	beq.n	c0038e0 <HASH_GetDigest+0x84>
 c003870:	4770      	bx	lr
  {
    /* Read the message digest */
    case 16:  /* MD5 */
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c003872:	4b29      	ldr	r3, [pc, #164]	; (c003918 <HASH_GetDigest+0xbc>)
 c003874:	68da      	ldr	r2, [r3, #12]
  \return               Reversed value
 */
__STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
{
#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
  return __builtin_bswap32(value);
 c003876:	ba12      	rev	r2, r2
 c003878:	6002      	str	r2, [r0, #0]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c00387a:	691a      	ldr	r2, [r3, #16]
 c00387c:	ba12      	rev	r2, r2
 c00387e:	6042      	str	r2, [r0, #4]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c003880:	695a      	ldr	r2, [r3, #20]
 c003882:	ba12      	rev	r2, r2
 c003884:	6082      	str	r2, [r0, #8]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c003886:	699b      	ldr	r3, [r3, #24]
 c003888:	ba1b      	rev	r3, r3
 c00388a:	60c3      	str	r3, [r0, #12]
    break;
 c00388c:	4770      	bx	lr
    case 20:  /* SHA1 */
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c00388e:	4b22      	ldr	r3, [pc, #136]	; (c003918 <HASH_GetDigest+0xbc>)
 c003890:	68da      	ldr	r2, [r3, #12]
 c003892:	ba12      	rev	r2, r2
 c003894:	6002      	str	r2, [r0, #0]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c003896:	691a      	ldr	r2, [r3, #16]
 c003898:	ba12      	rev	r2, r2
 c00389a:	6042      	str	r2, [r0, #4]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c00389c:	695a      	ldr	r2, [r3, #20]
 c00389e:	ba12      	rev	r2, r2
 c0038a0:	6082      	str	r2, [r0, #8]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c0038a2:	699a      	ldr	r2, [r3, #24]
 c0038a4:	ba12      	rev	r2, r2
 c0038a6:	60c2      	str	r2, [r0, #12]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c0038a8:	69db      	ldr	r3, [r3, #28]
 c0038aa:	ba1b      	rev	r3, r3
 c0038ac:	6103      	str	r3, [r0, #16]
    break;
 c0038ae:	4770      	bx	lr
  case 28:  /* SHA224 */
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c0038b0:	4b19      	ldr	r3, [pc, #100]	; (c003918 <HASH_GetDigest+0xbc>)
 c0038b2:	68da      	ldr	r2, [r3, #12]
 c0038b4:	ba12      	rev	r2, r2
 c0038b6:	6002      	str	r2, [r0, #0]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c0038b8:	691a      	ldr	r2, [r3, #16]
 c0038ba:	ba12      	rev	r2, r2
 c0038bc:	6042      	str	r2, [r0, #4]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c0038be:	695a      	ldr	r2, [r3, #20]
 c0038c0:	ba12      	rev	r2, r2
 c0038c2:	6082      	str	r2, [r0, #8]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c0038c4:	699a      	ldr	r2, [r3, #24]
 c0038c6:	ba12      	rev	r2, r2
 c0038c8:	60c2      	str	r2, [r0, #12]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c0038ca:	69db      	ldr	r3, [r3, #28]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c0038cc:	4a13      	ldr	r2, [pc, #76]	; (c00391c <HASH_GetDigest+0xc0>)
 c0038ce:	ba1b      	rev	r3, r3
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c0038d0:	6103      	str	r3, [r0, #16]
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c0038d2:	6953      	ldr	r3, [r2, #20]
 c0038d4:	ba1b      	rev	r3, r3
 c0038d6:	6143      	str	r3, [r0, #20]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 c0038d8:	6993      	ldr	r3, [r2, #24]
 c0038da:	ba1b      	rev	r3, r3
 c0038dc:	6183      	str	r3, [r0, #24]
    break;
 c0038de:	4770      	bx	lr
  case 32:   /* SHA256 */
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c0038e0:	4b0d      	ldr	r3, [pc, #52]	; (c003918 <HASH_GetDigest+0xbc>)
 c0038e2:	68da      	ldr	r2, [r3, #12]
 c0038e4:	ba12      	rev	r2, r2
 c0038e6:	6002      	str	r2, [r0, #0]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c0038e8:	691a      	ldr	r2, [r3, #16]
 c0038ea:	ba12      	rev	r2, r2
 c0038ec:	6042      	str	r2, [r0, #4]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c0038ee:	695a      	ldr	r2, [r3, #20]
 c0038f0:	ba12      	rev	r2, r2
 c0038f2:	6082      	str	r2, [r0, #8]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c0038f4:	699a      	ldr	r2, [r3, #24]
 c0038f6:	ba12      	rev	r2, r2
 c0038f8:	60c2      	str	r2, [r0, #12]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c0038fa:	69db      	ldr	r3, [r3, #28]
 c0038fc:	ba1b      	rev	r3, r3
 c0038fe:	6103      	str	r3, [r0, #16]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c003900:	4b06      	ldr	r3, [pc, #24]	; (c00391c <HASH_GetDigest+0xc0>)
 c003902:	695a      	ldr	r2, [r3, #20]
 c003904:	ba12      	rev	r2, r2
 c003906:	6142      	str	r2, [r0, #20]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 c003908:	699a      	ldr	r2, [r3, #24]
 c00390a:	ba12      	rev	r2, r2
 c00390c:	6182      	str	r2, [r0, #24]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[7]);
 c00390e:	69db      	ldr	r3, [r3, #28]
 c003910:	ba1b      	rev	r3, r3
 c003912:	61c3      	str	r3, [r0, #28]
    break;
    default:
    break;
  }
}
 c003914:	4770      	bx	lr
 c003916:	bf00      	nop
 c003918:	520c0400 	.word	0x520c0400
 c00391c:	520c0710 	.word	0x520c0710

0c003920 <HASH_WaitOnFlagUntilTimeout>:
  * @param  Status the Flag status (SET or RESET).
  * @param  Timeout Timeout duration.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_WaitOnFlagUntilTimeout(HASH_HandleTypeDef *hhash, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
{
 c003920:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c003924:	4604      	mov	r4, r0
 c003926:	460e      	mov	r6, r1
 c003928:	4691      	mov	r9, r2
 c00392a:	461d      	mov	r5, r3
  uint32_t tickstart = HAL_GetTick();
 c00392c:	f7fe fbec 	bl	c002108 <HAL_GetTick>
 c003930:	f8df 805c 	ldr.w	r8, [pc, #92]	; c003990 <HASH_WaitOnFlagUntilTimeout+0x70>
 c003934:	4607      	mov	r7, r0

  /* Wait until flag is set */
  if(Status == RESET)
 c003936:	f1b9 0f00 	cmp.w	r9, #0
 c00393a:	d021      	beq.n	c003980 <HASH_WaitOnFlagUntilTimeout+0x60>
      }
    }
  }
  else
  {
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
 c00393c:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 c003940:	ea36 0303 	bics.w	r3, r6, r3
 c003944:	d121      	bne.n	c00398a <HASH_WaitOnFlagUntilTimeout+0x6a>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 c003946:	1c6b      	adds	r3, r5, #1
 c003948:	d0f8      	beq.n	c00393c <HASH_WaitOnFlagUntilTimeout+0x1c>
      {
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 c00394a:	f7fe fbdd 	bl	c002108 <HAL_GetTick>
 c00394e:	1bc0      	subs	r0, r0, r7
 c003950:	42a8      	cmp	r0, r5
 c003952:	d80a      	bhi.n	c00396a <HASH_WaitOnFlagUntilTimeout+0x4a>
 c003954:	2d00      	cmp	r5, #0
 c003956:	d1f1      	bne.n	c00393c <HASH_WaitOnFlagUntilTimeout+0x1c>
 c003958:	e007      	b.n	c00396a <HASH_WaitOnFlagUntilTimeout+0x4a>
      if(Timeout != HAL_MAX_DELAY)
 c00395a:	1c6a      	adds	r2, r5, #1
 c00395c:	d010      	beq.n	c003980 <HASH_WaitOnFlagUntilTimeout+0x60>
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 c00395e:	f7fe fbd3 	bl	c002108 <HAL_GetTick>
 c003962:	1bc0      	subs	r0, r0, r7
 c003964:	42a8      	cmp	r0, r5
 c003966:	d800      	bhi.n	c00396a <HASH_WaitOnFlagUntilTimeout+0x4a>
 c003968:	b955      	cbnz	r5, c003980 <HASH_WaitOnFlagUntilTimeout+0x60>
        {
          /* Set State to Ready to be able to restart later on */
          hhash->State  = HAL_HASH_STATE_READY;
 c00396a:	2301      	movs	r3, #1
          /* Store time out issue in handle status */
          hhash->Status = HAL_TIMEOUT;

          /* Process Unlocked */
          __HAL_UNLOCK(hhash);
 c00396c:	2200      	movs	r2, #0
          hhash->State  = HAL_HASH_STATE_READY;
 c00396e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
          hhash->Status = HAL_TIMEOUT;
 c003972:	2303      	movs	r3, #3
          __HAL_UNLOCK(hhash);
 c003974:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34

          return HAL_TIMEOUT;
 c003978:	4618      	mov	r0, r3
          hhash->Status = HAL_TIMEOUT;
 c00397a:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
          return HAL_TIMEOUT;
 c00397e:	e005      	b.n	c00398c <HASH_WaitOnFlagUntilTimeout+0x6c>
    while(__HAL_HASH_GET_FLAG(Flag) == RESET)
 c003980:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 c003984:	ea36 0303 	bics.w	r3, r6, r3
 c003988:	d1e7      	bne.n	c00395a <HASH_WaitOnFlagUntilTimeout+0x3a>
        }
      }
    }
  }
  return HAL_OK;
 c00398a:	2000      	movs	r0, #0
}
 c00398c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c003990:	520c0400 	.word	0x520c0400

0c003994 <HAL_HASH_MspInit>:
}
 c003994:	4770      	bx	lr
	...

0c003998 <HAL_HASH_Init>:
{
 c003998:	b538      	push	{r3, r4, r5, lr}
  if(hhash == NULL)
 c00399a:	4604      	mov	r4, r0
 c00399c:	b328      	cbz	r0, c0039ea <HAL_HASH_Init+0x52>
  if(hhash->State == HAL_HASH_STATE_RESET)
 c00399e:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 c0039a2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 c0039a6:	b91b      	cbnz	r3, c0039b0 <HAL_HASH_Init+0x18>
    hhash->Lock = HAL_UNLOCKED;
 c0039a8:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
    HAL_HASH_MspInit(hhash);
 c0039ac:	f7ff fff2 	bl	c003994 <HAL_HASH_MspInit>
  hhash->HashInCount = 0;
 c0039b0:	2000      	movs	r0, #0
  hhash->State = HAL_HASH_STATE_BUSY;
 c0039b2:	2302      	movs	r3, #2
  hhash->Phase = HAL_HASH_PHASE_READY;
 c0039b4:	2101      	movs	r1, #1
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 c0039b6:	4a0e      	ldr	r2, [pc, #56]	; (c0039f0 <HAL_HASH_Init+0x58>)
  hhash->State = HAL_HASH_STATE_BUSY;
 c0039b8:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  hhash->HashBuffSize = 0;
 c0039bc:	61e0      	str	r0, [r4, #28]
  hhash->HashInCount = 0;
 c0039be:	6220      	str	r0, [r4, #32]
  hhash->Phase = HAL_HASH_PHASE_READY;
 c0039c0:	f884 102d 	strb.w	r1, [r4, #45]	; 0x2d
  hhash->HashITCounter = 0;
 c0039c4:	6260      	str	r0, [r4, #36]	; 0x24
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c0039c6:	86e0      	strh	r0, [r4, #54]	; 0x36
  hhash->NbWordsAlreadyPushed = 0;
 c0039c8:	63a0      	str	r0, [r4, #56]	; 0x38
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 c0039ca:	6813      	ldr	r3, [r2, #0]
 c0039cc:	6825      	ldr	r5, [r4, #0]
 c0039ce:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 c0039d2:	432b      	orrs	r3, r5
 c0039d4:	6013      	str	r3, [r2, #0]
__HAL_HASH_RESET_MDMAT();
 c0039d6:	6813      	ldr	r3, [r2, #0]
 c0039d8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 c0039dc:	6013      	str	r3, [r2, #0]
  hhash->State = HAL_HASH_STATE_READY;
 c0039de:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
  hhash->Status = HAL_OK;
 c0039e2:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;
 c0039e6:	63e0      	str	r0, [r4, #60]	; 0x3c
}
 c0039e8:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 c0039ea:	2001      	movs	r0, #1
 c0039ec:	e7fc      	b.n	c0039e8 <HAL_HASH_Init+0x50>
 c0039ee:	bf00      	nop
 c0039f0:	520c0400 	.word	0x520c0400

0c0039f4 <HAL_HASH_MspDeInit>:
 c0039f4:	4770      	bx	lr

0c0039f6 <HAL_HASH_DeInit>:
{
 c0039f6:	b538      	push	{r3, r4, r5, lr}
  if(hhash == NULL)
 c0039f8:	4605      	mov	r5, r0
 c0039fa:	2401      	movs	r4, #1
 c0039fc:	b190      	cbz	r0, c003a24 <HAL_HASH_DeInit+0x2e>
  hhash->State = HAL_HASH_STATE_BUSY;
 c0039fe:	2302      	movs	r3, #2
  hhash->Phase = HAL_HASH_PHASE_READY;
 c003a00:	f880 402d 	strb.w	r4, [r0, #45]	; 0x2d
  hhash->HashInCount = 0;
 c003a04:	2400      	movs	r4, #0
  hhash->State = HAL_HASH_STATE_BUSY;
 c003a06:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  hhash->HashBuffSize = 0;
 c003a0a:	61c4      	str	r4, [r0, #28]
  hhash->HashInCount = 0;
 c003a0c:	6204      	str	r4, [r0, #32]
  hhash->DigestCalculationDisable = RESET;
 c003a0e:	f880 4037 	strb.w	r4, [r0, #55]	; 0x37
  hhash->HashITCounter = 0;
 c003a12:	6244      	str	r4, [r0, #36]	; 0x24
  HAL_HASH_MspDeInit(hhash);
 c003a14:	f7ff ffee 	bl	c0039f4 <HAL_HASH_MspDeInit>
  hhash->State = HAL_HASH_STATE_RESET;
 c003a18:	f885 4035 	strb.w	r4, [r5, #53]	; 0x35
  hhash->Status = HAL_OK;
 c003a1c:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;
 c003a20:	63ec      	str	r4, [r5, #60]	; 0x3c
  hhash->Accumulation = 0U;
 c003a22:	642c      	str	r4, [r5, #64]	; 0x40
    return HAL_ERROR;
 c003a24:	4620      	mov	r0, r4
}
 c003a26:	bd38      	pop	{r3, r4, r5, pc}

0c003a28 <HASH_Start>:
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 c003a28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c003a2a:	461e      	mov	r6, r3
  uint8_t *pInBuffer_tmp;  /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp; /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c003a2c:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
{
 c003a30:	4604      	mov	r4, r0


  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 c003a32:	2b01      	cmp	r3, #1
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c003a34:	b2d8      	uxtb	r0, r3
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 c003a36:	d001      	beq.n	c003a3c <HASH_Start+0x14>
 c003a38:	2808      	cmp	r0, #8
 c003a3a:	d17b      	bne.n	c003b34 <HASH_Start+0x10c>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (pOutBuffer == NULL))
 c003a3c:	b101      	cbz	r1, c003a40 <HASH_Start+0x18>
 c003a3e:	b926      	cbnz	r6, c003a4a <HASH_Start+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 c003a40:	2501      	movs	r5, #1
 c003a42:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
  }
  else
  {
    return HAL_BUSY;
  }
}
 c003a46:	4628      	mov	r0, r5
 c003a48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hhash);
 c003a4a:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 c003a4e:	2b01      	cmp	r3, #1
 c003a50:	d070      	beq.n	c003b34 <HASH_Start+0x10c>
 c003a52:	2501      	movs	r5, #1
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 c003a54:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
    __HAL_LOCK(hhash);
 c003a58:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 c003a5c:	42ab      	cmp	r3, r5
 c003a5e:	d147      	bne.n	c003af0 <HASH_Start+0xc8>
      hhash->State = HAL_HASH_STATE_BUSY;
 c003a60:	2702      	movs	r7, #2
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c003a62:	4d36      	ldr	r5, [pc, #216]	; (c003b3c <HASH_Start+0x114>)
      hhash->State = HAL_HASH_STATE_BUSY;
 c003a64:	f884 7035 	strb.w	r7, [r4, #53]	; 0x35
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c003a68:	6828      	ldr	r0, [r5, #0]
 c003a6a:	9b07      	ldr	r3, [sp, #28]
 c003a6c:	f420 20a0 	bic.w	r0, r0, #327680	; 0x50000
 c003a70:	f020 00c4 	bic.w	r0, r0, #196	; 0xc4
 c003a74:	4318      	orrs	r0, r3
 c003a76:	f040 0004 	orr.w	r0, r0, #4
 c003a7a:	6028      	str	r0, [r5, #0]
      __HAL_HASH_SET_NBVALIDBITS(Size);
 c003a7c:	68a8      	ldr	r0, [r5, #8]
 c003a7e:	f002 0303 	and.w	r3, r2, #3
 c003a82:	f020 001f 	bic.w	r0, r0, #31
 c003a86:	ea40 03c3 	orr.w	r3, r0, r3, lsl #3
 c003a8a:	60ab      	str	r3, [r5, #8]
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 c003a8c:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 c003a90:	4620      	mov	r0, r4
 c003a92:	f7ff fea3 	bl	c0037dc <HASH_WriteData>
 c003a96:	4605      	mov	r5, r0
 c003a98:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 c003a9c:	2800      	cmp	r0, #0
 c003a9e:	d1d2      	bne.n	c003a46 <HASH_Start+0x1e>
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 c003aa0:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 c003aa4:	2b08      	cmp	r3, #8
 c003aa6:	d03d      	beq.n	c003b24 <HASH_Start+0xfc>
      __HAL_HASH_START_DIGEST();
 c003aa8:	4f24      	ldr	r7, [pc, #144]	; (c003b3c <HASH_Start+0x114>)
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c003aaa:	4602      	mov	r2, r0
      __HAL_HASH_START_DIGEST();
 c003aac:	68bb      	ldr	r3, [r7, #8]
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c003aae:	2102      	movs	r1, #2
      __HAL_HASH_START_DIGEST();
 c003ab0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 c003ab4:	60bb      	str	r3, [r7, #8]
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c003ab6:	4620      	mov	r0, r4
 c003ab8:	9b06      	ldr	r3, [sp, #24]
 c003aba:	f7ff ff31 	bl	c003920 <HASH_WaitOnFlagUntilTimeout>
 c003abe:	2800      	cmp	r0, #0
 c003ac0:	d13a      	bne.n	c003b38 <HASH_Start+0x110>
      HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 c003ac2:	683a      	ldr	r2, [r7, #0]
 c003ac4:	4b1e      	ldr	r3, [pc, #120]	; (c003b40 <HASH_Start+0x118>)
 c003ac6:	421a      	tst	r2, r3
 c003ac8:	d030      	beq.n	c003b2c <HASH_Start+0x104>
 c003aca:	683a      	ldr	r2, [r7, #0]
 c003acc:	401a      	ands	r2, r3
 c003ace:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 c003ad2:	d02d      	beq.n	c003b30 <HASH_Start+0x108>
 c003ad4:	683a      	ldr	r2, [r7, #0]
 c003ad6:	4393      	bics	r3, r2
 c003ad8:	bf0c      	ite	eq
 c003ada:	2120      	moveq	r1, #32
 c003adc:	2110      	movne	r1, #16
 c003ade:	4630      	mov	r0, r6
 c003ae0:	f7ff febc 	bl	c00385c <HASH_GetDigest>
      hhash->State = HAL_HASH_STATE_READY;
 c003ae4:	2301      	movs	r3, #1
 c003ae6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      hhash->Phase = HAL_HASH_PHASE_READY;
 c003aea:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
 c003aee:	e019      	b.n	c003b24 <HASH_Start+0xfc>
    else if (hhash->Phase == HAL_HASH_PHASE_PROCESS)
 c003af0:	2b02      	cmp	r3, #2
 c003af2:	d115      	bne.n	c003b20 <HASH_Start+0xf8>
      if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c003af4:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 c003af8:	2b08      	cmp	r3, #8
        __HAL_HASH_SET_NBVALIDBITS(Size);
 c003afa:	bf1d      	ittte	ne
 c003afc:	4d0f      	ldrne	r5, [pc, #60]	; (c003b3c <HASH_Start+0x114>)
 c003afe:	f002 0303 	andne.w	r3, r2, #3
 c003b02:	68a8      	ldrne	r0, [r5, #8]
        Size_tmp = hhash->HashInCount;
 c003b04:	6a22      	ldreq	r2, [r4, #32]
        __HAL_HASH_SET_NBVALIDBITS(Size);
 c003b06:	bf1e      	ittt	ne
 c003b08:	f020 001f 	bicne.w	r0, r0, #31
 c003b0c:	ea40 03c3 	orrne.w	r3, r0, r3, lsl #3
 c003b10:	60ab      	strne	r3, [r5, #8]
      hhash->State = HAL_HASH_STATE_BUSY;
 c003b12:	f04f 0302 	mov.w	r3, #2
        pInBuffer_tmp = hhash->pHashInBuffPtr;
 c003b16:	bf08      	it	eq
 c003b18:	68e1      	ldreq	r1, [r4, #12]
      hhash->State = HAL_HASH_STATE_BUSY;
 c003b1a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 c003b1e:	e7b7      	b.n	c003a90 <HASH_Start+0x68>
      hhash->State = HAL_HASH_STATE_READY;
 c003b20:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
    __HAL_UNLOCK(hhash);
 c003b24:	2300      	movs	r3, #0
 c003b26:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return HAL_OK;
 c003b2a:	e78c      	b.n	c003a46 <HASH_Start+0x1e>
      HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 c003b2c:	2114      	movs	r1, #20
 c003b2e:	e7d6      	b.n	c003ade <HASH_Start+0xb6>
 c003b30:	211c      	movs	r1, #28
 c003b32:	e7d4      	b.n	c003ade <HASH_Start+0xb6>
    return HAL_BUSY;
 c003b34:	2502      	movs	r5, #2
 c003b36:	e786      	b.n	c003a46 <HASH_Start+0x1e>
        return HAL_TIMEOUT;
 c003b38:	2503      	movs	r5, #3
 c003b3a:	e784      	b.n	c003a46 <HASH_Start+0x1e>
 c003b3c:	520c0400 	.word	0x520c0400
 c003b40:	00040080 	.word	0x00040080

0c003b44 <HASH_Accumulate>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
 c003b44:	b570      	push	{r4, r5, r6, lr}
  uint8_t *pInBuffer_tmp;   /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp;  /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c003b46:	f890 5035 	ldrb.w	r5, [r0, #53]	; 0x35
{
 c003b4a:	4604      	mov	r4, r0

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 c003b4c:	0790      	lsls	r0, r2, #30
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c003b4e:	b2ed      	uxtb	r5, r5
  if ((Size % 4U) != 0U)
 c003b50:	d13e      	bne.n	c003bd0 <HASH_Accumulate+0x8c>
  {
    return  HAL_ERROR;
  }

  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 c003b52:	2d01      	cmp	r5, #1
 c003b54:	d001      	beq.n	c003b5a <HASH_Accumulate+0x16>
 c003b56:	2d08      	cmp	r5, #8
 c003b58:	d13c      	bne.n	c003bd4 <HASH_Accumulate+0x90>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (Size == 0U))
 c003b5a:	b101      	cbz	r1, c003b5e <HASH_Accumulate+0x1a>
 c003b5c:	b91a      	cbnz	r2, c003b66 <HASH_Accumulate+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 c003b5e:	2001      	movs	r0, #1
 c003b60:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
  {
    return HAL_BUSY;
  }


}
 c003b64:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_LOCK(hhash);
 c003b66:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 c003b6a:	2801      	cmp	r0, #1
 c003b6c:	d032      	beq.n	c003bd4 <HASH_Accumulate+0x90>
 c003b6e:	2001      	movs	r0, #1
 c003b70:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c003b74:	f894 0035 	ldrb.w	r0, [r4, #53]	; 0x35
 c003b78:	2808      	cmp	r0, #8
 c003b7a:	f04f 0002 	mov.w	r0, #2
      hhash->State = HAL_HASH_STATE_BUSY;
 c003b7e:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c003b82:	d113      	bne.n	c003bac <HASH_Accumulate+0x68>
      pInBuffer_tmp = hhash->pHashInBuffPtr;  /* pInBuffer_tmp is set to the input data address */
 c003b84:	68e1      	ldr	r1, [r4, #12]
      Size_tmp = hhash->HashInCount;          /* Size_tmp contains the input data size in bytes */
 c003b86:	6a22      	ldr	r2, [r4, #32]
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 c003b88:	4620      	mov	r0, r4
 c003b8a:	f7ff fe27 	bl	c0037dc <HASH_WriteData>
 c003b8e:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 c003b92:	2800      	cmp	r0, #0
 c003b94:	d1e6      	bne.n	c003b64 <HASH_Accumulate+0x20>
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 c003b96:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 c003b9a:	2b08      	cmp	r3, #8
      hhash->State = HAL_HASH_STATE_READY;
 c003b9c:	bf1c      	itt	ne
 c003b9e:	2301      	movne	r3, #1
 c003ba0:	f884 3035 	strbne.w	r3, [r4, #53]	; 0x35
    __HAL_UNLOCK(hhash);
 c003ba4:	2300      	movs	r3, #0
 c003ba6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return HAL_OK;
 c003baa:	e7db      	b.n	c003b64 <HASH_Accumulate+0x20>
      if(hhash->Phase == HAL_HASH_PHASE_READY)
 c003bac:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
 c003bb0:	2801      	cmp	r0, #1
 c003bb2:	d109      	bne.n	c003bc8 <HASH_Accumulate+0x84>
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c003bb4:	4e08      	ldr	r6, [pc, #32]	; (c003bd8 <HASH_Accumulate+0x94>)
 c003bb6:	6830      	ldr	r0, [r6, #0]
 c003bb8:	f420 20a0 	bic.w	r0, r0, #327680	; 0x50000
 c003bbc:	f020 00c4 	bic.w	r0, r0, #196	; 0xc4
 c003bc0:	4303      	orrs	r3, r0
 c003bc2:	f043 0304 	orr.w	r3, r3, #4
 c003bc6:	6033      	str	r3, [r6, #0]
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 c003bc8:	2302      	movs	r3, #2
 c003bca:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
 c003bce:	e7db      	b.n	c003b88 <HASH_Accumulate+0x44>
    return  HAL_ERROR;
 c003bd0:	2001      	movs	r0, #1
 c003bd2:	e7c7      	b.n	c003b64 <HASH_Accumulate+0x20>
    return HAL_BUSY;
 c003bd4:	2002      	movs	r0, #2
 c003bd6:	e7c5      	b.n	c003b64 <HASH_Accumulate+0x20>
 c003bd8:	520c0400 	.word	0x520c0400

0c003bdc <HAL_HASHEx_SHA224_Start>:
  * @param  pOutBuffer pointer to the computed digest. Digest size is 28 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA224_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 c003bdc:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA224);
 c003bde:	f44f 2480 	mov.w	r4, #262144	; 0x40000
 c003be2:	9401      	str	r4, [sp, #4]
 c003be4:	9c04      	ldr	r4, [sp, #16]
 c003be6:	9400      	str	r4, [sp, #0]
 c003be8:	f7ff ff1e 	bl	c003a28 <HASH_Start>
}
 c003bec:	b002      	add	sp, #8
 c003bee:	bd10      	pop	{r4, pc}

0c003bf0 <HAL_HASHEx_SHA224_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA224_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA224);
 c003bf0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 c003bf4:	f7ff bfa6 	b.w	c003b44 <HASH_Accumulate>

0c003bf8 <HAL_HASHEx_SHA224_Accmlt_End>:
 c003bf8:	f7ff bff0 	b.w	c003bdc <HAL_HASHEx_SHA224_Start>

0c003bfc <HAL_HASHEx_SHA256_Start>:
  * @param  pOutBuffer pointer to the computed digest. Digest size is 32 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA256_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 c003bfc:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA256);
 c003bfe:	4c04      	ldr	r4, [pc, #16]	; (c003c10 <HAL_HASHEx_SHA256_Start+0x14>)
 c003c00:	9401      	str	r4, [sp, #4]
 c003c02:	9c04      	ldr	r4, [sp, #16]
 c003c04:	9400      	str	r4, [sp, #0]
 c003c06:	f7ff ff0f 	bl	c003a28 <HASH_Start>
}
 c003c0a:	b002      	add	sp, #8
 c003c0c:	bd10      	pop	{r4, pc}
 c003c0e:	bf00      	nop
 c003c10:	00040080 	.word	0x00040080

0c003c14 <HAL_HASHEx_SHA256_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA256_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA256);
 c003c14:	4b01      	ldr	r3, [pc, #4]	; (c003c1c <HAL_HASHEx_SHA256_Accmlt+0x8>)
 c003c16:	f7ff bf95 	b.w	c003b44 <HASH_Accumulate>
 c003c1a:	bf00      	nop
 c003c1c:	00040080 	.word	0x00040080

0c003c20 <HAL_HASHEx_SHA256_Accmlt_End>:
 c003c20:	f7ff bfec 	b.w	c003bfc <HAL_HASHEx_SHA256_Start>

0c003c24 <HAL_ICACHE_Enable>:
  *         cache operation completes.
  * @retval HAL status (HAL_OK)
  */
HAL_StatusTypeDef HAL_ICACHE_Enable(void)
{
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 c003c24:	4a03      	ldr	r2, [pc, #12]	; (c003c34 <HAL_ICACHE_Enable+0x10>)

  return HAL_OK;
}
 c003c26:	2000      	movs	r0, #0
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 c003c28:	6813      	ldr	r3, [r2, #0]
 c003c2a:	f043 0301 	orr.w	r3, r3, #1
 c003c2e:	6013      	str	r3, [r2, #0]
}
 c003c30:	4770      	bx	lr
 c003c32:	bf00      	nop
 c003c34:	50030400 	.word	0x50030400

0c003c38 <HAL_ICACHE_WaitForInvalidateComplete>:
  * @brief Wait for the end of the Instruction Cache invalidate procedure.
  * @note This function checks and clears the BSYENDF flag when set.
  * @retval HAL status (HAL_OK/HAL_TIMEOUT)
  */
HAL_StatusTypeDef HAL_ICACHE_WaitForInvalidateComplete(void)
{
 c003c38:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tickstart;

  /* Check if ongoing invalidation operation */
  if (READ_BIT(ICACHE->SR, ICACHE_SR_BUSYF) != 0U)
 c003c3a:	4c0c      	ldr	r4, [pc, #48]	; (c003c6c <HAL_ICACHE_WaitForInvalidateComplete+0x34>)
 c003c3c:	6863      	ldr	r3, [r4, #4]
 c003c3e:	07d9      	lsls	r1, r3, #31
 c003c40:	d404      	bmi.n	c003c4c <HAL_ICACHE_WaitForInvalidateComplete+0x14>
  HAL_StatusTypeDef status = HAL_OK;
 c003c42:	2000      	movs	r0, #0
      }
    }
  }

  /* Clear BSYENDF */
  WRITE_REG(ICACHE->FCR, ICACHE_FCR_CBSYENDF);
 c003c44:	2202      	movs	r2, #2
 c003c46:	4b09      	ldr	r3, [pc, #36]	; (c003c6c <HAL_ICACHE_WaitForInvalidateComplete+0x34>)
 c003c48:	60da      	str	r2, [r3, #12]

  return status;
}
 c003c4a:	bd38      	pop	{r3, r4, r5, pc}
    tickstart = HAL_GetTick();
 c003c4c:	f7fe fa5c 	bl	c002108 <HAL_GetTick>
 c003c50:	4605      	mov	r5, r0
    while (READ_BIT(ICACHE->SR, ICACHE_SR_BSYENDF) == 0U)
 c003c52:	6863      	ldr	r3, [r4, #4]
 c003c54:	079b      	lsls	r3, r3, #30
 c003c56:	d4f4      	bmi.n	c003c42 <HAL_ICACHE_WaitForInvalidateComplete+0xa>
      if ((HAL_GetTick() - tickstart) > ICACHE_INVALIDATE_TIMEOUT_VALUE)
 c003c58:	f7fe fa56 	bl	c002108 <HAL_GetTick>
 c003c5c:	1b40      	subs	r0, r0, r5
 c003c5e:	2801      	cmp	r0, #1
 c003c60:	d9f7      	bls.n	c003c52 <HAL_ICACHE_WaitForInvalidateComplete+0x1a>
        if (READ_BIT(ICACHE->SR, ICACHE_SR_BSYENDF) == 0U)
 c003c62:	6863      	ldr	r3, [r4, #4]
 c003c64:	079a      	lsls	r2, r3, #30
 c003c66:	d4f4      	bmi.n	c003c52 <HAL_ICACHE_WaitForInvalidateComplete+0x1a>
          status = HAL_TIMEOUT;
 c003c68:	2003      	movs	r0, #3
 c003c6a:	e7eb      	b.n	c003c44 <HAL_ICACHE_WaitForInvalidateComplete+0xc>
 c003c6c:	50030400 	.word	0x50030400

0c003c70 <HAL_ICACHE_Invalidate>:
  if (READ_BIT(ICACHE->SR, ICACHE_SR_BUSYF) != 0U)
 c003c70:	4b07      	ldr	r3, [pc, #28]	; (c003c90 <HAL_ICACHE_Invalidate+0x20>)
 c003c72:	685a      	ldr	r2, [r3, #4]
 c003c74:	07d2      	lsls	r2, r2, #31
 c003c76:	d409      	bmi.n	c003c8c <HAL_ICACHE_Invalidate+0x1c>
    CLEAR_BIT(ICACHE->FCR, ICACHE_FCR_CBSYENDF);
 c003c78:	68da      	ldr	r2, [r3, #12]
 c003c7a:	f022 0202 	bic.w	r2, r2, #2
 c003c7e:	60da      	str	r2, [r3, #12]
    SET_BIT(ICACHE->CR, ICACHE_CR_CACHEINV);
 c003c80:	681a      	ldr	r2, [r3, #0]
 c003c82:	f042 0202 	orr.w	r2, r2, #2
 c003c86:	601a      	str	r2, [r3, #0]
    status = HAL_ICACHE_WaitForInvalidateComplete();
 c003c88:	f7ff bfd6 	b.w	c003c38 <HAL_ICACHE_WaitForInvalidateComplete>
}
 c003c8c:	2001      	movs	r0, #1
 c003c8e:	4770      	bx	lr
 c003c90:	50030400 	.word	0x50030400

0c003c94 <HAL_PWREx_EnableVddIO2>:
  * @note  Remove VDDIO2 electrical and logical isolation, once VDDIO2 supply is present.
  * @retval None
  */
void HAL_PWREx_EnableVddIO2(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_IOSV);
 c003c94:	4a02      	ldr	r2, [pc, #8]	; (c003ca0 <HAL_PWREx_EnableVddIO2+0xc>)
 c003c96:	6853      	ldr	r3, [r2, #4]
 c003c98:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 c003c9c:	6053      	str	r3, [r2, #4]
}
 c003c9e:	4770      	bx	lr
 c003ca0:	50007000 	.word	0x50007000

0c003ca4 <HAL_PWREx_ConfigSRAM2ContentRetention>:
{
  /* Check the parameters */
  assert_param(IS_PWR_SRAM2CONTENT_RETENTION(SRAM2ContentRetention));

  /* Set RRS bits */
  MODIFY_REG(PWR->CR3, PWR_CR3_RRS, SRAM2ContentRetention);
 c003ca4:	4a03      	ldr	r2, [pc, #12]	; (c003cb4 <HAL_PWREx_ConfigSRAM2ContentRetention+0x10>)
 c003ca6:	6893      	ldr	r3, [r2, #8]
 c003ca8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 c003cac:	4318      	orrs	r0, r3
 c003cae:	6090      	str	r0, [r2, #8]

  return HAL_OK;
}
 c003cb0:	2000      	movs	r0, #0
 c003cb2:	4770      	bx	lr
 c003cb4:	50007000 	.word	0x50007000

0c003cb8 <HAL_PWREx_EnableSRAM2ContentRetention>:
  *         Standby mode and its content is kept.
  * @retval None
  */
void HAL_PWREx_EnableSRAM2ContentRetention(void)
{
  (void) HAL_PWREx_ConfigSRAM2ContentRetention(PWR_FULL_SRAM2_RETENTION);
 c003cb8:	f44f 7080 	mov.w	r0, #256	; 0x100
 c003cbc:	f7ff bff2 	b.w	c003ca4 <HAL_PWREx_ConfigSRAM2ContentRetention>

0c003cc0 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t msirange = 0U, sysclockfreq = 0U;
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c003cc0:	4a24      	ldr	r2, [pc, #144]	; (c003d54 <HAL_RCC_GetSysClockFreq+0x94>)
 c003cc2:	6893      	ldr	r3, [r2, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 c003cc4:	68d1      	ldr	r1, [r2, #12]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 c003cc6:	f013 030c 	ands.w	r3, r3, #12
 c003cca:	d005      	beq.n	c003cd8 <HAL_RCC_GetSysClockFreq+0x18>
 c003ccc:	2b0c      	cmp	r3, #12
 c003cce:	d116      	bne.n	c003cfe <HAL_RCC_GetSysClockFreq+0x3e>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 c003cd0:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 c003cd4:	2901      	cmp	r1, #1
 c003cd6:	d119      	bne.n	c003d0c <HAL_RCC_GetSysClockFreq+0x4c>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 c003cd8:	6811      	ldr	r1, [r2, #0]
 c003cda:	0709      	lsls	r1, r1, #28
    {
      /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 c003cdc:	bf54      	ite	pl
 c003cde:	f8d2 2094 	ldrpl.w	r2, [r2, #148]	; 0x94
    }
    else
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 c003ce2:	6812      	ldrmi	r2, [r2, #0]
    }
    /*MSI frequency range in Hz*/
    msirange = MSIRangeTable[msirange];
 c003ce4:	491c      	ldr	r1, [pc, #112]	; (c003d58 <HAL_RCC_GetSysClockFreq+0x98>)
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 c003ce6:	bf54      	ite	pl
 c003ce8:	f3c2 2203 	ubfxpl	r2, r2, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 c003cec:	f3c2 1203 	ubfxmi	r2, r2, #4, #4
    msirange = MSIRangeTable[msirange];
 c003cf0:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]

    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 c003cf4:	b113      	cbz	r3, c003cfc <HAL_RCC_GetSysClockFreq+0x3c>
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 c003cf6:	2b0c      	cmp	r3, #12
 c003cf8:	d009      	beq.n	c003d0e <HAL_RCC_GetSysClockFreq+0x4e>
 c003cfa:	2000      	movs	r0, #0
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
    sysclockfreq = pllvco / pllr;
  }

  return sysclockfreq;
}
 c003cfc:	4770      	bx	lr
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 c003cfe:	2b04      	cmp	r3, #4
 c003d00:	d026      	beq.n	c003d50 <HAL_RCC_GetSysClockFreq+0x90>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 c003d02:	2b08      	cmp	r3, #8
 c003d04:	4815      	ldr	r0, [pc, #84]	; (c003d5c <HAL_RCC_GetSysClockFreq+0x9c>)
 c003d06:	bf18      	it	ne
 c003d08:	2000      	movne	r0, #0
 c003d0a:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
 c003d0c:	2000      	movs	r0, #0
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c003d0e:	4a11      	ldr	r2, [pc, #68]	; (c003d54 <HAL_RCC_GetSysClockFreq+0x94>)
 c003d10:	68d1      	ldr	r1, [r2, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 c003d12:	68d3      	ldr	r3, [r2, #12]
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c003d14:	f001 0103 	and.w	r1, r1, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 c003d18:	f3c3 1303 	ubfx	r3, r3, #4, #4
    switch (pllsource)
 c003d1c:	2902      	cmp	r1, #2
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 c003d1e:	f103 0301 	add.w	r3, r3, #1
    switch (pllsource)
 c003d22:	d005      	beq.n	c003d30 <HAL_RCC_GetSysClockFreq+0x70>
 c003d24:	2903      	cmp	r1, #3
 c003d26:	d003      	beq.n	c003d30 <HAL_RCC_GetSysClockFreq+0x70>
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c003d28:	68d2      	ldr	r2, [r2, #12]
 c003d2a:	f3c2 2206 	ubfx	r2, r2, #8, #7
 c003d2e:	e003      	b.n	c003d38 <HAL_RCC_GetSysClockFreq+0x78>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c003d30:	68d2      	ldr	r2, [r2, #12]
 c003d32:	480a      	ldr	r0, [pc, #40]	; (c003d5c <HAL_RCC_GetSysClockFreq+0x9c>)
 c003d34:	f3c2 2206 	ubfx	r2, r2, #8, #7
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c003d38:	fbb0 f0f3 	udiv	r0, r0, r3
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 c003d3c:	4b05      	ldr	r3, [pc, #20]	; (c003d54 <HAL_RCC_GetSysClockFreq+0x94>)
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c003d3e:	4350      	muls	r0, r2
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 c003d40:	68db      	ldr	r3, [r3, #12]
 c003d42:	f3c3 6341 	ubfx	r3, r3, #25, #2
 c003d46:	3301      	adds	r3, #1
 c003d48:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco / pllr;
 c003d4a:	fbb0 f0f3 	udiv	r0, r0, r3
 c003d4e:	4770      	bx	lr
 c003d50:	4802      	ldr	r0, [pc, #8]	; (c003d5c <HAL_RCC_GetSysClockFreq+0x9c>)
 c003d52:	4770      	bx	lr
 c003d54:	50021000 	.word	0x50021000
 c003d58:	0c00a2a8 	.word	0x0c00a2a8
 c003d5c:	00f42400 	.word	0x00f42400

0c003d60 <HAL_RCC_GetHCLKFreq>:
  * @note   Each time HCLK changes, this function must be called to update the
  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 c003d60:	b508      	push	{r3, lr}
  return (HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]);
 c003d62:	f7ff ffad 	bl	c003cc0 <HAL_RCC_GetSysClockFreq>
 c003d66:	4b04      	ldr	r3, [pc, #16]	; (c003d78 <HAL_RCC_GetHCLKFreq+0x18>)
 c003d68:	4a04      	ldr	r2, [pc, #16]	; (c003d7c <HAL_RCC_GetHCLKFreq+0x1c>)
 c003d6a:	689b      	ldr	r3, [r3, #8]
 c003d6c:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c003d70:	5cd3      	ldrb	r3, [r2, r3]
}
 c003d72:	40d8      	lsrs	r0, r3
 c003d74:	bd08      	pop	{r3, pc}
 c003d76:	bf00      	nop
 c003d78:	50021000 	.word	0x50021000
 c003d7c:	0c00a290 	.word	0x0c00a290

0c003d80 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 c003d80:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 c003d82:	f7ff ffed 	bl	c003d60 <HAL_RCC_GetHCLKFreq>
 c003d86:	4b04      	ldr	r3, [pc, #16]	; (c003d98 <HAL_RCC_GetPCLK1Freq+0x18>)
 c003d88:	4a04      	ldr	r2, [pc, #16]	; (c003d9c <HAL_RCC_GetPCLK1Freq+0x1c>)
 c003d8a:	689b      	ldr	r3, [r3, #8]
 c003d8c:	f3c3 2302 	ubfx	r3, r3, #8, #3
 c003d90:	5cd3      	ldrb	r3, [r2, r3]
}
 c003d92:	40d8      	lsrs	r0, r3
 c003d94:	bd08      	pop	{r3, pc}
 c003d96:	bf00      	nop
 c003d98:	50021000 	.word	0x50021000
 c003d9c:	0c00a2a0 	.word	0x0c00a2a0

0c003da0 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 c003da0:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 c003da2:	f7ff ffdd 	bl	c003d60 <HAL_RCC_GetHCLKFreq>
 c003da6:	4b04      	ldr	r3, [pc, #16]	; (c003db8 <HAL_RCC_GetPCLK2Freq+0x18>)
 c003da8:	4a04      	ldr	r2, [pc, #16]	; (c003dbc <HAL_RCC_GetPCLK2Freq+0x1c>)
 c003daa:	689b      	ldr	r3, [r3, #8]
 c003dac:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 c003db0:	5cd3      	ldrb	r3, [r2, r3]
}
 c003db2:	40d8      	lsrs	r0, r3
 c003db4:	bd08      	pop	{r3, pc}
 c003db6:	bf00      	nop
 c003db8:	50021000 	.word	0x50021000
 c003dbc:	0c00a2a0 	.word	0x0c00a2a0

0c003dc0 <HAL_UART_MspInit>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
 c003dc0:	4770      	bx	lr

0c003dc2 <HAL_UART_RxCpltCallback>:
 c003dc2:	4770      	bx	lr

0c003dc4 <HAL_UART_ErrorCallback>:
 c003dc4:	4770      	bx	lr

0c003dc6 <HAL_UARTEx_RxEventCallback>:
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 c003dc6:	4770      	bx	lr

0c003dc8 <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c003dc8:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
{
 c003dcc:	b510      	push	{r4, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c003dce:	2a22      	cmp	r2, #34	; 0x22
{
 c003dd0:	4604      	mov	r4, r0
 c003dd2:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c003dd4:	d130      	bne.n	c003e38 <UART_RxISR_8BIT+0x70>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c003dd6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c003dd8:	f890 1060 	ldrb.w	r1, [r0, #96]	; 0x60
 c003ddc:	6d82      	ldr	r2, [r0, #88]	; 0x58
 c003dde:	400b      	ands	r3, r1
 c003de0:	7013      	strb	r3, [r2, #0]
    huart->pRxBuffPtr++;
 c003de2:	6d83      	ldr	r3, [r0, #88]	; 0x58
 c003de4:	3301      	adds	r3, #1
 c003de6:	6583      	str	r3, [r0, #88]	; 0x58
    huart->RxXferCount--;
 c003de8:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 c003dec:	3b01      	subs	r3, #1
 c003dee:	b29b      	uxth	r3, r3
 c003df0:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 c003df4:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 c003df8:	b292      	uxth	r2, r2
 c003dfa:	b9ca      	cbnz	r2, c003e30 <UART_RxISR_8BIT+0x68>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 c003dfc:	6803      	ldr	r3, [r0, #0]
 c003dfe:	6819      	ldr	r1, [r3, #0]
 c003e00:	f421 7190 	bic.w	r1, r1, #288	; 0x120
 c003e04:	6019      	str	r1, [r3, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c003e06:	6899      	ldr	r1, [r3, #8]
 c003e08:	f021 0101 	bic.w	r1, r1, #1
 c003e0c:	6099      	str	r1, [r3, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 c003e0e:	2120      	movs	r1, #32
 c003e10:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 c003e14:	6702      	str	r2, [r0, #112]	; 0x70

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c003e16:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 c003e18:	2a01      	cmp	r2, #1
 c003e1a:	d10a      	bne.n	c003e32 <UART_RxISR_8BIT+0x6a>
      {
        /* Disable IDLE interrupt */
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c003e1c:	681a      	ldr	r2, [r3, #0]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c003e1e:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c003e22:	f022 0210 	bic.w	r2, r2, #16
 c003e26:	601a      	str	r2, [r3, #0]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c003e28:	f7ff ffcd 	bl	c003dc6 <HAL_UARTEx_RxEventCallback>
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }
      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c003e2c:	2300      	movs	r3, #0
 c003e2e:	66e3      	str	r3, [r4, #108]	; 0x6c
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c003e30:	bd10      	pop	{r4, pc}
        HAL_UART_RxCpltCallback(huart);
 c003e32:	f7ff ffc6 	bl	c003dc2 <HAL_UART_RxCpltCallback>
 c003e36:	e7f9      	b.n	c003e2c <UART_RxISR_8BIT+0x64>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c003e38:	699a      	ldr	r2, [r3, #24]
 c003e3a:	f042 0208 	orr.w	r2, r2, #8
 c003e3e:	619a      	str	r2, [r3, #24]
}
 c003e40:	e7f6      	b.n	c003e30 <UART_RxISR_8BIT+0x68>

0c003e42 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c003e42:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
{
 c003e46:	b510      	push	{r4, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c003e48:	2a22      	cmp	r2, #34	; 0x22
{
 c003e4a:	4604      	mov	r4, r0
 c003e4c:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c003e4e:	d12e      	bne.n	c003eae <UART_RxISR_16BIT+0x6c>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c003e50:	6a59      	ldr	r1, [r3, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 c003e52:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
 c003e56:	4011      	ands	r1, r2
 c003e58:	6d82      	ldr	r2, [r0, #88]	; 0x58
 c003e5a:	f822 1b02 	strh.w	r1, [r2], #2
    huart->pRxBuffPtr += 2U;
 c003e5e:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 c003e60:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 c003e64:	3a01      	subs	r2, #1
 c003e66:	b292      	uxth	r2, r2
 c003e68:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 c003e6c:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 c003e70:	b292      	uxth	r2, r2
 c003e72:	b9c2      	cbnz	r2, c003ea6 <UART_RxISR_16BIT+0x64>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 c003e74:	6819      	ldr	r1, [r3, #0]
 c003e76:	f421 7190 	bic.w	r1, r1, #288	; 0x120
 c003e7a:	6019      	str	r1, [r3, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c003e7c:	6899      	ldr	r1, [r3, #8]
 c003e7e:	f021 0101 	bic.w	r1, r1, #1
 c003e82:	6099      	str	r1, [r3, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 c003e84:	2120      	movs	r1, #32
 c003e86:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 c003e8a:	6702      	str	r2, [r0, #112]	; 0x70

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c003e8c:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 c003e8e:	2a01      	cmp	r2, #1
 c003e90:	d10a      	bne.n	c003ea8 <UART_RxISR_16BIT+0x66>
      {
        /* Disable IDLE interrupt */
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c003e92:	681a      	ldr	r2, [r3, #0]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c003e94:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c003e98:	f022 0210 	bic.w	r2, r2, #16
 c003e9c:	601a      	str	r2, [r3, #0]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c003e9e:	f7ff ff92 	bl	c003dc6 <HAL_UARTEx_RxEventCallback>
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }
      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c003ea2:	2300      	movs	r3, #0
 c003ea4:	66e3      	str	r3, [r4, #108]	; 0x6c
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c003ea6:	bd10      	pop	{r4, pc}
        HAL_UART_RxCpltCallback(huart);
 c003ea8:	f7ff ff8b 	bl	c003dc2 <HAL_UART_RxCpltCallback>
 c003eac:	e7f9      	b.n	c003ea2 <UART_RxISR_16BIT+0x60>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c003eae:	699a      	ldr	r2, [r3, #24]
 c003eb0:	f042 0208 	orr.w	r2, r2, #8
 c003eb4:	619a      	str	r2, [r3, #24]
}
 c003eb6:	e7f6      	b.n	c003ea6 <UART_RxISR_16BIT+0x64>

0c003eb8 <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 c003eb8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c003ebc:	6803      	ldr	r3, [r0, #0]
{
 c003ebe:	4604      	mov	r4, r0
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c003ec0:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 c003ec2:	f8d3 9000 	ldr.w	r9, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 c003ec6:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c003ec8:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 c003ecc:	2a22      	cmp	r2, #34	; 0x22
 c003ece:	f040 8085 	bne.w	c003fdc <UART_RxISR_8BIT_FIFOEN+0x124>
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 c003ed2:	2700      	movs	r7, #0
  uint16_t  uhMask = huart->Mask;
 c003ed4:	f8b0 8060 	ldrh.w	r8, [r0, #96]	; 0x60
    nb_rx_data = huart->NbRxDataToProcess;
 c003ed8:	f8b0 a068 	ldrh.w	sl, [r0, #104]	; 0x68
      {
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c003edc:	f8df b10c 	ldr.w	fp, [pc, #268]	; c003fec <UART_RxISR_8BIT_FIFOEN+0x134>
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c003ee0:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 c003ee4:	f1ba 0f00 	cmp.w	sl, #0
 c003ee8:	d001      	beq.n	c003eee <UART_RxISR_8BIT_FIFOEN+0x36>
 c003eea:	06ab      	lsls	r3, r5, #26
 c003eec:	d414      	bmi.n	c003f18 <UART_RxISR_8BIT_FIFOEN+0x60>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 c003eee:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 c003ef2:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 c003ef4:	b173      	cbz	r3, c003f14 <UART_RxISR_8BIT_FIFOEN+0x5c>
 c003ef6:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 c003efa:	429a      	cmp	r2, r3
 c003efc:	d90a      	bls.n	c003f14 <UART_RxISR_8BIT_FIFOEN+0x5c>
    {
      /* Disable the UART RXFT interrupt*/
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c003efe:	6823      	ldr	r3, [r4, #0]
 c003f00:	689a      	ldr	r2, [r3, #8]
 c003f02:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 c003f06:	609a      	str	r2, [r3, #8]

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 c003f08:	4a37      	ldr	r2, [pc, #220]	; (c003fe8 <UART_RxISR_8BIT_FIFOEN+0x130>)
 c003f0a:	6722      	str	r2, [r4, #112]	; 0x70

      /* Enable the UART Data Register Not Empty interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 c003f0c:	681a      	ldr	r2, [r3, #0]
 c003f0e:	f042 0220 	orr.w	r2, r2, #32
 c003f12:	601a      	str	r2, [r3, #0]
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c003f14:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c003f18:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c003f1a:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c003f1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c003f1e:	ea03 0308 	and.w	r3, r3, r8
 c003f22:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
 c003f24:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c003f26:	3301      	adds	r3, #1
 c003f28:	65a3      	str	r3, [r4, #88]	; 0x58
      huart->RxXferCount--;
 c003f2a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 c003f2e:	3b01      	subs	r3, #1
 c003f30:	b29b      	uxth	r3, r3
 c003f32:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 c003f36:	6823      	ldr	r3, [r4, #0]
 c003f38:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 c003f3a:	076a      	lsls	r2, r5, #29
 c003f3c:	d02a      	beq.n	c003f94 <UART_RxISR_8BIT_FIFOEN+0xdc>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 c003f3e:	07e8      	lsls	r0, r5, #31
 c003f40:	d50a      	bpl.n	c003f58 <UART_RxISR_8BIT_FIFOEN+0xa0>
 c003f42:	f419 7f80 	tst.w	r9, #256	; 0x100
 c003f46:	d007      	beq.n	c003f58 <UART_RxISR_8BIT_FIFOEN+0xa0>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 c003f48:	2201      	movs	r2, #1
 c003f4a:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 c003f4c:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 c003f50:	f042 0201 	orr.w	r2, r2, #1
 c003f54:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c003f58:	07a9      	lsls	r1, r5, #30
 c003f5a:	d508      	bpl.n	c003f6e <UART_RxISR_8BIT_FIFOEN+0xb6>
 c003f5c:	b13e      	cbz	r6, c003f6e <UART_RxISR_8BIT_FIFOEN+0xb6>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 c003f5e:	2202      	movs	r2, #2
 c003f60:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 c003f62:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 c003f66:	f042 0204 	orr.w	r2, r2, #4
 c003f6a:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c003f6e:	076a      	lsls	r2, r5, #29
 c003f70:	d508      	bpl.n	c003f84 <UART_RxISR_8BIT_FIFOEN+0xcc>
 c003f72:	b13e      	cbz	r6, c003f84 <UART_RxISR_8BIT_FIFOEN+0xcc>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 c003f74:	2204      	movs	r2, #4
 c003f76:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 c003f78:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 c003f7c:	f043 0302 	orr.w	r3, r3, #2
 c003f80:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 c003f84:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 c003f88:	b123      	cbz	r3, c003f94 <UART_RxISR_8BIT_FIFOEN+0xdc>
          HAL_UART_ErrorCallback(huart);
 c003f8a:	4620      	mov	r0, r4
 c003f8c:	f7ff ff1a 	bl	c003dc4 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 c003f90:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 c003f94:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 c003f98:	b292      	uxth	r2, r2
 c003f9a:	2a00      	cmp	r2, #0
 c003f9c:	d1a2      	bne.n	c003ee4 <UART_RxISR_8BIT_FIFOEN+0x2c>
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c003f9e:	6823      	ldr	r3, [r4, #0]
 c003fa0:	6819      	ldr	r1, [r3, #0]
 c003fa2:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 c003fa6:	6019      	str	r1, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c003fa8:	6899      	ldr	r1, [r3, #8]
 c003faa:	ea01 010b 	and.w	r1, r1, fp
 c003fae:	6099      	str	r1, [r3, #8]
        huart->RxState = HAL_UART_STATE_READY;
 c003fb0:	2120      	movs	r1, #32
 c003fb2:	f8c4 1088 	str.w	r1, [r4, #136]	; 0x88
        huart->RxISR = NULL;
 c003fb6:	6722      	str	r2, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c003fb8:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 c003fba:	2a01      	cmp	r2, #1
 c003fbc:	d10a      	bne.n	c003fd4 <UART_RxISR_8BIT_FIFOEN+0x11c>
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c003fbe:	681a      	ldr	r2, [r3, #0]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c003fc0:	4620      	mov	r0, r4
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c003fc2:	f022 0210 	bic.w	r2, r2, #16
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c003fc6:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c003fca:	601a      	str	r2, [r3, #0]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c003fcc:	f7ff fefb 	bl	c003dc6 <HAL_UARTEx_RxEventCallback>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c003fd0:	66e7      	str	r7, [r4, #108]	; 0x6c
 c003fd2:	e787      	b.n	c003ee4 <UART_RxISR_8BIT_FIFOEN+0x2c>
          HAL_UART_RxCpltCallback(huart);
 c003fd4:	4620      	mov	r0, r4
 c003fd6:	f7ff fef4 	bl	c003dc2 <HAL_UART_RxCpltCallback>
 c003fda:	e7f9      	b.n	c003fd0 <UART_RxISR_8BIT_FIFOEN+0x118>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c003fdc:	699a      	ldr	r2, [r3, #24]
 c003fde:	f042 0208 	orr.w	r2, r2, #8
 c003fe2:	619a      	str	r2, [r3, #24]
}
 c003fe4:	e796      	b.n	c003f14 <UART_RxISR_8BIT_FIFOEN+0x5c>
 c003fe6:	bf00      	nop
 c003fe8:	0c003dc9 	.word	0x0c003dc9
 c003fec:	effffffe 	.word	0xeffffffe

0c003ff0 <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 c003ff0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c003ff4:	6803      	ldr	r3, [r0, #0]
{
 c003ff6:	4604      	mov	r4, r0
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c003ff8:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 c003ffa:	f8d3 9000 	ldr.w	r9, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 c003ffe:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c004000:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 c004004:	2a22      	cmp	r2, #34	; 0x22
 c004006:	f040 8083 	bne.w	c004110 <UART_RxISR_16BIT_FIFOEN+0x120>
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 c00400a:	2700      	movs	r7, #0
  uint16_t  uhMask = huart->Mask;
 c00400c:	f8b0 8060 	ldrh.w	r8, [r0, #96]	; 0x60
    nb_rx_data = huart->NbRxDataToProcess;
 c004010:	f8b0 a068 	ldrh.w	sl, [r0, #104]	; 0x68
      {
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c004014:	f8df b108 	ldr.w	fp, [pc, #264]	; c004120 <UART_RxISR_16BIT_FIFOEN+0x130>
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c004018:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 c00401c:	f1ba 0f00 	cmp.w	sl, #0
 c004020:	d001      	beq.n	c004026 <UART_RxISR_16BIT_FIFOEN+0x36>
 c004022:	06ab      	lsls	r3, r5, #26
 c004024:	d414      	bmi.n	c004050 <UART_RxISR_16BIT_FIFOEN+0x60>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 c004026:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 c00402a:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 c00402c:	b173      	cbz	r3, c00404c <UART_RxISR_16BIT_FIFOEN+0x5c>
 c00402e:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 c004032:	429a      	cmp	r2, r3
 c004034:	d90a      	bls.n	c00404c <UART_RxISR_16BIT_FIFOEN+0x5c>
    {
      /* Disable the UART RXFT interrupt*/
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c004036:	6823      	ldr	r3, [r4, #0]
 c004038:	689a      	ldr	r2, [r3, #8]
 c00403a:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 c00403e:	609a      	str	r2, [r3, #8]

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 c004040:	4a36      	ldr	r2, [pc, #216]	; (c00411c <UART_RxISR_16BIT_FIFOEN+0x12c>)
 c004042:	6722      	str	r2, [r4, #112]	; 0x70

      /* Enable the UART Data Register Not Empty interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 c004044:	681a      	ldr	r2, [r3, #0]
 c004046:	f042 0220 	orr.w	r2, r2, #32
 c00404a:	601a      	str	r2, [r3, #0]
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c00404c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c004050:	6823      	ldr	r3, [r4, #0]
      *tmp = (uint16_t)(uhdata & uhMask);
 c004052:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c004054:	6a59      	ldr	r1, [r3, #36]	; 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
 c004056:	ea08 0101 	and.w	r1, r8, r1
 c00405a:	f822 1b02 	strh.w	r1, [r2], #2
      huart->pRxBuffPtr += 2U;
 c00405e:	65a2      	str	r2, [r4, #88]	; 0x58
      huart->RxXferCount--;
 c004060:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 c004064:	3a01      	subs	r2, #1
 c004066:	b292      	uxth	r2, r2
 c004068:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 c00406c:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 c00406e:	076a      	lsls	r2, r5, #29
 c004070:	d02a      	beq.n	c0040c8 <UART_RxISR_16BIT_FIFOEN+0xd8>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 c004072:	07e8      	lsls	r0, r5, #31
 c004074:	d50a      	bpl.n	c00408c <UART_RxISR_16BIT_FIFOEN+0x9c>
 c004076:	f419 7f80 	tst.w	r9, #256	; 0x100
 c00407a:	d007      	beq.n	c00408c <UART_RxISR_16BIT_FIFOEN+0x9c>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 c00407c:	2201      	movs	r2, #1
 c00407e:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 c004080:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 c004084:	f042 0201 	orr.w	r2, r2, #1
 c004088:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c00408c:	07a9      	lsls	r1, r5, #30
 c00408e:	d508      	bpl.n	c0040a2 <UART_RxISR_16BIT_FIFOEN+0xb2>
 c004090:	b13e      	cbz	r6, c0040a2 <UART_RxISR_16BIT_FIFOEN+0xb2>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 c004092:	2202      	movs	r2, #2
 c004094:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 c004096:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 c00409a:	f042 0204 	orr.w	r2, r2, #4
 c00409e:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c0040a2:	076a      	lsls	r2, r5, #29
 c0040a4:	d508      	bpl.n	c0040b8 <UART_RxISR_16BIT_FIFOEN+0xc8>
 c0040a6:	b13e      	cbz	r6, c0040b8 <UART_RxISR_16BIT_FIFOEN+0xc8>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 c0040a8:	2204      	movs	r2, #4
 c0040aa:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 c0040ac:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 c0040b0:	f043 0302 	orr.w	r3, r3, #2
 c0040b4:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 c0040b8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 c0040bc:	b123      	cbz	r3, c0040c8 <UART_RxISR_16BIT_FIFOEN+0xd8>
          HAL_UART_ErrorCallback(huart);
 c0040be:	4620      	mov	r0, r4
 c0040c0:	f7ff fe80 	bl	c003dc4 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 c0040c4:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 c0040c8:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 c0040cc:	b292      	uxth	r2, r2
 c0040ce:	2a00      	cmp	r2, #0
 c0040d0:	d1a4      	bne.n	c00401c <UART_RxISR_16BIT_FIFOEN+0x2c>
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c0040d2:	6823      	ldr	r3, [r4, #0]
 c0040d4:	6819      	ldr	r1, [r3, #0]
 c0040d6:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 c0040da:	6019      	str	r1, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c0040dc:	6899      	ldr	r1, [r3, #8]
 c0040de:	ea01 010b 	and.w	r1, r1, fp
 c0040e2:	6099      	str	r1, [r3, #8]
        huart->RxState = HAL_UART_STATE_READY;
 c0040e4:	2120      	movs	r1, #32
 c0040e6:	f8c4 1088 	str.w	r1, [r4, #136]	; 0x88
        huart->RxISR = NULL;
 c0040ea:	6722      	str	r2, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c0040ec:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 c0040ee:	2a01      	cmp	r2, #1
 c0040f0:	d10a      	bne.n	c004108 <UART_RxISR_16BIT_FIFOEN+0x118>
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c0040f2:	681a      	ldr	r2, [r3, #0]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c0040f4:	4620      	mov	r0, r4
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c0040f6:	f022 0210 	bic.w	r2, r2, #16
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c0040fa:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c0040fe:	601a      	str	r2, [r3, #0]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c004100:	f7ff fe61 	bl	c003dc6 <HAL_UARTEx_RxEventCallback>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c004104:	66e7      	str	r7, [r4, #108]	; 0x6c
 c004106:	e789      	b.n	c00401c <UART_RxISR_16BIT_FIFOEN+0x2c>
          HAL_UART_RxCpltCallback(huart);
 c004108:	4620      	mov	r0, r4
 c00410a:	f7ff fe5a 	bl	c003dc2 <HAL_UART_RxCpltCallback>
 c00410e:	e7f9      	b.n	c004104 <UART_RxISR_16BIT_FIFOEN+0x114>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c004110:	699a      	ldr	r2, [r3, #24]
 c004112:	f042 0208 	orr.w	r2, r2, #8
 c004116:	619a      	str	r2, [r3, #24]
}
 c004118:	e798      	b.n	c00404c <UART_RxISR_16BIT_FIFOEN+0x5c>
 c00411a:	bf00      	nop
 c00411c:	0c003e43 	.word	0x0c003e43
 c004120:	effffffe 	.word	0xeffffffe

0c004124 <UART_SetConfig>:
{
 c004124:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c004126:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c004128:	6921      	ldr	r1, [r4, #16]
 c00412a:	68a2      	ldr	r2, [r4, #8]
  if (UART_INSTANCE_LOWPOWER(huart))
 c00412c:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c00412e:	430a      	orrs	r2, r1
 c004130:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c004132:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c004134:	69c0      	ldr	r0, [r0, #28]
 c004136:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c004138:	49a1      	ldr	r1, [pc, #644]	; (c0043c0 <UART_SetConfig+0x29c>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c00413a:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c00413c:	4029      	ands	r1, r5
 c00413e:	430a      	orrs	r2, r1
 c004140:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 c004142:	685a      	ldr	r2, [r3, #4]
 c004144:	68e1      	ldr	r1, [r4, #12]
 c004146:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 c00414a:	430a      	orrs	r2, r1
 c00414c:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 c00414e:	4a9d      	ldr	r2, [pc, #628]	; (c0043c4 <UART_SetConfig+0x2a0>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 c004150:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 c004152:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
 c004154:	bf1c      	itt	ne
 c004156:	6a22      	ldrne	r2, [r4, #32]
 c004158:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 c00415a:	689a      	ldr	r2, [r3, #8]
 c00415c:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 c004160:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 c004164:	430a      	orrs	r2, r1
 c004166:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 c004168:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 c00416a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 c00416c:	f022 020f 	bic.w	r2, r2, #15
 c004170:	430a      	orrs	r2, r1
 c004172:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 c004174:	4a94      	ldr	r2, [pc, #592]	; (c0043c8 <UART_SetConfig+0x2a4>)
 c004176:	4293      	cmp	r3, r2
 c004178:	d11b      	bne.n	c0041b2 <UART_SetConfig+0x8e>
 c00417a:	4b94      	ldr	r3, [pc, #592]	; (c0043cc <UART_SetConfig+0x2a8>)
 c00417c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 c004180:	f003 0303 	and.w	r3, r3, #3
 c004184:	3b01      	subs	r3, #1
 c004186:	2b02      	cmp	r3, #2
 c004188:	f200 80ea 	bhi.w	c004360 <UART_SetConfig+0x23c>
 c00418c:	4a90      	ldr	r2, [pc, #576]	; (c0043d0 <UART_SetConfig+0x2ac>)
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c00418e:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c004192:	5cd3      	ldrb	r3, [r2, r3]
 c004194:	f040 80ac 	bne.w	c0042f0 <UART_SetConfig+0x1cc>
    switch (clocksource)
 c004198:	2b08      	cmp	r3, #8
 c00419a:	d826      	bhi.n	c0041ea <UART_SetConfig+0xc6>
 c00419c:	e8df f013 	tbh	[pc, r3, lsl #1]
 c0041a0:	00e300ef 	.word	0x00e300ef
 c0041a4:	002500a6 	.word	0x002500a6
 c0041a8:	002500e9 	.word	0x002500e9
 c0041ac:	00250025 	.word	0x00250025
 c0041b0:	00f3      	.short	0x00f3
  UART_GETCLOCKSOURCE(huart, clocksource);
 c0041b2:	4a88      	ldr	r2, [pc, #544]	; (c0043d4 <UART_SetConfig+0x2b0>)
 c0041b4:	4293      	cmp	r3, r2
 c0041b6:	d106      	bne.n	c0041c6 <UART_SetConfig+0xa2>
 c0041b8:	4b84      	ldr	r3, [pc, #528]	; (c0043cc <UART_SetConfig+0x2a8>)
 c0041ba:	4a87      	ldr	r2, [pc, #540]	; (c0043d8 <UART_SetConfig+0x2b4>)
 c0041bc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 c0041c0:	f003 030c 	and.w	r3, r3, #12
 c0041c4:	e7e3      	b.n	c00418e <UART_SetConfig+0x6a>
 c0041c6:	4a85      	ldr	r2, [pc, #532]	; (c0043dc <UART_SetConfig+0x2b8>)
 c0041c8:	4293      	cmp	r3, r2
 c0041ca:	d119      	bne.n	c004200 <UART_SetConfig+0xdc>
 c0041cc:	4b7f      	ldr	r3, [pc, #508]	; (c0043cc <UART_SetConfig+0x2a8>)
 c0041ce:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 c0041d2:	f003 0330 	and.w	r3, r3, #48	; 0x30
 c0041d6:	2b20      	cmp	r3, #32
 c0041d8:	f000 80bd 	beq.w	c004356 <UART_SetConfig+0x232>
 c0041dc:	d807      	bhi.n	c0041ee <UART_SetConfig+0xca>
 c0041de:	2b00      	cmp	r3, #0
 c0041e0:	f000 80ca 	beq.w	c004378 <UART_SetConfig+0x254>
 c0041e4:	2b10      	cmp	r3, #16
 c0041e6:	f000 80c1 	beq.w	c00436c <UART_SetConfig+0x248>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c0041ea:	2001      	movs	r0, #1
 c0041ec:	e04f      	b.n	c00428e <UART_SetConfig+0x16a>
  UART_GETCLOCKSOURCE(huart, clocksource);
 c0041ee:	2b30      	cmp	r3, #48	; 0x30
 c0041f0:	d1fb      	bne.n	c0041ea <UART_SetConfig+0xc6>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c0041f2:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c0041f6:	f000 80c6 	beq.w	c004386 <UART_SetConfig+0x262>
 c0041fa:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 c0041fe:	e093      	b.n	c004328 <UART_SetConfig+0x204>
  UART_GETCLOCKSOURCE(huart, clocksource);
 c004200:	4a77      	ldr	r2, [pc, #476]	; (c0043e0 <UART_SetConfig+0x2bc>)
 c004202:	4293      	cmp	r3, r2
 c004204:	d10f      	bne.n	c004226 <UART_SetConfig+0x102>
 c004206:	4b71      	ldr	r3, [pc, #452]	; (c0043cc <UART_SetConfig+0x2a8>)
 c004208:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 c00420c:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 c004210:	2b80      	cmp	r3, #128	; 0x80
 c004212:	f000 80a0 	beq.w	c004356 <UART_SetConfig+0x232>
 c004216:	d804      	bhi.n	c004222 <UART_SetConfig+0xfe>
 c004218:	2b00      	cmp	r3, #0
 c00421a:	f000 80ad 	beq.w	c004378 <UART_SetConfig+0x254>
 c00421e:	2b40      	cmp	r3, #64	; 0x40
 c004220:	e7e1      	b.n	c0041e6 <UART_SetConfig+0xc2>
 c004222:	2bc0      	cmp	r3, #192	; 0xc0
 c004224:	e7e4      	b.n	c0041f0 <UART_SetConfig+0xcc>
 c004226:	f1b3 2f50 	cmp.w	r3, #1342197760	; 0x50005000
 c00422a:	d113      	bne.n	c004254 <UART_SetConfig+0x130>
 c00422c:	f503 33e0 	add.w	r3, r3, #114688	; 0x1c000
 c004230:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 c004234:	f403 7340 	and.w	r3, r3, #768	; 0x300
 c004238:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 c00423c:	f000 808b 	beq.w	c004356 <UART_SetConfig+0x232>
 c004240:	d805      	bhi.n	c00424e <UART_SetConfig+0x12a>
 c004242:	2b00      	cmp	r3, #0
 c004244:	f000 8098 	beq.w	c004378 <UART_SetConfig+0x254>
 c004248:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 c00424c:	e7cb      	b.n	c0041e6 <UART_SetConfig+0xc2>
 c00424e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 c004252:	e7cd      	b.n	c0041f0 <UART_SetConfig+0xcc>
 c004254:	4a5b      	ldr	r2, [pc, #364]	; (c0043c4 <UART_SetConfig+0x2a0>)
 c004256:	4293      	cmp	r3, r2
 c004258:	d1c7      	bne.n	c0041ea <UART_SetConfig+0xc6>
 c00425a:	4b5c      	ldr	r3, [pc, #368]	; (c0043cc <UART_SetConfig+0x2a8>)
 c00425c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 c004260:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 c004264:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 c004268:	d018      	beq.n	c00429c <UART_SetConfig+0x178>
 c00426a:	d806      	bhi.n	c00427a <UART_SetConfig+0x156>
 c00426c:	b15b      	cbz	r3, c004286 <UART_SetConfig+0x162>
 c00426e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 c004272:	d1ba      	bne.n	c0041ea <UART_SetConfig+0xc6>
        pclk = HAL_RCC_GetSysClockFreq();
 c004274:	f7ff fd24 	bl	c003cc0 <HAL_RCC_GetSysClockFreq>
        break;
 c004278:	e007      	b.n	c00428a <UART_SetConfig+0x166>
  UART_GETCLOCKSOURCE(huart, clocksource);
 c00427a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 c00427e:	d1b4      	bne.n	c0041ea <UART_SetConfig+0xc6>
        pclk = (uint32_t) LSE_VALUE;
 c004280:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 c004284:	e00b      	b.n	c00429e <UART_SetConfig+0x17a>
        pclk = HAL_RCC_GetPCLK1Freq();
 c004286:	f7ff fd7b 	bl	c003d80 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 c00428a:	b940      	cbnz	r0, c00429e <UART_SetConfig+0x17a>
 c00428c:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
 c00428e:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 c004292:	66a3      	str	r3, [r4, #104]	; 0x68
  huart->RxISR = NULL;
 c004294:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 c004296:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70
}
 c00429a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pclk = (uint32_t) HSI_VALUE;
 c00429c:	4851      	ldr	r0, [pc, #324]	; (c0043e4 <UART_SetConfig+0x2c0>)
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 c00429e:	4b52      	ldr	r3, [pc, #328]	; (c0043e8 <UART_SetConfig+0x2c4>)
 c0042a0:	6a62      	ldr	r2, [r4, #36]	; 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c0042a2:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 c0042a4:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c0042a8:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 c0042ac:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c0042b0:	4299      	cmp	r1, r3
 c0042b2:	d89a      	bhi.n	c0041ea <UART_SetConfig+0xc6>
 c0042b4:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 c0042b8:	d897      	bhi.n	c0041ea <UART_SetConfig+0xc6>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, (uint64_t)huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c0042ba:	2300      	movs	r3, #0
 c0042bc:	2100      	movs	r1, #0
 c0042be:	f005 fc83 	bl	c009bc8 <__aeabi_uldivmod>
 c0042c2:	020f      	lsls	r7, r1, #8
 c0042c4:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 c0042c8:	0206      	lsls	r6, r0, #8
 c0042ca:	0868      	lsrs	r0, r5, #1
 c0042cc:	1830      	adds	r0, r6, r0
 c0042ce:	462a      	mov	r2, r5
 c0042d0:	f04f 0300 	mov.w	r3, #0
 c0042d4:	f147 0100 	adc.w	r1, r7, #0
 c0042d8:	f005 fc76 	bl	c009bc8 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 c0042dc:	4b43      	ldr	r3, [pc, #268]	; (c0043ec <UART_SetConfig+0x2c8>)
 c0042de:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
 c0042e2:	429a      	cmp	r2, r3
 c0042e4:	d881      	bhi.n	c0041ea <UART_SetConfig+0xc6>
          huart->Instance->BRR = usartdiv;
 c0042e6:	6823      	ldr	r3, [r4, #0]
 c0042e8:	60d8      	str	r0, [r3, #12]
 c0042ea:	e7cf      	b.n	c00428c <UART_SetConfig+0x168>
        pclk = (uint32_t) HSI_VALUE;
 c0042ec:	483d      	ldr	r0, [pc, #244]	; (c0043e4 <UART_SetConfig+0x2c0>)
 c0042ee:	e04a      	b.n	c004386 <UART_SetConfig+0x262>
    switch (clocksource)
 c0042f0:	2b08      	cmp	r3, #8
 c0042f2:	f63f af7a 	bhi.w	c0041ea <UART_SetConfig+0xc6>
 c0042f6:	a201      	add	r2, pc, #4	; (adr r2, c0042fc <UART_SetConfig+0x1d8>)
 c0042f8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 c0042fc:	0c004321 	.word	0x0c004321
 c004300:	0c00434b 	.word	0x0c00434b
 c004304:	0c00435d 	.word	0x0c00435d
 c004308:	0c0041eb 	.word	0x0c0041eb
 c00430c:	0c004351 	.word	0x0c004351
 c004310:	0c0041eb 	.word	0x0c0041eb
 c004314:	0c0041eb 	.word	0x0c0041eb
 c004318:	0c0041eb 	.word	0x0c0041eb
 c00431c:	0c0041fb 	.word	0x0c0041fb
        pclk = HAL_RCC_GetPCLK1Freq();
 c004320:	f7ff fd2e 	bl	c003d80 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 c004324:	2800      	cmp	r0, #0
 c004326:	d0b1      	beq.n	c00428c <UART_SetConfig+0x168>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004328:	6a61      	ldr	r1, [r4, #36]	; 0x24
 c00432a:	4a2f      	ldr	r2, [pc, #188]	; (c0043e8 <UART_SetConfig+0x2c4>)
 c00432c:	6863      	ldr	r3, [r4, #4]
 c00432e:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
 c004332:	fbb0 f0f2 	udiv	r0, r0, r2
 c004336:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 c00433a:	fbb0 f0f3 	udiv	r0, r0, r3
 c00433e:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 c004340:	f64f 73ef 	movw	r3, #65519	; 0xffef
 c004344:	f1a0 0210 	sub.w	r2, r0, #16
 c004348:	e7cb      	b.n	c0042e2 <UART_SetConfig+0x1be>
        pclk = HAL_RCC_GetPCLK2Freq();
 c00434a:	f7ff fd29 	bl	c003da0 <HAL_RCC_GetPCLK2Freq>
        break;
 c00434e:	e7e9      	b.n	c004324 <UART_SetConfig+0x200>
        pclk = HAL_RCC_GetSysClockFreq();
 c004350:	f7ff fcb6 	bl	c003cc0 <HAL_RCC_GetSysClockFreq>
        break;
 c004354:	e7e6      	b.n	c004324 <UART_SetConfig+0x200>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c004356:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c00435a:	d0c7      	beq.n	c0042ec <UART_SetConfig+0x1c8>
        pclk = (uint32_t) HSI_VALUE;
 c00435c:	4821      	ldr	r0, [pc, #132]	; (c0043e4 <UART_SetConfig+0x2c0>)
 c00435e:	e7e3      	b.n	c004328 <UART_SetConfig+0x204>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c004360:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c004364:	d1f1      	bne.n	c00434a <UART_SetConfig+0x226>
        pclk = HAL_RCC_GetPCLK2Freq();
 c004366:	f7ff fd1b 	bl	c003da0 <HAL_RCC_GetPCLK2Freq>
        break;
 c00436a:	e00a      	b.n	c004382 <UART_SetConfig+0x25e>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c00436c:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c004370:	d1ee      	bne.n	c004350 <UART_SetConfig+0x22c>
        pclk = HAL_RCC_GetSysClockFreq();
 c004372:	f7ff fca5 	bl	c003cc0 <HAL_RCC_GetSysClockFreq>
        break;
 c004376:	e004      	b.n	c004382 <UART_SetConfig+0x25e>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c004378:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c00437c:	d1d0      	bne.n	c004320 <UART_SetConfig+0x1fc>
        pclk = HAL_RCC_GetPCLK1Freq();
 c00437e:	f7ff fcff 	bl	c003d80 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 c004382:	2800      	cmp	r0, #0
 c004384:	d082      	beq.n	c00428c <UART_SetConfig+0x168>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c004386:	6a61      	ldr	r1, [r4, #36]	; 0x24
 c004388:	4b17      	ldr	r3, [pc, #92]	; (c0043e8 <UART_SetConfig+0x2c4>)
 c00438a:	6862      	ldr	r2, [r4, #4]
 c00438c:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 c004390:	fbb0 f3f3 	udiv	r3, r0, r3
 c004394:	0850      	lsrs	r0, r2, #1
 c004396:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 c00439a:	fbb0 f0f2 	udiv	r0, r0, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 c00439e:	f64f 72ef 	movw	r2, #65519	; 0xffef
 c0043a2:	b283      	uxth	r3, r0
 c0043a4:	f1a3 0110 	sub.w	r1, r3, #16
 c0043a8:	4291      	cmp	r1, r2
 c0043aa:	f63f af1e 	bhi.w	c0041ea <UART_SetConfig+0xc6>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 c0043ae:	f020 000f 	bic.w	r0, r0, #15
        huart->Instance->BRR = brrtemp;
 c0043b2:	6822      	ldr	r2, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 c0043b4:	b280      	uxth	r0, r0
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 c0043b6:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 c0043ba:	4318      	orrs	r0, r3
 c0043bc:	60d0      	str	r0, [r2, #12]
 c0043be:	e765      	b.n	c00428c <UART_SetConfig+0x168>
 c0043c0:	cfff69f3 	.word	0xcfff69f3
 c0043c4:	50008000 	.word	0x50008000
 c0043c8:	50013800 	.word	0x50013800
 c0043cc:	50021000 	.word	0x50021000
 c0043d0:	0c00a7d5 	.word	0x0c00a7d5
 c0043d4:	50004400 	.word	0x50004400
 c0043d8:	0c00a7d8 	.word	0x0c00a7d8
 c0043dc:	50004800 	.word	0x50004800
 c0043e0:	50004c00 	.word	0x50004c00
 c0043e4:	00f42400 	.word	0x00f42400
 c0043e8:	0c00a7e6 	.word	0x0c00a7e6
 c0043ec:	000ffcff 	.word	0x000ffcff

0c0043f0 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 c0043f0:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
 c0043f2:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 c0043f4:	07da      	lsls	r2, r3, #31
 c0043f6:	d506      	bpl.n	c004406 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 c0043f8:	6801      	ldr	r1, [r0, #0]
 c0043fa:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 c0043fc:	684a      	ldr	r2, [r1, #4]
 c0043fe:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 c004402:	4322      	orrs	r2, r4
 c004404:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 c004406:	079c      	lsls	r4, r3, #30
 c004408:	d506      	bpl.n	c004418 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 c00440a:	6801      	ldr	r1, [r0, #0]
 c00440c:	6b04      	ldr	r4, [r0, #48]	; 0x30
 c00440e:	684a      	ldr	r2, [r1, #4]
 c004410:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 c004414:	4322      	orrs	r2, r4
 c004416:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 c004418:	0759      	lsls	r1, r3, #29
 c00441a:	d506      	bpl.n	c00442a <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 c00441c:	6801      	ldr	r1, [r0, #0]
 c00441e:	6b44      	ldr	r4, [r0, #52]	; 0x34
 c004420:	684a      	ldr	r2, [r1, #4]
 c004422:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 c004426:	4322      	orrs	r2, r4
 c004428:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 c00442a:	071a      	lsls	r2, r3, #28
 c00442c:	d506      	bpl.n	c00443c <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 c00442e:	6801      	ldr	r1, [r0, #0]
 c004430:	6b84      	ldr	r4, [r0, #56]	; 0x38
 c004432:	684a      	ldr	r2, [r1, #4]
 c004434:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 c004438:	4322      	orrs	r2, r4
 c00443a:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 c00443c:	06dc      	lsls	r4, r3, #27
 c00443e:	d506      	bpl.n	c00444e <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 c004440:	6801      	ldr	r1, [r0, #0]
 c004442:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 c004444:	688a      	ldr	r2, [r1, #8]
 c004446:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 c00444a:	4322      	orrs	r2, r4
 c00444c:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 c00444e:	0699      	lsls	r1, r3, #26
 c004450:	d506      	bpl.n	c004460 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 c004452:	6801      	ldr	r1, [r0, #0]
 c004454:	6c04      	ldr	r4, [r0, #64]	; 0x40
 c004456:	688a      	ldr	r2, [r1, #8]
 c004458:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 c00445c:	4322      	orrs	r2, r4
 c00445e:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 c004460:	065a      	lsls	r2, r3, #25
 c004462:	d510      	bpl.n	c004486 <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 c004464:	6801      	ldr	r1, [r0, #0]
 c004466:	6c44      	ldr	r4, [r0, #68]	; 0x44
 c004468:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 c00446a:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 c00446e:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 c004472:	ea42 0204 	orr.w	r2, r2, r4
 c004476:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 c004478:	d105      	bne.n	c004486 <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 c00447a:	684a      	ldr	r2, [r1, #4]
 c00447c:	6c84      	ldr	r4, [r0, #72]	; 0x48
 c00447e:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 c004482:	4322      	orrs	r2, r4
 c004484:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 c004486:	061b      	lsls	r3, r3, #24
 c004488:	d506      	bpl.n	c004498 <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 c00448a:	6802      	ldr	r2, [r0, #0]
 c00448c:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 c00448e:	6853      	ldr	r3, [r2, #4]
 c004490:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 c004494:	430b      	orrs	r3, r1
 c004496:	6053      	str	r3, [r2, #4]
}
 c004498:	bd10      	pop	{r4, pc}

0c00449a <UART_WaitOnFlagUntilTimeout>:
{
 c00449a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00449e:	4604      	mov	r4, r0
 c0044a0:	460e      	mov	r6, r1
 c0044a2:	4615      	mov	r5, r2
 c0044a4:	461f      	mov	r7, r3
 c0044a6:	f8dd 8018 	ldr.w	r8, [sp, #24]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 c0044aa:	6822      	ldr	r2, [r4, #0]
 c0044ac:	69d3      	ldr	r3, [r2, #28]
 c0044ae:	ea36 0303 	bics.w	r3, r6, r3
 c0044b2:	bf0c      	ite	eq
 c0044b4:	2301      	moveq	r3, #1
 c0044b6:	2300      	movne	r3, #0
 c0044b8:	42ab      	cmp	r3, r5
 c0044ba:	d001      	beq.n	c0044c0 <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 c0044bc:	2000      	movs	r0, #0
 c0044be:	e01c      	b.n	c0044fa <UART_WaitOnFlagUntilTimeout+0x60>
    if (Timeout != HAL_MAX_DELAY)
 c0044c0:	f1b8 3fff 	cmp.w	r8, #4294967295
 c0044c4:	d0f2      	beq.n	c0044ac <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c0044c6:	f7fd fe1f 	bl	c002108 <HAL_GetTick>
 c0044ca:	1bc0      	subs	r0, r0, r7
 c0044cc:	4540      	cmp	r0, r8
 c0044ce:	6820      	ldr	r0, [r4, #0]
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 c0044d0:	6803      	ldr	r3, [r0, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c0044d2:	d802      	bhi.n	c0044da <UART_WaitOnFlagUntilTimeout+0x40>
 c0044d4:	f1b8 0f00 	cmp.w	r8, #0
 c0044d8:	d111      	bne.n	c0044fe <UART_WaitOnFlagUntilTimeout+0x64>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 c0044da:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 c0044de:	6003      	str	r3, [r0, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c0044e0:	6883      	ldr	r3, [r0, #8]
 c0044e2:	f023 0301 	bic.w	r3, r3, #1
 c0044e6:	6083      	str	r3, [r0, #8]
        huart->gState = HAL_UART_STATE_READY;
 c0044e8:	2320      	movs	r3, #32
 c0044ea:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 c0044ee:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          __HAL_UNLOCK(huart);
 c0044f2:	2300      	movs	r3, #0
          return HAL_TIMEOUT;
 c0044f4:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 c0044f6:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
}
 c0044fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 c0044fe:	075a      	lsls	r2, r3, #29
 c004500:	d5d3      	bpl.n	c0044aa <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 c004502:	69c3      	ldr	r3, [r0, #28]
 c004504:	051b      	lsls	r3, r3, #20
 c004506:	d5d0      	bpl.n	c0044aa <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 c004508:	f44f 6300 	mov.w	r3, #2048	; 0x800
 c00450c:	6203      	str	r3, [r0, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 c00450e:	6803      	ldr	r3, [r0, #0]
 c004510:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 c004514:	6003      	str	r3, [r0, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c004516:	6883      	ldr	r3, [r0, #8]
 c004518:	f023 0301 	bic.w	r3, r3, #1
 c00451c:	6083      	str	r3, [r0, #8]
          huart->gState = HAL_UART_STATE_READY;
 c00451e:	2320      	movs	r3, #32
 c004520:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 c004524:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 c004528:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 c00452c:	e7e1      	b.n	c0044f2 <UART_WaitOnFlagUntilTimeout+0x58>

0c00452e <HAL_UART_Transmit>:
{
 c00452e:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c004532:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 c004534:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 c004538:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 c00453a:	2b20      	cmp	r3, #32
{
 c00453c:	460e      	mov	r6, r1
 c00453e:	4617      	mov	r7, r2
  if (huart->gState == HAL_UART_STATE_READY)
 c004540:	d150      	bne.n	c0045e4 <HAL_UART_Transmit+0xb6>
    if ((pData == NULL) || (Size == 0U))
 c004542:	2900      	cmp	r1, #0
 c004544:	d04c      	beq.n	c0045e0 <HAL_UART_Transmit+0xb2>
 c004546:	2a00      	cmp	r2, #0
 c004548:	d04a      	beq.n	c0045e0 <HAL_UART_Transmit+0xb2>
    __HAL_LOCK(huart);
 c00454a:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 c00454e:	2b01      	cmp	r3, #1
 c004550:	d048      	beq.n	c0045e4 <HAL_UART_Transmit+0xb6>
 c004552:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 c004554:	2500      	movs	r5, #0
    __HAL_LOCK(huart);
 c004556:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
 c00455a:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 c00455c:	f8c0 508c 	str.w	r5, [r0, #140]	; 0x8c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 c004560:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    tickstart = HAL_GetTick();
 c004564:	f7fd fdd0 	bl	c002108 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c004568:	68a2      	ldr	r2, [r4, #8]
    tickstart = HAL_GetTick();
 c00456a:	4603      	mov	r3, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c00456c:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    huart->TxXferSize  = Size;
 c004570:	f8a4 7054 	strh.w	r7, [r4, #84]	; 0x54
    huart->TxXferCount = Size;
 c004574:	f8a4 7056 	strh.w	r7, [r4, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c004578:	d103      	bne.n	c004582 <HAL_UART_Transmit+0x54>
 c00457a:	6922      	ldr	r2, [r4, #16]
 c00457c:	b90a      	cbnz	r2, c004582 <HAL_UART_Transmit+0x54>
 c00457e:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 c004580:	4616      	mov	r6, r2
    __HAL_UNLOCK(huart);
 c004582:	2200      	movs	r2, #0
 c004584:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
    while (huart->TxXferCount > 0U)
 c004588:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c00458c:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 c004590:	b292      	uxth	r2, r2
 c004592:	b942      	cbnz	r2, c0045a6 <HAL_UART_Transmit+0x78>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 c004594:	2140      	movs	r1, #64	; 0x40
 c004596:	4620      	mov	r0, r4
 c004598:	f7ff ff7f 	bl	c00449a <UART_WaitOnFlagUntilTimeout>
 c00459c:	b958      	cbnz	r0, c0045b6 <HAL_UART_Transmit+0x88>
    huart->gState = HAL_UART_STATE_READY;
 c00459e:	2320      	movs	r3, #32
 c0045a0:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    return HAL_OK;
 c0045a4:	e008      	b.n	c0045b8 <HAL_UART_Transmit+0x8a>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c0045a6:	2200      	movs	r2, #0
 c0045a8:	2180      	movs	r1, #128	; 0x80
 c0045aa:	4620      	mov	r0, r4
 c0045ac:	9303      	str	r3, [sp, #12]
 c0045ae:	f7ff ff74 	bl	c00449a <UART_WaitOnFlagUntilTimeout>
 c0045b2:	9b03      	ldr	r3, [sp, #12]
 c0045b4:	b118      	cbz	r0, c0045be <HAL_UART_Transmit+0x90>
        return HAL_TIMEOUT;
 c0045b6:	2003      	movs	r0, #3
}
 c0045b8:	b004      	add	sp, #16
 c0045ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (pdata8bits == NULL)
 c0045be:	6821      	ldr	r1, [r4, #0]
 c0045c0:	b95e      	cbnz	r6, c0045da <HAL_UART_Transmit+0xac>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 c0045c2:	f835 2b02 	ldrh.w	r2, [r5], #2
 c0045c6:	f3c2 0208 	ubfx	r2, r2, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 c0045ca:	628a      	str	r2, [r1, #40]	; 0x28
      huart->TxXferCount--;
 c0045cc:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
 c0045d0:	3a01      	subs	r2, #1
 c0045d2:	b292      	uxth	r2, r2
 c0045d4:	f8a4 2056 	strh.w	r2, [r4, #86]	; 0x56
 c0045d8:	e7d6      	b.n	c004588 <HAL_UART_Transmit+0x5a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 c0045da:	f816 2b01 	ldrb.w	r2, [r6], #1
 c0045de:	e7f4      	b.n	c0045ca <HAL_UART_Transmit+0x9c>
      return  HAL_ERROR;
 c0045e0:	2001      	movs	r0, #1
 c0045e2:	e7e9      	b.n	c0045b8 <HAL_UART_Transmit+0x8a>
    return HAL_BUSY;
 c0045e4:	2002      	movs	r0, #2
 c0045e6:	e7e7      	b.n	c0045b8 <HAL_UART_Transmit+0x8a>

0c0045e8 <UART_CheckIdleState>:
{
 c0045e8:	b530      	push	{r4, r5, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c0045ea:	2500      	movs	r5, #0
{
 c0045ec:	4604      	mov	r4, r0
 c0045ee:	b085      	sub	sp, #20
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c0045f0:	f8c0 508c 	str.w	r5, [r0, #140]	; 0x8c
  tickstart = HAL_GetTick();
 c0045f4:	f7fd fd88 	bl	c002108 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 c0045f8:	6822      	ldr	r2, [r4, #0]
  tickstart = HAL_GetTick();
 c0045fa:	4603      	mov	r3, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 c0045fc:	6812      	ldr	r2, [r2, #0]
 c0045fe:	0711      	lsls	r1, r2, #28
 c004600:	d417      	bmi.n	c004632 <UART_CheckIdleState+0x4a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 c004602:	6822      	ldr	r2, [r4, #0]
 c004604:	6812      	ldr	r2, [r2, #0]
 c004606:	0752      	lsls	r2, r2, #29
 c004608:	d509      	bpl.n	c00461e <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 c00460a:	f06f 427e 	mvn.w	r2, #4261412864	; 0xfe000000
 c00460e:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 c004612:	9200      	str	r2, [sp, #0]
 c004614:	4620      	mov	r0, r4
 c004616:	2200      	movs	r2, #0
 c004618:	f7ff ff3f 	bl	c00449a <UART_WaitOnFlagUntilTimeout>
 c00461c:	b9b0      	cbnz	r0, c00464c <UART_CheckIdleState+0x64>
  huart->gState = HAL_UART_STATE_READY;
 c00461e:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c004620:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 c004622:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 c004626:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 c00462a:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c00462e:	66e0      	str	r0, [r4, #108]	; 0x6c
  return HAL_OK;
 c004630:	e00d      	b.n	c00464e <UART_CheckIdleState+0x66>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 c004632:	f06f 427e 	mvn.w	r2, #4261412864	; 0xfe000000
 c004636:	9003      	str	r0, [sp, #12]
 c004638:	9200      	str	r2, [sp, #0]
 c00463a:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 c00463e:	462a      	mov	r2, r5
 c004640:	4620      	mov	r0, r4
 c004642:	f7ff ff2a 	bl	c00449a <UART_WaitOnFlagUntilTimeout>
 c004646:	9b03      	ldr	r3, [sp, #12]
 c004648:	2800      	cmp	r0, #0
 c00464a:	d0da      	beq.n	c004602 <UART_CheckIdleState+0x1a>
      return HAL_TIMEOUT;
 c00464c:	2003      	movs	r0, #3
}
 c00464e:	b005      	add	sp, #20
 c004650:	bd30      	pop	{r4, r5, pc}

0c004652 <HAL_UART_Init>:
{
 c004652:	b510      	push	{r4, lr}
  if (huart == NULL)
 c004654:	4604      	mov	r4, r0
 c004656:	b350      	cbz	r0, c0046ae <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 c004658:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 c00465c:	b91b      	cbnz	r3, c004666 <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 c00465e:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 c004662:	f7ff fbad 	bl	c003dc0 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 c004666:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 c004668:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 c00466a:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 c00466e:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 c004670:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 c004672:	f023 0301 	bic.w	r3, r3, #1
 c004676:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 c004678:	f7ff fd54 	bl	c004124 <UART_SetConfig>
 c00467c:	2801      	cmp	r0, #1
 c00467e:	d016      	beq.n	c0046ae <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 c004680:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 c004682:	b113      	cbz	r3, c00468a <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 c004684:	4620      	mov	r0, r4
 c004686:	f7ff feb3 	bl	c0043f0 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 c00468a:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 c00468c:	4620      	mov	r0, r4
}
 c00468e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 c004692:	685a      	ldr	r2, [r3, #4]
 c004694:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 c004698:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 c00469a:	689a      	ldr	r2, [r3, #8]
 c00469c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 c0046a0:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 c0046a2:	681a      	ldr	r2, [r3, #0]
 c0046a4:	f042 0201 	orr.w	r2, r2, #1
 c0046a8:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 c0046aa:	f7ff bf9d 	b.w	c0045e8 <UART_CheckIdleState>
}
 c0046ae:	2001      	movs	r0, #1
 c0046b0:	bd10      	pop	{r4, pc}
	...

0c0046b4 <UART_Start_Receive_IT>:
  huart->RxISR       = NULL;
 c0046b4:	2300      	movs	r3, #0
{
 c0046b6:	b510      	push	{r4, lr}
  huart->pRxBuffPtr  = pData;
 c0046b8:	6581      	str	r1, [r0, #88]	; 0x58
  UART_MASK_COMPUTATION(huart);
 c0046ba:	6881      	ldr	r1, [r0, #8]
  huart->RxXferSize  = Size;
 c0046bc:	f8a0 205c 	strh.w	r2, [r0, #92]	; 0x5c
  UART_MASK_COMPUTATION(huart);
 c0046c0:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
  huart->RxXferCount = Size;
 c0046c4:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
  huart->RxISR       = NULL;
 c0046c8:	6703      	str	r3, [r0, #112]	; 0x70
  UART_MASK_COMPUTATION(huart);
 c0046ca:	d131      	bne.n	c004730 <UART_Start_Receive_IT+0x7c>
 c0046cc:	6903      	ldr	r3, [r0, #16]
 c0046ce:	bb6b      	cbnz	r3, c00472c <UART_Start_Receive_IT+0x78>
 c0046d0:	f240 13ff 	movw	r3, #511	; 0x1ff
 c0046d4:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c0046d8:	2300      	movs	r3, #0
 c0046da:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 c0046de:	2322      	movs	r3, #34	; 0x22
 c0046e0:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c0046e4:	6803      	ldr	r3, [r0, #0]
 c0046e6:	689c      	ldr	r4, [r3, #8]
 c0046e8:	f044 0401 	orr.w	r4, r4, #1
 c0046ec:	609c      	str	r4, [r3, #8]
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 c0046ee:	6e44      	ldr	r4, [r0, #100]	; 0x64
 c0046f0:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
 c0046f4:	d12c      	bne.n	c004750 <UART_Start_Receive_IT+0x9c>
 c0046f6:	f8b0 4068 	ldrh.w	r4, [r0, #104]	; 0x68
 c0046fa:	4294      	cmp	r4, r2
 c0046fc:	d828      	bhi.n	c004750 <UART_Start_Receive_IT+0x9c>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c0046fe:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 c004702:	d123      	bne.n	c00474c <UART_Start_Receive_IT+0x98>
 c004704:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 c004706:	4a1c      	ldr	r2, [pc, #112]	; (c004778 <UART_Start_Receive_IT+0xc4>)
 c004708:	491c      	ldr	r1, [pc, #112]	; (c00477c <UART_Start_Receive_IT+0xc8>)
 c00470a:	2c00      	cmp	r4, #0
 c00470c:	bf08      	it	eq
 c00470e:	460a      	moveq	r2, r1
 c004710:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 c004712:	2200      	movs	r2, #0
 c004714:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c004718:	681a      	ldr	r2, [r3, #0]
 c00471a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 c00471e:	601a      	str	r2, [r3, #0]
    SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c004720:	689a      	ldr	r2, [r3, #8]
 c004722:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c004726:	609a      	str	r2, [r3, #8]
}
 c004728:	2000      	movs	r0, #0
 c00472a:	bd10      	pop	{r4, pc}
  UART_MASK_COMPUTATION(huart);
 c00472c:	23ff      	movs	r3, #255	; 0xff
 c00472e:	e7d1      	b.n	c0046d4 <UART_Start_Receive_IT+0x20>
 c004730:	b921      	cbnz	r1, c00473c <UART_Start_Receive_IT+0x88>
 c004732:	6903      	ldr	r3, [r0, #16]
 c004734:	2b00      	cmp	r3, #0
 c004736:	d0f9      	beq.n	c00472c <UART_Start_Receive_IT+0x78>
 c004738:	237f      	movs	r3, #127	; 0x7f
 c00473a:	e7cb      	b.n	c0046d4 <UART_Start_Receive_IT+0x20>
 c00473c:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
 c004740:	d1c8      	bne.n	c0046d4 <UART_Start_Receive_IT+0x20>
 c004742:	6903      	ldr	r3, [r0, #16]
 c004744:	2b00      	cmp	r3, #0
 c004746:	d0f7      	beq.n	c004738 <UART_Start_Receive_IT+0x84>
 c004748:	233f      	movs	r3, #63	; 0x3f
 c00474a:	e7c3      	b.n	c0046d4 <UART_Start_Receive_IT+0x20>
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 c00474c:	4a0a      	ldr	r2, [pc, #40]	; (c004778 <UART_Start_Receive_IT+0xc4>)
 c00474e:	e7df      	b.n	c004710 <UART_Start_Receive_IT+0x5c>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c004750:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 c004754:	d10e      	bne.n	c004774 <UART_Start_Receive_IT+0xc0>
 c004756:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT;
 c004758:	4a09      	ldr	r2, [pc, #36]	; (c004780 <UART_Start_Receive_IT+0xcc>)
 c00475a:	490a      	ldr	r1, [pc, #40]	; (c004784 <UART_Start_Receive_IT+0xd0>)
 c00475c:	2c00      	cmp	r4, #0
 c00475e:	bf08      	it	eq
 c004760:	460a      	moveq	r2, r1
 c004762:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 c004764:	2200      	movs	r2, #0
 c004766:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 c00476a:	681a      	ldr	r2, [r3, #0]
 c00476c:	f442 7290 	orr.w	r2, r2, #288	; 0x120
 c004770:	601a      	str	r2, [r3, #0]
 c004772:	e7d9      	b.n	c004728 <UART_Start_Receive_IT+0x74>
      huart->RxISR = UART_RxISR_8BIT;
 c004774:	4a02      	ldr	r2, [pc, #8]	; (c004780 <UART_Start_Receive_IT+0xcc>)
 c004776:	e7f4      	b.n	c004762 <UART_Start_Receive_IT+0xae>
 c004778:	0c003eb9 	.word	0x0c003eb9
 c00477c:	0c003ff1 	.word	0x0c003ff1
 c004780:	0c003dc9 	.word	0x0c003dc9
 c004784:	0c003e43 	.word	0x0c003e43

0c004788 <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 c004788:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
{
 c00478c:	b410      	push	{r4}
  if (huart->RxState == HAL_UART_STATE_READY)
 c00478e:	2b20      	cmp	r3, #32
 c004790:	d11d      	bne.n	c0047ce <HAL_UART_Receive_IT+0x46>
    if ((pData == NULL) || (Size == 0U))
 c004792:	b1c1      	cbz	r1, c0047c6 <HAL_UART_Receive_IT+0x3e>
 c004794:	b1ba      	cbz	r2, c0047c6 <HAL_UART_Receive_IT+0x3e>
    __HAL_LOCK(huart);
 c004796:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 c00479a:	2b01      	cmp	r3, #1
 c00479c:	d017      	beq.n	c0047ce <HAL_UART_Receive_IT+0x46>
 c00479e:	2301      	movs	r3, #1
 c0047a0:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c0047a4:	2300      	movs	r3, #0
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c0047a6:	4c0b      	ldr	r4, [pc, #44]	; (c0047d4 <HAL_UART_Receive_IT+0x4c>)
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c0047a8:	66c3      	str	r3, [r0, #108]	; 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c0047aa:	6803      	ldr	r3, [r0, #0]
 c0047ac:	42a3      	cmp	r3, r4
 c0047ae:	d006      	beq.n	c0047be <HAL_UART_Receive_IT+0x36>
      if(READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 c0047b0:	685c      	ldr	r4, [r3, #4]
 c0047b2:	0224      	lsls	r4, r4, #8
        SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 c0047b4:	bf42      	ittt	mi
 c0047b6:	681c      	ldrmi	r4, [r3, #0]
 c0047b8:	f044 6480 	orrmi.w	r4, r4, #67108864	; 0x4000000
 c0047bc:	601c      	strmi	r4, [r3, #0]
}
 c0047be:	f85d 4b04 	ldr.w	r4, [sp], #4
    return(UART_Start_Receive_IT(huart, pData, Size));
 c0047c2:	f7ff bf77 	b.w	c0046b4 <UART_Start_Receive_IT>
      return HAL_ERROR;
 c0047c6:	2001      	movs	r0, #1
}
 c0047c8:	f85d 4b04 	ldr.w	r4, [sp], #4
 c0047cc:	4770      	bx	lr
    return HAL_BUSY;
 c0047ce:	2002      	movs	r0, #2
 c0047d0:	e7fa      	b.n	c0047c8 <HAL_UART_Receive_IT+0x40>
 c0047d2:	bf00      	nop
 c0047d4:	50008000 	.word	0x50008000

0c0047d8 <aes_gen_tables>:
#define MUL(x,y) ( ( (x) && (y) ) ? pow[(log[(x)]+log[(y)]) % 255] : 0 )

static int aes_init_done = 0;

static void aes_gen_tables( void )
{
 c0047d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0047dc:	f6ad 0d24 	subw	sp, sp, #2084	; 0x824
 c0047e0:	ac08      	add	r4, sp, #32
    int log[256];

    /*
     * compute pow and log tables over GF(2^8)
     */
    for( i = 0, x = 1; i < 256; i++ )
 c0047e2:	2301      	movs	r3, #1
 c0047e4:	2200      	movs	r2, #0
 c0047e6:	4626      	mov	r6, r4
    {
        pow[i] = x;
        log[x] = i;
 c0047e8:	f50d 6184 	add.w	r1, sp, #1056	; 0x420
        x = ( x ^ XTIME( x ) ) & 0xFF;
 c0047ec:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 c0047f0:	bf18      	it	ne
 c0047f2:	201b      	movne	r0, #27
        log[x] = i;
 c0047f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        pow[i] = x;
 c0047f8:	f844 3b04 	str.w	r3, [r4], #4
    for( i = 0, x = 1; i < 256; i++ )
 c0047fc:	3201      	adds	r2, #1
        x = ( x ^ XTIME( x ) ) & 0xFF;
 c0047fe:	ea83 0343 	eor.w	r3, r3, r3, lsl #1
 c004802:	4043      	eors	r3, r0
    for( i = 0, x = 1; i < 256; i++ )
 c004804:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
        x = ( x ^ XTIME( x ) ) & 0xFF;
 c004808:	b2db      	uxtb	r3, r3
    for( i = 0, x = 1; i < 256; i++ )
 c00480a:	d1ef      	bne.n	c0047ec <aes_gen_tables+0x14>
    }

    /*
     * calculate the round constants
     */
    for( i = 0, x = 1; i < 10; i++ )
 c00480c:	2301      	movs	r3, #1
 c00480e:	2200      	movs	r2, #0
 c004810:	4c6c      	ldr	r4, [pc, #432]	; (c0049c4 <aes_gen_tables+0x1ec>)
    {
        RCON[i] = (uint32_t) x;
        x = XTIME( x ) & 0xFF;
 c004812:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 c004816:	bf18      	it	ne
 c004818:	201b      	movne	r0, #27
    for( i = 0, x = 1; i < 10; i++ )
 c00481a:	3201      	adds	r2, #1
        RCON[i] = (uint32_t) x;
 c00481c:	f844 3b04 	str.w	r3, [r4], #4
    for( i = 0, x = 1; i < 10; i++ )
 c004820:	2a0a      	cmp	r2, #10
        x = XTIME( x ) & 0xFF;
 c004822:	ea80 0343 	eor.w	r3, r0, r3, lsl #1
 c004826:	b2db      	uxtb	r3, r3
    for( i = 0, x = 1; i < 10; i++ )
 c004828:	d1f3      	bne.n	c004812 <aes_gen_tables+0x3a>
    }

    /*
     * generate the forward and reverse S-boxes
     */
    FSb[0x00] = 0x63;
 c00482a:	2363      	movs	r3, #99	; 0x63
 c00482c:	4d66      	ldr	r5, [pc, #408]	; (c0049c8 <aes_gen_tables+0x1f0>)
    RSb[0x63] = 0x00;

    for( i = 1; i < 256; i++ )
 c00482e:	2001      	movs	r0, #1
    FSb[0x00] = 0x63;
 c004830:	702b      	strb	r3, [r5, #0]
    RSb[0x63] = 0x00;
 c004832:	2300      	movs	r3, #0
 c004834:	4c65      	ldr	r4, [pc, #404]	; (c0049cc <aes_gen_tables+0x1f4>)
 c004836:	f884 3063 	strb.w	r3, [r4, #99]	; 0x63
    {
        x = pow[255 - log[i]];
 c00483a:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 c00483e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 c004842:	f856 8023 	ldr.w	r8, [r6, r3, lsl #2]

        y  = x; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
 c004846:	ea4f 12e8 	mov.w	r2, r8, asr #7
 c00484a:	ea42 0248 	orr.w	r2, r2, r8, lsl #1
 c00484e:	fa5f fe82 	uxtb.w	lr, r2
        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
 c004852:	f3c2 12c0 	ubfx	r2, r2, #7, #1
 c004856:	ea42 024e 	orr.w	r2, r2, lr, lsl #1
 c00485a:	fa5f fc82 	uxtb.w	ip, r2
        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
 c00485e:	f3c2 12c0 	ubfx	r2, r2, #7, #1
 c004862:	ea42 024c 	orr.w	r2, r2, ip, lsl #1
 c004866:	b2d7      	uxtb	r7, r2
        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
 c004868:	f3c2 12c0 	ubfx	r2, r2, #7, #1
 c00486c:	ea42 0247 	orr.w	r2, r2, r7, lsl #1
 c004870:	b2d3      	uxtb	r3, r2
 c004872:	ea83 0308 	eor.w	r3, r3, r8
 c004876:	ea83 030e 	eor.w	r3, r3, lr
 c00487a:	ea83 030c 	eor.w	r3, r3, ip
 c00487e:	407b      	eors	r3, r7
        x ^= y ^ 0x63;
 c004880:	f083 0363 	eor.w	r3, r3, #99	; 0x63

        FSb[i] = (unsigned char) x;
 c004884:	542b      	strb	r3, [r5, r0]
        RSb[x] = (unsigned char) i;
 c004886:	54e0      	strb	r0, [r4, r3]
    for( i = 1; i < 256; i++ )
 c004888:	3001      	adds	r0, #1
 c00488a:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 c00488e:	d1d4      	bne.n	c00483a <aes_gen_tables+0x62>
        FT3[i] = ROTL8( FT2[i] );
#endif /* !MBEDTLS_AES_FEWER_TABLES */

        x = RSb[i];

        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
 c004890:	24ff      	movs	r4, #255	; 0xff
 c004892:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 c004894:	484c      	ldr	r0, [pc, #304]	; (c0049c8 <aes_gen_tables+0x1f0>)
 c004896:	9303      	str	r3, [sp, #12]
                 ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^
 c004898:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 c00489a:	f8df c148 	ldr.w	ip, [pc, #328]	; c0049e4 <aes_gen_tables+0x20c>
 c00489e:	9304      	str	r3, [sp, #16]
                 ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^
 c0048a0:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 c0048a2:	4f4b      	ldr	r7, [pc, #300]	; (c0049d0 <aes_gen_tables+0x1f8>)
 c0048a4:	9306      	str	r3, [sp, #24]
                 ( (uint32_t) MUL( 0x0B, x ) << 24 );
 c0048a6:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 c0048a8:	4e4a      	ldr	r6, [pc, #296]	; (c0049d4 <aes_gen_tables+0x1fc>)
 c0048aa:	9307      	str	r3, [sp, #28]
 c0048ac:	4b4a      	ldr	r3, [pc, #296]	; (c0049d8 <aes_gen_tables+0x200>)
 c0048ae:	f8df a138 	ldr.w	sl, [pc, #312]	; c0049e8 <aes_gen_tables+0x210>
 c0048b2:	9302      	str	r3, [sp, #8]
 c0048b4:	4b49      	ldr	r3, [pc, #292]	; (c0049dc <aes_gen_tables+0x204>)
 c0048b6:	f8df 9134 	ldr.w	r9, [pc, #308]	; c0049ec <aes_gen_tables+0x214>
 c0048ba:	f8df 8134 	ldr.w	r8, [pc, #308]	; c0049f0 <aes_gen_tables+0x218>
 c0048be:	f8df e10c 	ldr.w	lr, [pc, #268]	; c0049cc <aes_gen_tables+0x1f4>
 c0048c2:	9301      	str	r3, [sp, #4]
        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
 c0048c4:	f50d 6584 	add.w	r5, sp, #1056	; 0x420
        x = FSb[i];
 c0048c8:	f810 3b01 	ldrb.w	r3, [r0], #1
        y = XTIME( x ) & 0xFF;
 c0048cc:	f013 0f80 	tst.w	r3, #128	; 0x80
 c0048d0:	bf14      	ite	ne
 c0048d2:	221b      	movne	r2, #27
 c0048d4:	2200      	moveq	r2, #0
                 ( (uint32_t) x << 16 ) ^
 c0048d6:	0419      	lsls	r1, r3, #16
        y = XTIME( x ) & 0xFF;
 c0048d8:	ea82 0243 	eor.w	r2, r2, r3, lsl #1
 c0048dc:	b2d2      	uxtb	r2, r2
                 ( (uint32_t) x <<  8 ) ^
 c0048de:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 c0048e2:	4051      	eors	r1, r2
        z =  ( y ^ x ) & 0xFF;
 c0048e4:	4053      	eors	r3, r2
                 ( (uint32_t) x << 16 ) ^
 c0048e6:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
        FT0[i] = ( (uint32_t) y       ) ^
 c0048ea:	9b01      	ldr	r3, [sp, #4]
 c0048ec:	f843 1b04 	str.w	r1, [r3], #4
 c0048f0:	9301      	str	r3, [sp, #4]
        FT1[i] = ROTL8( FT0[i] );
 c0048f2:	ea4f 6331 	mov.w	r3, r1, ror #24
 c0048f6:	f84a 3b04 	str.w	r3, [sl], #4
        FT2[i] = ROTL8( FT1[i] );
 c0048fa:	ea4f 4331 	mov.w	r3, r1, ror #16
 c0048fe:	f849 3b04 	str.w	r3, [r9], #4
        x = RSb[i];
 c004902:	f81e 3b01 	ldrb.w	r3, [lr], #1
        FT3[i] = ROTL8( FT2[i] );
 c004906:	ea4f 2131 	mov.w	r1, r1, ror #8
 c00490a:	f848 1b04 	str.w	r1, [r8], #4
        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
 c00490e:	2b00      	cmp	r3, #0
 c004910:	d052      	beq.n	c0049b8 <aes_gen_tables+0x1e0>
 c004912:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
 c004916:	9903      	ldr	r1, [sp, #12]
 c004918:	4411      	add	r1, r2
 c00491a:	fb91 fbf4 	sdiv	fp, r1, r4
 c00491e:	ebcb 2b0b 	rsb	fp, fp, fp, lsl #8
 c004922:	eba1 0b0b 	sub.w	fp, r1, fp
 c004926:	a908      	add	r1, sp, #32
 c004928:	f851 b02b 	ldr.w	fp, [r1, fp, lsl #2]
                 ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^
 c00492c:	9904      	ldr	r1, [sp, #16]
 c00492e:	440a      	add	r2, r1
 c004930:	fb92 f1f4 	sdiv	r1, r2, r4
 c004934:	ebc1 2101 	rsb	r1, r1, r1, lsl #8
 c004938:	1a51      	subs	r1, r2, r1
 c00493a:	aa08      	add	r2, sp, #32
 c00493c:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 c004940:	0212      	lsls	r2, r2, #8
        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
 c004942:	ea82 020b 	eor.w	r2, r2, fp
 c004946:	9205      	str	r2, [sp, #20]
                 ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^
 c004948:	2b00      	cmp	r3, #0
 c00494a:	d038      	beq.n	c0049be <aes_gen_tables+0x1e6>
 c00494c:	9906      	ldr	r1, [sp, #24]
 c00494e:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
 c004952:	440a      	add	r2, r1
 c004954:	fb92 fbf4 	sdiv	fp, r2, r4
 c004958:	ebcb 2b0b 	rsb	fp, fp, fp, lsl #8
 c00495c:	eba2 010b 	sub.w	r1, r2, fp
 c004960:	aa08      	add	r2, sp, #32
 c004962:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 c004966:	0409      	lsls	r1, r1, #16
                 ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^
 c004968:	9a05      	ldr	r2, [sp, #20]
 c00496a:	404a      	eors	r2, r1
                 ( (uint32_t) MUL( 0x0B, x ) << 24 );
 c00496c:	b163      	cbz	r3, c004988 <aes_gen_tables+0x1b0>
 c00496e:	9907      	ldr	r1, [sp, #28]
 c004970:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 c004974:	440b      	add	r3, r1
 c004976:	fb93 f1f4 	sdiv	r1, r3, r4
 c00497a:	ebc1 2101 	rsb	r1, r1, r1, lsl #8
 c00497e:	1a59      	subs	r1, r3, r1
 c004980:	ab08      	add	r3, sp, #32
 c004982:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 c004986:	061b      	lsls	r3, r3, #24
                 ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^
 c004988:	405a      	eors	r2, r3
        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
 c00498a:	9b02      	ldr	r3, [sp, #8]
 c00498c:	f843 2b04 	str.w	r2, [r3], #4
 c004990:	9302      	str	r3, [sp, #8]

#if !defined(MBEDTLS_AES_FEWER_TABLES)
        RT1[i] = ROTL8( RT0[i] );
 c004992:	ea4f 6332 	mov.w	r3, r2, ror #24
 c004996:	f84c 3b04 	str.w	r3, [ip], #4
        RT2[i] = ROTL8( RT1[i] );
 c00499a:	ea4f 4332 	mov.w	r3, r2, ror #16
 c00499e:	f847 3b04 	str.w	r3, [r7], #4
    for( i = 0; i < 256; i++ )
 c0049a2:	4b0f      	ldr	r3, [pc, #60]	; (c0049e0 <aes_gen_tables+0x208>)
        RT3[i] = ROTL8( RT2[i] );
 c0049a4:	ea4f 2232 	mov.w	r2, r2, ror #8
    for( i = 0; i < 256; i++ )
 c0049a8:	4283      	cmp	r3, r0
        RT3[i] = ROTL8( RT2[i] );
 c0049aa:	f846 2b04 	str.w	r2, [r6], #4
    for( i = 0; i < 256; i++ )
 c0049ae:	d18b      	bne.n	c0048c8 <aes_gen_tables+0xf0>
#endif /* !MBEDTLS_AES_FEWER_TABLES */
    }
}
 c0049b0:	f60d 0d24 	addw	sp, sp, #2084	; 0x824
 c0049b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
 c0049b8:	469b      	mov	fp, r3
                 ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^
 c0049ba:	461a      	mov	r2, r3
 c0049bc:	e7c1      	b.n	c004942 <aes_gen_tables+0x16a>
                 ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^
 c0049be:	4619      	mov	r1, r3
 c0049c0:	e7d2      	b.n	c004968 <aes_gen_tables+0x190>
 c0049c2:	bf00      	nop
 c0049c4:	30031374 	.word	0x30031374
 c0049c8:	30030274 	.word	0x30030274
 c0049cc:	3003139c 	.word	0x3003139c
 c0049d0:	30031c9c 	.word	0x30031c9c
 c0049d4:	3003209c 	.word	0x3003209c
 c0049d8:	3003149c 	.word	0x3003149c
 c0049dc:	30030374 	.word	0x30030374
 c0049e0:	30030374 	.word	0x30030374
 c0049e4:	3003189c 	.word	0x3003189c
 c0049e8:	30030774 	.word	0x30030774
 c0049ec:	30030b74 	.word	0x30030b74
 c0049f0:	30030f74 	.word	0x30030f74

0c0049f4 <mbedtls_aes_init>:

void mbedtls_aes_init( mbedtls_aes_context *ctx )
{
    AES_VALIDATE( ctx != NULL );

    memset( ctx, 0, sizeof( mbedtls_aes_context ) );
 c0049f4:	f44f 728c 	mov.w	r2, #280	; 0x118
 c0049f8:	2100      	movs	r1, #0
 c0049fa:	f004 b8d4 	b.w	c008ba6 <memset>

0c0049fe <mbedtls_aes_free>:
}

void mbedtls_aes_free( mbedtls_aes_context *ctx )
{
    if( ctx == NULL )
 c0049fe:	b118      	cbz	r0, c004a08 <mbedtls_aes_free+0xa>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_aes_context ) );
 c004a00:	f44f 718c 	mov.w	r1, #280	; 0x118
 c004a04:	f002 b9e6 	b.w	c006dd4 <mbedtls_platform_zeroize>
}
 c004a08:	4770      	bx	lr
	...

0c004a0c <mbedtls_aes_setkey_enc>:
    uint32_t *RK;

    AES_VALIDATE_RET( ctx != NULL );
    AES_VALIDATE_RET( key != NULL );

    switch( keybits )
 c004a0c:	2ac0      	cmp	r2, #192	; 0xc0
{
 c004a0e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c004a10:	4604      	mov	r4, r0
 c004a12:	460d      	mov	r5, r1
 c004a14:	4616      	mov	r6, r2
    switch( keybits )
 c004a16:	d04a      	beq.n	c004aae <mbedtls_aes_setkey_enc+0xa2>
 c004a18:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 c004a1c:	d049      	beq.n	c004ab2 <mbedtls_aes_setkey_enc+0xa6>
 c004a1e:	2a80      	cmp	r2, #128	; 0x80
 c004a20:	f040 80d1 	bne.w	c004bc6 <mbedtls_aes_setkey_enc+0x1ba>
    {
        case 128: ctx->nr = 10; break;
 c004a24:	230a      	movs	r3, #10
        case 256: ctx->nr = 14; break;
        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
    }

#if !defined(MBEDTLS_AES_ROM_TABLES)
    if( aes_init_done == 0 )
 c004a26:	4f69      	ldr	r7, [pc, #420]	; (c004bcc <mbedtls_aes_setkey_enc+0x1c0>)
        case 256: ctx->nr = 14; break;
 c004a28:	6023      	str	r3, [r4, #0]
    if( aes_init_done == 0 )
 c004a2a:	683b      	ldr	r3, [r7, #0]
 c004a2c:	b91b      	cbnz	r3, c004a36 <mbedtls_aes_setkey_enc+0x2a>
    {
        aes_gen_tables();
 c004a2e:	f7ff fed3 	bl	c0047d8 <aes_gen_tables>
        aes_init_done = 1;
 c004a32:	2301      	movs	r3, #1
 c004a34:	603b      	str	r3, [r7, #0]

    if( aes_padlock_ace )
        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
    else
#endif
    ctx->rk = RK = ctx->buf;
 c004a36:	4622      	mov	r2, r4
 c004a38:	4629      	mov	r1, r5
 c004a3a:	f104 0308 	add.w	r3, r4, #8
#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );
#endif

    for( i = 0; i < ( keybits >> 5 ); i++ )
 c004a3e:	0976      	lsrs	r6, r6, #5
    ctx->rk = RK = ctx->buf;
 c004a40:	f842 3f04 	str.w	r3, [r2, #4]!
    for( i = 0; i < ( keybits >> 5 ); i++ )
 c004a44:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 c004a48:	428e      	cmp	r6, r1
 c004a4a:	d134      	bne.n	c004ab6 <mbedtls_aes_setkey_enc+0xaa>
    {
        GET_UINT32_LE( RK[i], key, i << 2 );
    }

    switch( ctx->nr )
 c004a4c:	6823      	ldr	r3, [r4, #0]
 c004a4e:	2b0c      	cmp	r3, #12
 c004a50:	d040      	beq.n	c004ad4 <mbedtls_aes_setkey_enc+0xc8>
 c004a52:	2b0e      	cmp	r3, #14
 c004a54:	d06f      	beq.n	c004b36 <mbedtls_aes_setkey_enc+0x12a>
 c004a56:	2b0a      	cmp	r3, #10
 c004a58:	d127      	bne.n	c004aaa <mbedtls_aes_setkey_enc+0x9e>
 c004a5a:	4620      	mov	r0, r4
 c004a5c:	4d5c      	ldr	r5, [pc, #368]	; (c004bd0 <mbedtls_aes_setkey_enc+0x1c4>)
        case 10:

            for( i = 0; i < 10; i++, RK += 4 )
            {
                RK[4]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 c004a5e:	495d      	ldr	r1, [pc, #372]	; (c004bd4 <mbedtls_aes_setkey_enc+0x1c8>)
 c004a60:	f104 06a0 	add.w	r6, r4, #160	; 0xa0
 c004a64:	6942      	ldr	r2, [r0, #20]
                RK[4]  = RK[0] ^ RCON[i] ^
 c004a66:	f855 4b04 	ldr.w	r4, [r5], #4
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 c004a6a:	6887      	ldr	r7, [r0, #8]
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 c004a6c:	f3c2 2307 	ubfx	r3, r2, #8, #8
 c004a70:	5ccb      	ldrb	r3, [r1, r3]
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 c004a72:	407c      	eors	r4, r7
 c004a74:	4063      	eors	r3, r4
 c004a76:	0e14      	lsrs	r4, r2, #24
 c004a78:	5d0c      	ldrb	r4, [r1, r4]
 c004a7a:	3010      	adds	r0, #16
 c004a7c:	ea83 4304 	eor.w	r3, r3, r4, lsl #16
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );
 c004a80:	b2d4      	uxtb	r4, r2
 c004a82:	5d0c      	ldrb	r4, [r1, r4]
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 c004a84:	ea83 6304 	eor.w	r3, r3, r4, lsl #24
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
 c004a88:	f3c2 4407 	ubfx	r4, r2, #16, #8
 c004a8c:	5d0c      	ldrb	r4, [r1, r4]
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 c004a8e:	ea83 2304 	eor.w	r3, r3, r4, lsl #8

                RK[5]  = RK[1] ^ RK[4];
 c004a92:	f850 4c04 	ldr.w	r4, [r0, #-4]
                RK[4]  = RK[0] ^ RCON[i] ^
 c004a96:	6083      	str	r3, [r0, #8]
                RK[5]  = RK[1] ^ RK[4];
 c004a98:	4063      	eors	r3, r4
                RK[6]  = RK[2] ^ RK[5];
 c004a9a:	6804      	ldr	r4, [r0, #0]
                RK[5]  = RK[1] ^ RK[4];
 c004a9c:	60c3      	str	r3, [r0, #12]
                RK[6]  = RK[2] ^ RK[5];
 c004a9e:	4063      	eors	r3, r4
 c004aa0:	6103      	str	r3, [r0, #16]
                RK[7]  = RK[3] ^ RK[6];
 c004aa2:	4053      	eors	r3, r2
 c004aa4:	6143      	str	r3, [r0, #20]
            for( i = 0; i < 10; i++, RK += 4 )
 c004aa6:	4286      	cmp	r6, r0
 c004aa8:	d1dc      	bne.n	c004a64 <mbedtls_aes_setkey_enc+0x58>
    switch( ctx->nr )
 c004aaa:	2000      	movs	r0, #0
 c004aac:	e08d      	b.n	c004bca <mbedtls_aes_setkey_enc+0x1be>
        case 192: ctx->nr = 12; break;
 c004aae:	230c      	movs	r3, #12
 c004ab0:	e7b9      	b.n	c004a26 <mbedtls_aes_setkey_enc+0x1a>
        case 256: ctx->nr = 14; break;
 c004ab2:	230e      	movs	r3, #14
 c004ab4:	e7b7      	b.n	c004a26 <mbedtls_aes_setkey_enc+0x1a>
        GET_UINT32_LE( RK[i], key, i << 2 );
 c004ab6:	788b      	ldrb	r3, [r1, #2]
 c004ab8:	7848      	ldrb	r0, [r1, #1]
 c004aba:	041b      	lsls	r3, r3, #16
 c004abc:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 c004ac0:	7808      	ldrb	r0, [r1, #0]
 c004ac2:	3104      	adds	r1, #4
 c004ac4:	4303      	orrs	r3, r0
 c004ac6:	f811 0c01 	ldrb.w	r0, [r1, #-1]
 c004aca:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 c004ace:	f842 3f04 	str.w	r3, [r2, #4]!
    for( i = 0; i < ( keybits >> 5 ); i++ )
 c004ad2:	e7b9      	b.n	c004a48 <mbedtls_aes_setkey_enc+0x3c>
 c004ad4:	4620      	mov	r0, r4
        case 12:

            for( i = 0; i < 8; i++, RK += 6 )
            {
                RK[6]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 c004ad6:	493f      	ldr	r1, [pc, #252]	; (c004bd4 <mbedtls_aes_setkey_enc+0x1c8>)
 c004ad8:	4c3d      	ldr	r4, [pc, #244]	; (c004bd0 <mbedtls_aes_setkey_enc+0x1c4>)
 c004ada:	f100 05c0 	add.w	r5, r0, #192	; 0xc0
 c004ade:	69c2      	ldr	r2, [r0, #28]
                RK[6]  = RK[0] ^ RCON[i] ^
 c004ae0:	f854 6b04 	ldr.w	r6, [r4], #4
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 c004ae4:	6887      	ldr	r7, [r0, #8]
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 c004ae6:	f3c2 2307 	ubfx	r3, r2, #8, #8
 c004aea:	5ccb      	ldrb	r3, [r1, r3]
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 c004aec:	407e      	eors	r6, r7
 c004aee:	4073      	eors	r3, r6
 c004af0:	0e16      	lsrs	r6, r2, #24
 c004af2:	5d8e      	ldrb	r6, [r1, r6]
 c004af4:	3018      	adds	r0, #24
 c004af6:	ea83 4306 	eor.w	r3, r3, r6, lsl #16
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );
 c004afa:	b2d6      	uxtb	r6, r2
 c004afc:	5d8e      	ldrb	r6, [r1, r6]
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 c004afe:	ea83 6306 	eor.w	r3, r3, r6, lsl #24
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
 c004b02:	f3c2 4607 	ubfx	r6, r2, #16, #8
 c004b06:	5d8e      	ldrb	r6, [r1, r6]
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 c004b08:	ea83 2306 	eor.w	r3, r3, r6, lsl #8

                RK[7]  = RK[1] ^ RK[6];
 c004b0c:	f850 6c0c 	ldr.w	r6, [r0, #-12]
                RK[6]  = RK[0] ^ RCON[i] ^
 c004b10:	6083      	str	r3, [r0, #8]
                RK[7]  = RK[1] ^ RK[6];
 c004b12:	4073      	eors	r3, r6
                RK[8]  = RK[2] ^ RK[7];
 c004b14:	f850 6c08 	ldr.w	r6, [r0, #-8]
                RK[7]  = RK[1] ^ RK[6];
 c004b18:	60c3      	str	r3, [r0, #12]
                RK[8]  = RK[2] ^ RK[7];
 c004b1a:	4073      	eors	r3, r6
                RK[9]  = RK[3] ^ RK[8];
 c004b1c:	f850 6c04 	ldr.w	r6, [r0, #-4]
                RK[8]  = RK[2] ^ RK[7];
 c004b20:	6103      	str	r3, [r0, #16]
                RK[9]  = RK[3] ^ RK[8];
 c004b22:	4073      	eors	r3, r6
                RK[10] = RK[4] ^ RK[9];
 c004b24:	6806      	ldr	r6, [r0, #0]
                RK[9]  = RK[3] ^ RK[8];
 c004b26:	6143      	str	r3, [r0, #20]
                RK[10] = RK[4] ^ RK[9];
 c004b28:	4073      	eors	r3, r6
 c004b2a:	6183      	str	r3, [r0, #24]
                RK[11] = RK[5] ^ RK[10];
 c004b2c:	4053      	eors	r3, r2
 c004b2e:	61c3      	str	r3, [r0, #28]
            for( i = 0; i < 8; i++, RK += 6 )
 c004b30:	4285      	cmp	r5, r0
 c004b32:	d1d4      	bne.n	c004ade <mbedtls_aes_setkey_enc+0xd2>
 c004b34:	e7b9      	b.n	c004aaa <mbedtls_aes_setkey_enc+0x9e>
 c004b36:	4620      	mov	r0, r4
 c004b38:	4d25      	ldr	r5, [pc, #148]	; (c004bd0 <mbedtls_aes_setkey_enc+0x1c4>)
        case 14:

            for( i = 0; i < 7; i++, RK += 8 )
            {
                RK[8]  = RK[0] ^ RCON[i] ^
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 c004b3a:	4926      	ldr	r1, [pc, #152]	; (c004bd4 <mbedtls_aes_setkey_enc+0x1c8>)
 c004b3c:	f104 06e0 	add.w	r6, r4, #224	; 0xe0
 c004b40:	6a44      	ldr	r4, [r0, #36]	; 0x24
                RK[8]  = RK[0] ^ RCON[i] ^
 c004b42:	f855 2b04 	ldr.w	r2, [r5], #4
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 c004b46:	6887      	ldr	r7, [r0, #8]
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 c004b48:	f3c4 2307 	ubfx	r3, r4, #8, #8
 c004b4c:	5ccb      	ldrb	r3, [r1, r3]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 c004b4e:	407a      	eors	r2, r7
 c004b50:	4053      	eors	r3, r2
 c004b52:	0e22      	lsrs	r2, r4, #24
 c004b54:	5c8a      	ldrb	r2, [r1, r2]
                RK[11] = RK[3] ^ RK[10];

                RK[12] = RK[4] ^
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 c004b56:	6987      	ldr	r7, [r0, #24]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 c004b58:	ea83 4302 	eor.w	r3, r3, r2, lsl #16
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );
 c004b5c:	b2e2      	uxtb	r2, r4
 c004b5e:	5c8a      	ldrb	r2, [r1, r2]
 c004b60:	3020      	adds	r0, #32
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 c004b62:	ea83 6302 	eor.w	r3, r3, r2, lsl #24
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
 c004b66:	f3c4 4207 	ubfx	r2, r4, #16, #8
 c004b6a:	5c8a      	ldrb	r2, [r1, r2]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 c004b6c:	ea83 2302 	eor.w	r3, r3, r2, lsl #8
                RK[9]  = RK[1] ^ RK[8];
 c004b70:	f850 2c14 	ldr.w	r2, [r0, #-20]
                RK[8]  = RK[0] ^ RCON[i] ^
 c004b74:	6083      	str	r3, [r0, #8]
                RK[9]  = RK[1] ^ RK[8];
 c004b76:	4053      	eors	r3, r2
                RK[10] = RK[2] ^ RK[9];
 c004b78:	f850 2c10 	ldr.w	r2, [r0, #-16]
                RK[9]  = RK[1] ^ RK[8];
 c004b7c:	60c3      	str	r3, [r0, #12]
                RK[10] = RK[2] ^ RK[9];
 c004b7e:	4053      	eors	r3, r2
                RK[11] = RK[3] ^ RK[10];
 c004b80:	f850 2c0c 	ldr.w	r2, [r0, #-12]
                RK[10] = RK[2] ^ RK[9];
 c004b84:	6103      	str	r3, [r0, #16]
                RK[11] = RK[3] ^ RK[10];
 c004b86:	4053      	eors	r3, r2
 c004b88:	6143      	str	r3, [r0, #20]
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
 c004b8a:	b2da      	uxtb	r2, r3
 c004b8c:	5c8a      	ldrb	r2, [r1, r2]
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 c004b8e:	407a      	eors	r2, r7
                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );
 c004b90:	0e1f      	lsrs	r7, r3, #24
 c004b92:	5dcf      	ldrb	r7, [r1, r7]
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 c004b94:	ea82 6207 	eor.w	r2, r2, r7, lsl #24
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
 c004b98:	f3c3 2707 	ubfx	r7, r3, #8, #8
 c004b9c:	5dcf      	ldrb	r7, [r1, r7]
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 c004b9e:	f3c3 4307 	ubfx	r3, r3, #16, #8
 c004ba2:	5ccb      	ldrb	r3, [r1, r3]
 c004ba4:	ea82 2207 	eor.w	r2, r2, r7, lsl #8
 c004ba8:	ea82 4303 	eor.w	r3, r2, r3, lsl #16

                RK[13] = RK[5] ^ RK[12];
 c004bac:	f850 2c04 	ldr.w	r2, [r0, #-4]
                RK[12] = RK[4] ^
 c004bb0:	6183      	str	r3, [r0, #24]
                RK[13] = RK[5] ^ RK[12];
 c004bb2:	4053      	eors	r3, r2
                RK[14] = RK[6] ^ RK[13];
 c004bb4:	6802      	ldr	r2, [r0, #0]
                RK[13] = RK[5] ^ RK[12];
 c004bb6:	61c3      	str	r3, [r0, #28]
                RK[14] = RK[6] ^ RK[13];
 c004bb8:	4053      	eors	r3, r2
 c004bba:	6203      	str	r3, [r0, #32]
                RK[15] = RK[7] ^ RK[14];
 c004bbc:	4063      	eors	r3, r4
 c004bbe:	6243      	str	r3, [r0, #36]	; 0x24
            for( i = 0; i < 7; i++, RK += 8 )
 c004bc0:	4286      	cmp	r6, r0
 c004bc2:	d1bd      	bne.n	c004b40 <mbedtls_aes_setkey_enc+0x134>
 c004bc4:	e771      	b.n	c004aaa <mbedtls_aes_setkey_enc+0x9e>
    switch( keybits )
 c004bc6:	f06f 001f 	mvn.w	r0, #31
            }
            break;
    }

    return( 0 );
}
 c004bca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c004bcc:	3003249c 	.word	0x3003249c
 c004bd0:	30031374 	.word	0x30031374
 c004bd4:	30030274 	.word	0x30030274

0c004bd8 <mbedtls_internal_aes_encrypt>:
 */
#if !defined(MBEDTLS_AES_ENCRYPT_ALT)
int mbedtls_internal_aes_encrypt( mbedtls_aes_context *ctx,
                                  const unsigned char input[16],
                                  unsigned char output[16] )
{
 c004bd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;
 c004bdc:	6847      	ldr	r7, [r0, #4]

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 c004bde:	680d      	ldr	r5, [r1, #0]
 c004be0:	683b      	ldr	r3, [r7, #0]
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 c004be2:	684c      	ldr	r4, [r1, #4]
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 c004be4:	405d      	eors	r5, r3
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 c004be6:	687b      	ldr	r3, [r7, #4]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 c004be8:	688e      	ldr	r6, [r1, #8]
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 c004bea:	405c      	eors	r4, r3
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 c004bec:	68bb      	ldr	r3, [r7, #8]
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 c004bee:	68c9      	ldr	r1, [r1, #12]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 c004bf0:	405e      	eors	r6, r3
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 c004bf2:	68fb      	ldr	r3, [r7, #12]
{
 c004bf4:	b08f      	sub	sp, #60	; 0x3c
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 c004bf6:	404b      	eors	r3, r1

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 c004bf8:	6801      	ldr	r1, [r0, #0]
 c004bfa:	f8df 8288 	ldr.w	r8, [pc, #648]	; c004e84 <mbedtls_internal_aes_encrypt+0x2ac>
 c004bfe:	1049      	asrs	r1, r1, #1
 c004c00:	3901      	subs	r1, #1
 c004c02:	f8df e284 	ldr.w	lr, [pc, #644]	; c004e88 <mbedtls_internal_aes_encrypt+0x2b0>
 c004c06:	f8df c284 	ldr.w	ip, [pc, #644]	; c004e8c <mbedtls_internal_aes_encrypt+0x2b4>
 c004c0a:	9100      	str	r1, [sp, #0]
 c004c0c:	f107 0130 	add.w	r1, r7, #48	; 0x30
 c004c10:	f851 7c10 	ldr.w	r7, [r1, #-16]
 c004c14:	f851 0c20 	ldr.w	r0, [r1, #-32]
 c004c18:	9701      	str	r7, [sp, #4]
 c004c1a:	b2ef      	uxtb	r7, r5
 c004c1c:	f858 7027 	ldr.w	r7, [r8, r7, lsl #2]
 c004c20:	ea4f 6b14 	mov.w	fp, r4, lsr #24
 c004c24:	ea87 0900 	eor.w	r9, r7, r0
 c004c28:	0e1f      	lsrs	r7, r3, #24
 c004c2a:	f85e 7027 	ldr.w	r7, [lr, r7, lsl #2]
 c004c2e:	4893      	ldr	r0, [pc, #588]	; (c004e7c <mbedtls_internal_aes_encrypt+0x2a4>)
 c004c30:	ea89 0907 	eor.w	r9, r9, r7
 c004c34:	f3c4 2707 	ubfx	r7, r4, #8, #8
 c004c38:	f85c 7027 	ldr.w	r7, [ip, r7, lsl #2]
 c004c3c:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
 c004c40:	ea89 0907 	eor.w	r9, r9, r7
 c004c44:	f3c6 4707 	ubfx	r7, r6, #16, #8
 c004c48:	f850 7027 	ldr.w	r7, [r0, r7, lsl #2]
 c004c4c:	3120      	adds	r1, #32
 c004c4e:	ea89 0907 	eor.w	r9, r9, r7
 c004c52:	fa5f f089 	uxtb.w	r0, r9
 c004c56:	b2e7      	uxtb	r7, r4
 c004c58:	f858 7027 	ldr.w	r7, [r8, r7, lsl #2]
 c004c5c:	9002      	str	r0, [sp, #8]
 c004c5e:	f851 0c3c 	ldr.w	r0, [r1, #-60]
 c004c62:	f3c4 4407 	ubfx	r4, r4, #16, #8
 c004c66:	ea87 0a00 	eor.w	sl, r7, r0
 c004c6a:	0e2f      	lsrs	r7, r5, #24
 c004c6c:	f85e 7027 	ldr.w	r7, [lr, r7, lsl #2]
 c004c70:	4882      	ldr	r0, [pc, #520]	; (c004e7c <mbedtls_internal_aes_encrypt+0x2a4>)
 c004c72:	ea8a 0a07 	eor.w	sl, sl, r7
 c004c76:	f3c6 2707 	ubfx	r7, r6, #8, #8
 c004c7a:	f85c 7027 	ldr.w	r7, [ip, r7, lsl #2]
 c004c7e:	ea8a 0a07 	eor.w	sl, sl, r7
 c004c82:	f3c3 4707 	ubfx	r7, r3, #16, #8
 c004c86:	f850 7027 	ldr.w	r7, [r0, r7, lsl #2]
 c004c8a:	ea8a 0a07 	eor.w	sl, sl, r7
 c004c8e:	f3ca 2007 	ubfx	r0, sl, #8, #8
 c004c92:	b2f7      	uxtb	r7, r6
 c004c94:	f858 7027 	ldr.w	r7, [r8, r7, lsl #2]
 c004c98:	9003      	str	r0, [sp, #12]
 c004c9a:	f851 0c38 	ldr.w	r0, [r1, #-56]
 c004c9e:	0e36      	lsrs	r6, r6, #24
 c004ca0:	4047      	eors	r7, r0
 c004ca2:	ea87 070b 	eor.w	r7, r7, fp
 c004ca6:	f3c3 2b07 	ubfx	fp, r3, #8, #8
 c004caa:	f85c b02b 	ldr.w	fp, [ip, fp, lsl #2]
 c004cae:	4873      	ldr	r0, [pc, #460]	; (c004e7c <mbedtls_internal_aes_encrypt+0x2a4>)
 c004cb0:	ea87 070b 	eor.w	r7, r7, fp
 c004cb4:	f3c5 4b07 	ubfx	fp, r5, #16, #8
 c004cb8:	f850 b02b 	ldr.w	fp, [r0, fp, lsl #2]
 c004cbc:	b2db      	uxtb	r3, r3
 c004cbe:	ea87 070b 	eor.w	r7, r7, fp
 c004cc2:	f3c7 4007 	ubfx	r0, r7, #16, #8
 c004cc6:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 c004cca:	9004      	str	r0, [sp, #16]
 c004ccc:	f851 0c34 	ldr.w	r0, [r1, #-52]
 c004cd0:	f85e 6026 	ldr.w	r6, [lr, r6, lsl #2]
 c004cd4:	4043      	eors	r3, r0
 c004cd6:	f3c5 2507 	ubfx	r5, r5, #8, #8
 c004cda:	4868      	ldr	r0, [pc, #416]	; (c004e7c <mbedtls_internal_aes_encrypt+0x2a4>)
 c004cdc:	4073      	eors	r3, r6
 c004cde:	f85c 6025 	ldr.w	r6, [ip, r5, lsl #2]
 c004ce2:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
 c004ce6:	4073      	eors	r3, r6
 c004ce8:	f851 0c2c 	ldr.w	r0, [r1, #-44]
 c004cec:	4063      	eors	r3, r4
 c004cee:	9005      	str	r0, [sp, #20]
 c004cf0:	f3c3 4007 	ubfx	r0, r3, #16, #8
 c004cf4:	9006      	str	r0, [sp, #24]
 c004cf6:	f851 0c28 	ldr.w	r0, [r1, #-40]
 c004cfa:	0e1d      	lsrs	r5, r3, #24
 c004cfc:	9007      	str	r0, [sp, #28]
 c004cfe:	b2f8      	uxtb	r0, r7
 c004d00:	9008      	str	r0, [sp, #32]
 c004d02:	f3c3 2007 	ubfx	r0, r3, #8, #8
 c004d06:	9009      	str	r0, [sp, #36]	; 0x24
 c004d08:	b2db      	uxtb	r3, r3
 c004d0a:	f3c9 4007 	ubfx	r0, r9, #16, #8
 c004d0e:	900a      	str	r0, [sp, #40]	; 0x28
 c004d10:	ea4f 601a 	mov.w	r0, sl, lsr #24
 c004d14:	930d      	str	r3, [sp, #52]	; 0x34
 c004d16:	9b00      	ldr	r3, [sp, #0]
 c004d18:	900b      	str	r0, [sp, #44]	; 0x2c
 c004d1a:	f851 0c24 	ldr.w	r0, [r1, #-36]
 c004d1e:	2b00      	cmp	r3, #0
 c004d20:	fa5f f48a 	uxtb.w	r4, sl
 c004d24:	f3c7 2b07 	ubfx	fp, r7, #8, #8
 c004d28:	ea4f 6619 	mov.w	r6, r9, lsr #24
 c004d2c:	900c      	str	r0, [sp, #48]	; 0x30
 c004d2e:	f3c9 2907 	ubfx	r9, r9, #8, #8
 c004d32:	f3ca 4a07 	ubfx	sl, sl, #16, #8
 c004d36:	ea4f 6717 	mov.w	r7, r7, lsr #24
 c004d3a:	dc5d      	bgt.n	c004df8 <mbedtls_internal_aes_encrypt+0x220>

    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );

    X0 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 c004d3c:	4950      	ldr	r1, [pc, #320]	; (c004e80 <mbedtls_internal_aes_encrypt+0x2a8>)
 c004d3e:	9b03      	ldr	r3, [sp, #12]
    X0 = *RK++ ^ \
 c004d40:	9801      	ldr	r0, [sp, #4]
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 c004d42:	f811 c003 	ldrb.w	ip, [r1, r3]
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
 c004d46:	9b02      	ldr	r3, [sp, #8]
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X1 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
 c004d48:	5d0c      	ldrb	r4, [r1, r4]
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
 c004d4a:	5ccb      	ldrb	r3, [r1, r3]
    X0 = *RK++ ^ \
 c004d4c:	4043      	eors	r3, r0
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
 c004d4e:	9804      	ldr	r0, [sp, #16]
    X0 = *RK++ ^ \
 c004d50:	ea83 230c 	eor.w	r3, r3, ip, lsl #8
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
 c004d54:	5c08      	ldrb	r0, [r1, r0]
    X0 = *RK++ ^ \
 c004d56:	ea83 4300 	eor.w	r3, r3, r0, lsl #16
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
 c004d5a:	5d48      	ldrb	r0, [r1, r5]
    X1 = *RK++ ^ \
 c004d5c:	9d05      	ldr	r5, [sp, #20]
    X0 = *RK++ ^ \
 c004d5e:	ea83 6300 	eor.w	r3, r3, r0, lsl #24
            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
 c004d62:	f811 000b 	ldrb.w	r0, [r1, fp]
    X1 = *RK++ ^ \
 c004d66:	406c      	eors	r4, r5
 c004d68:	ea84 2400 	eor.w	r4, r4, r0, lsl #8
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
 c004d6c:	9806      	ldr	r0, [sp, #24]
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    X2 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
 c004d6e:	9d08      	ldr	r5, [sp, #32]
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
 c004d70:	5c08      	ldrb	r0, [r1, r0]
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
 c004d72:	5d4d      	ldrb	r5, [r1, r5]
    X1 = *RK++ ^ \
 c004d74:	ea84 4400 	eor.w	r4, r4, r0, lsl #16
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
 c004d78:	5d88      	ldrb	r0, [r1, r6]
    X2 = *RK++ ^ \
 c004d7a:	9e07      	ldr	r6, [sp, #28]
    X1 = *RK++ ^ \
 c004d7c:	ea84 6400 	eor.w	r4, r4, r0, lsl #24
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 c004d80:	9809      	ldr	r0, [sp, #36]	; 0x24
    X2 = *RK++ ^ \
 c004d82:	4075      	eors	r5, r6
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 c004d84:	5c08      	ldrb	r0, [r1, r0]
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
 c004d86:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    X2 = *RK++ ^ \
 c004d88:	ea85 2500 	eor.w	r5, r5, r0, lsl #8
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 c004d8c:	980a      	ldr	r0, [sp, #40]	; 0x28
 c004d8e:	5c08      	ldrb	r0, [r1, r0]
    X2 = *RK++ ^ \
 c004d90:	ea85 4500 	eor.w	r5, r5, r0, lsl #16
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
 c004d94:	980b      	ldr	r0, [sp, #44]	; 0x2c
 c004d96:	5c08      	ldrb	r0, [r1, r0]
    X2 = *RK++ ^ \
 c004d98:	ea85 6500 	eor.w	r5, r5, r0, lsl #24
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
 c004d9c:	980d      	ldr	r0, [sp, #52]	; 0x34
 c004d9e:	5c08      	ldrb	r0, [r1, r0]
    X3 = *RK++ ^ \
 c004da0:	4070      	eors	r0, r6
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
 c004da2:	f811 6009 	ldrb.w	r6, [r1, r9]
    X3 = *RK++ ^ \
 c004da6:	ea80 2006 	eor.w	r0, r0, r6, lsl #8
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
 c004daa:	f811 600a 	ldrb.w	r6, [r1, sl]
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
 c004dae:	5dc9      	ldrb	r1, [r1, r7]
    X3 = *RK++ ^ \
 c004db0:	ea80 4006 	eor.w	r0, r0, r6, lsl #16
 c004db4:	ea80 6101 	eor.w	r1, r0, r1, lsl #24

    PUT_UINT32_LE( X0, output,  0 );
 c004db8:	0a18      	lsrs	r0, r3, #8
 c004dba:	7050      	strb	r0, [r2, #1]
 c004dbc:	0c18      	lsrs	r0, r3, #16
 c004dbe:	7090      	strb	r0, [r2, #2]
    PUT_UINT32_LE( X1, output,  4 );
    PUT_UINT32_LE( X2, output,  8 );
    PUT_UINT32_LE( X3, output, 12 );

    return( 0 );
}
 c004dc0:	2000      	movs	r0, #0
    PUT_UINT32_LE( X0, output,  0 );
 c004dc2:	7013      	strb	r3, [r2, #0]
 c004dc4:	0e1b      	lsrs	r3, r3, #24
 c004dc6:	70d3      	strb	r3, [r2, #3]
    PUT_UINT32_LE( X1, output,  4 );
 c004dc8:	0a23      	lsrs	r3, r4, #8
 c004dca:	7153      	strb	r3, [r2, #5]
 c004dcc:	0c23      	lsrs	r3, r4, #16
 c004dce:	7193      	strb	r3, [r2, #6]
    PUT_UINT32_LE( X2, output,  8 );
 c004dd0:	0a2b      	lsrs	r3, r5, #8
 c004dd2:	7253      	strb	r3, [r2, #9]
 c004dd4:	0c2b      	lsrs	r3, r5, #16
 c004dd6:	7293      	strb	r3, [r2, #10]
    PUT_UINT32_LE( X3, output, 12 );
 c004dd8:	0a0b      	lsrs	r3, r1, #8
    PUT_UINT32_LE( X1, output,  4 );
 c004dda:	7114      	strb	r4, [r2, #4]
    PUT_UINT32_LE( X2, output,  8 );
 c004ddc:	7215      	strb	r5, [r2, #8]
    PUT_UINT32_LE( X1, output,  4 );
 c004dde:	0e24      	lsrs	r4, r4, #24
    PUT_UINT32_LE( X2, output,  8 );
 c004de0:	0e2d      	lsrs	r5, r5, #24
    PUT_UINT32_LE( X3, output, 12 );
 c004de2:	7311      	strb	r1, [r2, #12]
 c004de4:	7353      	strb	r3, [r2, #13]
 c004de6:	0c0b      	lsrs	r3, r1, #16
 c004de8:	0e09      	lsrs	r1, r1, #24
    PUT_UINT32_LE( X1, output,  4 );
 c004dea:	71d4      	strb	r4, [r2, #7]
    PUT_UINT32_LE( X2, output,  8 );
 c004dec:	72d5      	strb	r5, [r2, #11]
    PUT_UINT32_LE( X3, output, 12 );
 c004dee:	7393      	strb	r3, [r2, #14]
 c004df0:	73d1      	strb	r1, [r2, #15]
}
 c004df2:	b00f      	add	sp, #60	; 0x3c
 c004df4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 c004df8:	9b02      	ldr	r3, [sp, #8]
 c004dfa:	f85e 5025 	ldr.w	r5, [lr, r5, lsl #2]
 c004dfe:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 c004e02:	481e      	ldr	r0, [pc, #120]	; (c004e7c <mbedtls_internal_aes_encrypt+0x2a4>)
 c004e04:	406b      	eors	r3, r5
 c004e06:	9d01      	ldr	r5, [sp, #4]
 c004e08:	f858 4024 	ldr.w	r4, [r8, r4, lsl #2]
 c004e0c:	406b      	eors	r3, r5
 c004e0e:	9d03      	ldr	r5, [sp, #12]
 c004e10:	f85e 7027 	ldr.w	r7, [lr, r7, lsl #2]
 c004e14:	f85c 5025 	ldr.w	r5, [ip, r5, lsl #2]
 c004e18:	405d      	eors	r5, r3
 c004e1a:	9b04      	ldr	r3, [sp, #16]
 c004e1c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 c004e20:	405d      	eors	r5, r3
 c004e22:	f85e 3026 	ldr.w	r3, [lr, r6, lsl #2]
 c004e26:	405c      	eors	r4, r3
 c004e28:	9b05      	ldr	r3, [sp, #20]
 c004e2a:	405c      	eors	r4, r3
 c004e2c:	f85c 302b 	ldr.w	r3, [ip, fp, lsl #2]
 c004e30:	405c      	eors	r4, r3
 c004e32:	9b06      	ldr	r3, [sp, #24]
 c004e34:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 c004e38:	405c      	eors	r4, r3
 c004e3a:	9b08      	ldr	r3, [sp, #32]
 c004e3c:	f858 6023 	ldr.w	r6, [r8, r3, lsl #2]
 c004e40:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 c004e42:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
 c004e46:	405e      	eors	r6, r3
 c004e48:	9b07      	ldr	r3, [sp, #28]
 c004e4a:	405e      	eors	r6, r3
 c004e4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c004e4e:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
 c004e52:	405e      	eors	r6, r3
 c004e54:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 c004e56:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 c004e5a:	405e      	eors	r6, r3
 c004e5c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 c004e5e:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 c004e62:	407b      	eors	r3, r7
 c004e64:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 c004e66:	407b      	eors	r3, r7
 c004e68:	f85c 7029 	ldr.w	r7, [ip, r9, lsl #2]
 c004e6c:	407b      	eors	r3, r7
 c004e6e:	f850 702a 	ldr.w	r7, [r0, sl, lsl #2]
 c004e72:	407b      	eors	r3, r7
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 c004e74:	9f00      	ldr	r7, [sp, #0]
 c004e76:	3f01      	subs	r7, #1
 c004e78:	9700      	str	r7, [sp, #0]
 c004e7a:	e6c9      	b.n	c004c10 <mbedtls_internal_aes_encrypt+0x38>
 c004e7c:	30030b74 	.word	0x30030b74
 c004e80:	30030274 	.word	0x30030274
 c004e84:	30030374 	.word	0x30030374
 c004e88:	30030f74 	.word	0x30030f74
 c004e8c:	30030774 	.word	0x30030774

0c004e90 <mbedtls_internal_aes_decrypt>:
 */
#if !defined(MBEDTLS_AES_DECRYPT_ALT)
int mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx,
                                  const unsigned char input[16],
                                  unsigned char output[16] )
{
 c004e90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;
 c004e94:	6847      	ldr	r7, [r0, #4]

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 c004e96:	680c      	ldr	r4, [r1, #0]
 c004e98:	683b      	ldr	r3, [r7, #0]
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 c004e9a:	684e      	ldr	r6, [r1, #4]
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 c004e9c:	405c      	eors	r4, r3
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 c004e9e:	687b      	ldr	r3, [r7, #4]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 c004ea0:	688d      	ldr	r5, [r1, #8]
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 c004ea2:	405e      	eors	r6, r3
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 c004ea4:	68bb      	ldr	r3, [r7, #8]
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 c004ea6:	68c9      	ldr	r1, [r1, #12]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 c004ea8:	405d      	eors	r5, r3
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 c004eaa:	68fb      	ldr	r3, [r7, #12]
{
 c004eac:	b08f      	sub	sp, #60	; 0x3c
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 c004eae:	404b      	eors	r3, r1

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 c004eb0:	6801      	ldr	r1, [r0, #0]
 c004eb2:	f8df 828c 	ldr.w	r8, [pc, #652]	; c005140 <mbedtls_internal_aes_decrypt+0x2b0>
 c004eb6:	1049      	asrs	r1, r1, #1
 c004eb8:	3901      	subs	r1, #1
 c004eba:	f8df e288 	ldr.w	lr, [pc, #648]	; c005144 <mbedtls_internal_aes_decrypt+0x2b4>
 c004ebe:	f8df c288 	ldr.w	ip, [pc, #648]	; c005148 <mbedtls_internal_aes_decrypt+0x2b8>
 c004ec2:	9100      	str	r1, [sp, #0]
 c004ec4:	f107 0130 	add.w	r1, r7, #48	; 0x30
 c004ec8:	f851 0c10 	ldr.w	r0, [r1, #-16]
 c004ecc:	b2e7      	uxtb	r7, r4
 c004ece:	f858 7027 	ldr.w	r7, [r8, r7, lsl #2]
 c004ed2:	9001      	str	r0, [sp, #4]
 c004ed4:	f851 0c20 	ldr.w	r0, [r1, #-32]
 c004ed8:	ea4f 6b13 	mov.w	fp, r3, lsr #24
 c004edc:	ea87 0900 	eor.w	r9, r7, r0
 c004ee0:	0e37      	lsrs	r7, r6, #24
 c004ee2:	f85e 7027 	ldr.w	r7, [lr, r7, lsl #2]
 c004ee6:	4894      	ldr	r0, [pc, #592]	; (c005138 <mbedtls_internal_aes_decrypt+0x2a8>)
 c004ee8:	ea89 0907 	eor.w	r9, r9, r7
 c004eec:	f3c3 2707 	ubfx	r7, r3, #8, #8
 c004ef0:	f85c 7027 	ldr.w	r7, [ip, r7, lsl #2]
 c004ef4:	f85e b02b 	ldr.w	fp, [lr, fp, lsl #2]
 c004ef8:	ea89 0907 	eor.w	r9, r9, r7
 c004efc:	f3c5 4707 	ubfx	r7, r5, #16, #8
 c004f00:	f850 7027 	ldr.w	r7, [r0, r7, lsl #2]
 c004f04:	3120      	adds	r1, #32
 c004f06:	ea89 0907 	eor.w	r9, r9, r7
 c004f0a:	fa5f f089 	uxtb.w	r0, r9
 c004f0e:	b2df      	uxtb	r7, r3
 c004f10:	f858 7027 	ldr.w	r7, [r8, r7, lsl #2]
 c004f14:	9002      	str	r0, [sp, #8]
 c004f16:	f851 0c34 	ldr.w	r0, [r1, #-52]
 c004f1a:	f3c3 4307 	ubfx	r3, r3, #16, #8
 c004f1e:	ea87 0a00 	eor.w	sl, r7, r0
 c004f22:	0e27      	lsrs	r7, r4, #24
 c004f24:	f85e 7027 	ldr.w	r7, [lr, r7, lsl #2]
 c004f28:	4883      	ldr	r0, [pc, #524]	; (c005138 <mbedtls_internal_aes_decrypt+0x2a8>)
 c004f2a:	ea8a 0a07 	eor.w	sl, sl, r7
 c004f2e:	f3c5 2707 	ubfx	r7, r5, #8, #8
 c004f32:	f85c 7027 	ldr.w	r7, [ip, r7, lsl #2]
 c004f36:	ea8a 0a07 	eor.w	sl, sl, r7
 c004f3a:	f3c6 4707 	ubfx	r7, r6, #16, #8
 c004f3e:	f850 7027 	ldr.w	r7, [r0, r7, lsl #2]
 c004f42:	ea8a 0a07 	eor.w	sl, sl, r7
 c004f46:	f3ca 2007 	ubfx	r0, sl, #8, #8
 c004f4a:	b2ef      	uxtb	r7, r5
 c004f4c:	f858 7027 	ldr.w	r7, [r8, r7, lsl #2]
 c004f50:	9003      	str	r0, [sp, #12]
 c004f52:	f851 0c38 	ldr.w	r0, [r1, #-56]
 c004f56:	0e2d      	lsrs	r5, r5, #24
 c004f58:	4047      	eors	r7, r0
 c004f5a:	ea87 070b 	eor.w	r7, r7, fp
 c004f5e:	f3c6 2b07 	ubfx	fp, r6, #8, #8
 c004f62:	f85c b02b 	ldr.w	fp, [ip, fp, lsl #2]
 c004f66:	4874      	ldr	r0, [pc, #464]	; (c005138 <mbedtls_internal_aes_decrypt+0x2a8>)
 c004f68:	ea87 070b 	eor.w	r7, r7, fp
 c004f6c:	f3c4 4b07 	ubfx	fp, r4, #16, #8
 c004f70:	f850 b02b 	ldr.w	fp, [r0, fp, lsl #2]
 c004f74:	b2f6      	uxtb	r6, r6
 c004f76:	ea87 070b 	eor.w	r7, r7, fp
 c004f7a:	f3c7 4007 	ubfx	r0, r7, #16, #8
 c004f7e:	f858 6026 	ldr.w	r6, [r8, r6, lsl #2]
 c004f82:	9004      	str	r0, [sp, #16]
 c004f84:	f851 0c3c 	ldr.w	r0, [r1, #-60]
 c004f88:	f85e 5025 	ldr.w	r5, [lr, r5, lsl #2]
 c004f8c:	4046      	eors	r6, r0
 c004f8e:	f3c4 2407 	ubfx	r4, r4, #8, #8
 c004f92:	4869      	ldr	r0, [pc, #420]	; (c005138 <mbedtls_internal_aes_decrypt+0x2a8>)
 c004f94:	406e      	eors	r6, r5
 c004f96:	f85c 5024 	ldr.w	r5, [ip, r4, lsl #2]
 c004f9a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 c004f9e:	f851 0c28 	ldr.w	r0, [r1, #-40]
 c004fa2:	406e      	eors	r6, r5
 c004fa4:	405e      	eors	r6, r3
 c004fa6:	9007      	str	r0, [sp, #28]
 c004fa8:	f851 3c2c 	ldr.w	r3, [r1, #-44]
 c004fac:	b2f8      	uxtb	r0, r7
 c004fae:	9008      	str	r0, [sp, #32]
 c004fb0:	f3c6 2007 	ubfx	r0, r6, #8, #8
 c004fb4:	9305      	str	r3, [sp, #20]
 c004fb6:	9009      	str	r0, [sp, #36]	; 0x24
 c004fb8:	f3ca 4307 	ubfx	r3, sl, #16, #8
 c004fbc:	f3c9 4007 	ubfx	r0, r9, #16, #8
 c004fc0:	9306      	str	r3, [sp, #24]
 c004fc2:	900a      	str	r0, [sp, #40]	; 0x28
 c004fc4:	ea4f 601a 	mov.w	r0, sl, lsr #24
 c004fc8:	900b      	str	r0, [sp, #44]	; 0x2c
 c004fca:	f851 0c24 	ldr.w	r0, [r1, #-36]
 c004fce:	f3c9 2b07 	ubfx	fp, r9, #8, #8
 c004fd2:	900c      	str	r0, [sp, #48]	; 0x30
 c004fd4:	f3c6 4007 	ubfx	r0, r6, #16, #8
 c004fd8:	900d      	str	r0, [sp, #52]	; 0x34
 c004fda:	9800      	ldr	r0, [sp, #0]
 c004fdc:	0e3b      	lsrs	r3, r7, #24
 c004fde:	2800      	cmp	r0, #0
 c004fe0:	ea4f 6416 	mov.w	r4, r6, lsr #24
 c004fe4:	b2f5      	uxtb	r5, r6
 c004fe6:	fa5f fa8a 	uxtb.w	sl, sl
 c004fea:	f3c7 2707 	ubfx	r7, r7, #8, #8
 c004fee:	ea4f 6919 	mov.w	r9, r9, lsr #24
 c004ff2:	dc5d      	bgt.n	c0050b0 <mbedtls_internal_aes_decrypt+0x220>

    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );

    X0 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 c004ff4:	4951      	ldr	r1, [pc, #324]	; (c00513c <mbedtls_internal_aes_decrypt+0x2ac>)
 c004ff6:	9803      	ldr	r0, [sp, #12]
    X0 = *RK++ ^ \
 c004ff8:	9e01      	ldr	r6, [sp, #4]
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 c004ffa:	f811 c000 	ldrb.w	ip, [r1, r0]
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
 c004ffe:	9802      	ldr	r0, [sp, #8]
 c005000:	5c08      	ldrb	r0, [r1, r0]
    X0 = *RK++ ^ \
 c005002:	4070      	eors	r0, r6
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
 c005004:	9e04      	ldr	r6, [sp, #16]
    X0 = *RK++ ^ \
 c005006:	ea80 200c 	eor.w	r0, r0, ip, lsl #8
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
 c00500a:	5d8e      	ldrb	r6, [r1, r6]
    X0 = *RK++ ^ \
 c00500c:	ea80 4006 	eor.w	r0, r0, r6, lsl #16
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
 c005010:	5d0e      	ldrb	r6, [r1, r4]

    X1 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
 c005012:	f811 400b 	ldrb.w	r4, [r1, fp]
    X0 = *RK++ ^ \
 c005016:	ea80 6006 	eor.w	r0, r0, r6, lsl #24
            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
 c00501a:	5d4e      	ldrb	r6, [r1, r5]
    X1 = *RK++ ^ \
 c00501c:	9d05      	ldr	r5, [sp, #20]
 c00501e:	406e      	eors	r6, r5
 c005020:	ea86 2604 	eor.w	r6, r6, r4, lsl #8
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
 c005024:	9c06      	ldr	r4, [sp, #24]
 c005026:	5d0c      	ldrb	r4, [r1, r4]
    X1 = *RK++ ^ \
 c005028:	ea86 4604 	eor.w	r6, r6, r4, lsl #16
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
 c00502c:	5ccc      	ldrb	r4, [r1, r3]

    X2 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 c00502e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    X1 = *RK++ ^ \
 c005030:	ea86 6404 	eor.w	r4, r6, r4, lsl #24
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 c005034:	5cce      	ldrb	r6, [r1, r3]
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
 c005036:	9b08      	ldr	r3, [sp, #32]
 c005038:	5ccd      	ldrb	r5, [r1, r3]
    X2 = *RK++ ^ \
 c00503a:	9b07      	ldr	r3, [sp, #28]
 c00503c:	405d      	eors	r5, r3
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 c00503e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    X2 = *RK++ ^ \
 c005040:	ea85 2506 	eor.w	r5, r5, r6, lsl #8
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 c005044:	5ccb      	ldrb	r3, [r1, r3]
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
 c005046:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    X2 = *RK++ ^ \
 c005048:	ea85 4503 	eor.w	r5, r5, r3, lsl #16
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
 c00504c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 c00504e:	5ccb      	ldrb	r3, [r1, r3]
    X2 = *RK++ ^ \
 c005050:	ea85 6503 	eor.w	r5, r5, r3, lsl #24
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
 c005054:	f811 300a 	ldrb.w	r3, [r1, sl]
    X3 = *RK++ ^ \
 c005058:	4073      	eors	r3, r6
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
 c00505a:	5dce      	ldrb	r6, [r1, r7]
    X3 = *RK++ ^ \
 c00505c:	ea83 2306 	eor.w	r3, r3, r6, lsl #8
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
 c005060:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 c005062:	5d8e      	ldrb	r6, [r1, r6]
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
 c005064:	f811 1009 	ldrb.w	r1, [r1, r9]
    X3 = *RK++ ^ \
 c005068:	ea83 4306 	eor.w	r3, r3, r6, lsl #16
 c00506c:	ea83 6301 	eor.w	r3, r3, r1, lsl #24

    PUT_UINT32_LE( X0, output,  0 );
 c005070:	0a01      	lsrs	r1, r0, #8
 c005072:	7010      	strb	r0, [r2, #0]
 c005074:	7051      	strb	r1, [r2, #1]
 c005076:	0c01      	lsrs	r1, r0, #16
 c005078:	0e00      	lsrs	r0, r0, #24
 c00507a:	7091      	strb	r1, [r2, #2]
 c00507c:	70d0      	strb	r0, [r2, #3]
    PUT_UINT32_LE( X1, output,  4 );
    PUT_UINT32_LE( X2, output,  8 );
    PUT_UINT32_LE( X3, output, 12 );

    return( 0 );
}
 c00507e:	2000      	movs	r0, #0
    PUT_UINT32_LE( X1, output,  4 );
 c005080:	0a21      	lsrs	r1, r4, #8
 c005082:	7151      	strb	r1, [r2, #5]
 c005084:	0c21      	lsrs	r1, r4, #16
 c005086:	7191      	strb	r1, [r2, #6]
    PUT_UINT32_LE( X2, output,  8 );
 c005088:	0a29      	lsrs	r1, r5, #8
 c00508a:	7251      	strb	r1, [r2, #9]
 c00508c:	0c29      	lsrs	r1, r5, #16
 c00508e:	7291      	strb	r1, [r2, #10]
    PUT_UINT32_LE( X3, output, 12 );
 c005090:	0a19      	lsrs	r1, r3, #8
    PUT_UINT32_LE( X1, output,  4 );
 c005092:	7114      	strb	r4, [r2, #4]
    PUT_UINT32_LE( X2, output,  8 );
 c005094:	7215      	strb	r5, [r2, #8]
    PUT_UINT32_LE( X1, output,  4 );
 c005096:	0e24      	lsrs	r4, r4, #24
    PUT_UINT32_LE( X2, output,  8 );
 c005098:	0e2d      	lsrs	r5, r5, #24
    PUT_UINT32_LE( X3, output, 12 );
 c00509a:	7313      	strb	r3, [r2, #12]
 c00509c:	7351      	strb	r1, [r2, #13]
 c00509e:	0c19      	lsrs	r1, r3, #16
 c0050a0:	0e1b      	lsrs	r3, r3, #24
    PUT_UINT32_LE( X1, output,  4 );
 c0050a2:	71d4      	strb	r4, [r2, #7]
    PUT_UINT32_LE( X2, output,  8 );
 c0050a4:	72d5      	strb	r5, [r2, #11]
    PUT_UINT32_LE( X3, output, 12 );
 c0050a6:	7391      	strb	r1, [r2, #14]
 c0050a8:	73d3      	strb	r3, [r2, #15]
}
 c0050aa:	b00f      	add	sp, #60	; 0x3c
 c0050ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 c0050b0:	9e02      	ldr	r6, [sp, #8]
 c0050b2:	f85e 4024 	ldr.w	r4, [lr, r4, lsl #2]
 c0050b6:	f858 6026 	ldr.w	r6, [r8, r6, lsl #2]
 c0050ba:	481f      	ldr	r0, [pc, #124]	; (c005138 <mbedtls_internal_aes_decrypt+0x2a8>)
 c0050bc:	4074      	eors	r4, r6
 c0050be:	9e01      	ldr	r6, [sp, #4]
 c0050c0:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
 c0050c4:	4074      	eors	r4, r6
 c0050c6:	9e03      	ldr	r6, [sp, #12]
 c0050c8:	f85e 9029 	ldr.w	r9, [lr, r9, lsl #2]
 c0050cc:	f85c 6026 	ldr.w	r6, [ip, r6, lsl #2]
 c0050d0:	f85c 7027 	ldr.w	r7, [ip, r7, lsl #2]
 c0050d4:	4074      	eors	r4, r6
 c0050d6:	9e04      	ldr	r6, [sp, #16]
 c0050d8:	f850 6026 	ldr.w	r6, [r0, r6, lsl #2]
 c0050dc:	4074      	eors	r4, r6
 c0050de:	f858 6025 	ldr.w	r6, [r8, r5, lsl #2]
 c0050e2:	405e      	eors	r6, r3
 c0050e4:	9b05      	ldr	r3, [sp, #20]
 c0050e6:	405e      	eors	r6, r3
 c0050e8:	f85c 302b 	ldr.w	r3, [ip, fp, lsl #2]
 c0050ec:	405e      	eors	r6, r3
 c0050ee:	9b06      	ldr	r3, [sp, #24]
 c0050f0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 c0050f4:	405e      	eors	r6, r3
 c0050f6:	9b08      	ldr	r3, [sp, #32]
 c0050f8:	f858 5023 	ldr.w	r5, [r8, r3, lsl #2]
 c0050fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 c0050fe:	f85e 3023 	ldr.w	r3, [lr, r3, lsl #2]
 c005102:	405d      	eors	r5, r3
 c005104:	9b07      	ldr	r3, [sp, #28]
 c005106:	405d      	eors	r5, r3
 c005108:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c00510a:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
 c00510e:	405d      	eors	r5, r3
 c005110:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 c005112:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 c005116:	980c      	ldr	r0, [sp, #48]	; 0x30
 c005118:	405d      	eors	r5, r3
 c00511a:	f858 302a 	ldr.w	r3, [r8, sl, lsl #2]
 c00511e:	ea83 0309 	eor.w	r3, r3, r9
 c005122:	4043      	eors	r3, r0
 c005124:	407b      	eors	r3, r7
 c005126:	980d      	ldr	r0, [sp, #52]	; 0x34
 c005128:	4f03      	ldr	r7, [pc, #12]	; (c005138 <mbedtls_internal_aes_decrypt+0x2a8>)
 c00512a:	f857 7020 	ldr.w	r7, [r7, r0, lsl #2]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 c00512e:	9800      	ldr	r0, [sp, #0]
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 c005130:	407b      	eors	r3, r7
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 c005132:	3801      	subs	r0, #1
 c005134:	9000      	str	r0, [sp, #0]
 c005136:	e6c7      	b.n	c004ec8 <mbedtls_internal_aes_decrypt+0x38>
 c005138:	30031c9c 	.word	0x30031c9c
 c00513c:	3003139c 	.word	0x3003139c
 c005140:	3003149c 	.word	0x3003149c
 c005144:	3003209c 	.word	0x3003209c
 c005148:	3003189c 	.word	0x3003189c

0c00514c <mbedtls_aes_crypt_ecb>:
 */
int mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,
                           int mode,
                           const unsigned char input[16],
                           unsigned char output[16] )
{
 c00514c:	b410      	push	{r4}
 c00514e:	460c      	mov	r4, r1
        // unaccelerated mode
        //
    }
#endif

    if( mode == MBEDTLS_AES_ENCRYPT )
 c005150:	2c01      	cmp	r4, #1
{
 c005152:	4611      	mov	r1, r2
 c005154:	461a      	mov	r2, r3
    if( mode == MBEDTLS_AES_ENCRYPT )
 c005156:	d103      	bne.n	c005160 <mbedtls_aes_crypt_ecb+0x14>
        return( mbedtls_internal_aes_encrypt( ctx, input, output ) );
    else
        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );
}
 c005158:	f85d 4b04 	ldr.w	r4, [sp], #4
        return( mbedtls_internal_aes_encrypt( ctx, input, output ) );
 c00515c:	f7ff bd3c 	b.w	c004bd8 <mbedtls_internal_aes_encrypt>
}
 c005160:	f85d 4b04 	ldr.w	r4, [sp], #4
        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );
 c005164:	f7ff be94 	b.w	c004e90 <mbedtls_internal_aes_decrypt>

0c005168 <mbedtls_asn1_get_len>:
 */
int mbedtls_asn1_get_len( unsigned char **p,
                  const unsigned char *end,
                  size_t *len )
{
    if( ( end - *p ) < 1 )
 c005168:	6803      	ldr	r3, [r0, #0]
{
 c00516a:	b570      	push	{r4, r5, r6, lr}
    if( ( end - *p ) < 1 )
 c00516c:	1acd      	subs	r5, r1, r3
 c00516e:	2d00      	cmp	r5, #0
 c005170:	dd0d      	ble.n	c00518e <mbedtls_asn1_get_len+0x26>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    if( ( **p & 0x80 ) == 0 )
 c005172:	f993 6000 	ldrsb.w	r6, [r3]
 c005176:	781c      	ldrb	r4, [r3, #0]
 c005178:	2e00      	cmp	r6, #0
 c00517a:	db0b      	blt.n	c005194 <mbedtls_asn1_get_len+0x2c>
        *len = *(*p)++;
 c00517c:	1c5c      	adds	r4, r3, #1
 c00517e:	6004      	str	r4, [r0, #0]
 c005180:	781b      	ldrb	r3, [r3, #0]
 c005182:	6013      	str	r3, [r2, #0]
        default:
            return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
        }
    }

    if( *len > (size_t) ( end - *p ) )
 c005184:	6803      	ldr	r3, [r0, #0]
 c005186:	1ac9      	subs	r1, r1, r3
 c005188:	6813      	ldr	r3, [r2, #0]
 c00518a:	428b      	cmp	r3, r1
 c00518c:	d932      	bls.n	c0051f4 <mbedtls_asn1_get_len+0x8c>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 c00518e:	f06f 005f 	mvn.w	r0, #95	; 0x5f

    return( 0 );
}
 c005192:	bd70      	pop	{r4, r5, r6, pc}
        switch( **p & 0x7F )
 c005194:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 c005198:	3c01      	subs	r4, #1
 c00519a:	2c03      	cmp	r4, #3
 c00519c:	d827      	bhi.n	c0051ee <mbedtls_asn1_get_len+0x86>
 c00519e:	e8df f004 	tbb	[pc, r4]
 c0051a2:	0902      	.short	0x0902
 c0051a4:	1e12      	.short	0x1e12
            if( ( end - *p ) < 2 )
 c0051a6:	2d01      	cmp	r5, #1
 c0051a8:	d0f1      	beq.n	c00518e <mbedtls_asn1_get_len+0x26>
            *len = (*p)[1];
 c0051aa:	785c      	ldrb	r4, [r3, #1]
            (*p) += 2;
 c0051ac:	3302      	adds	r3, #2
            *len = (*p)[1];
 c0051ae:	6014      	str	r4, [r2, #0]
            (*p) += 5;
 c0051b0:	6003      	str	r3, [r0, #0]
            break;
 c0051b2:	e7e7      	b.n	c005184 <mbedtls_asn1_get_len+0x1c>
            if( ( end - *p ) < 3 )
 c0051b4:	2d02      	cmp	r5, #2
 c0051b6:	ddea      	ble.n	c00518e <mbedtls_asn1_get_len+0x26>
            *len = ( (size_t)(*p)[1] << 8 ) | (*p)[2];
 c0051b8:	f8b3 4001 	ldrh.w	r4, [r3, #1]
            (*p) += 3;
 c0051bc:	3303      	adds	r3, #3
            *len = ( (size_t)(*p)[1] << 8 ) | (*p)[2];
 c0051be:	ba64      	rev16	r4, r4
 c0051c0:	b2a4      	uxth	r4, r4
 c0051c2:	6014      	str	r4, [r2, #0]
            (*p) += 3;
 c0051c4:	e7f4      	b.n	c0051b0 <mbedtls_asn1_get_len+0x48>
            if( ( end - *p ) < 4 )
 c0051c6:	2d03      	cmp	r5, #3
 c0051c8:	dde1      	ble.n	c00518e <mbedtls_asn1_get_len+0x26>
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c0051ca:	789c      	ldrb	r4, [r3, #2]
            *len = ( (size_t)(*p)[1] << 16 ) |
 c0051cc:	785d      	ldrb	r5, [r3, #1]
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c0051ce:	0224      	lsls	r4, r4, #8
            *len = ( (size_t)(*p)[1] << 16 ) |
 c0051d0:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c0051d4:	78dd      	ldrb	r5, [r3, #3]
            (*p) += 4;
 c0051d6:	3304      	adds	r3, #4
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c0051d8:	432c      	orrs	r4, r5
            *len = ( (size_t)(*p)[1] << 16 ) |
 c0051da:	6014      	str	r4, [r2, #0]
            (*p) += 4;
 c0051dc:	e7e8      	b.n	c0051b0 <mbedtls_asn1_get_len+0x48>
            if( ( end - *p ) < 5 )
 c0051de:	2d04      	cmp	r5, #4
 c0051e0:	ddd5      	ble.n	c00518e <mbedtls_asn1_get_len+0x26>
            *len = ( (size_t)(*p)[1] << 24 ) | ( (size_t)(*p)[2] << 16 ) |
 c0051e2:	f8d3 4001 	ldr.w	r4, [r3, #1]
            (*p) += 5;
 c0051e6:	3305      	adds	r3, #5
 c0051e8:	ba24      	rev	r4, r4
            *len = ( (size_t)(*p)[1] << 24 ) | ( (size_t)(*p)[2] << 16 ) |
 c0051ea:	6014      	str	r4, [r2, #0]
            (*p) += 5;
 c0051ec:	e7e0      	b.n	c0051b0 <mbedtls_asn1_get_len+0x48>
    if( ( **p & 0x80 ) == 0 )
 c0051ee:	f06f 0063 	mvn.w	r0, #99	; 0x63
 c0051f2:	e7ce      	b.n	c005192 <mbedtls_asn1_get_len+0x2a>
    return( 0 );
 c0051f4:	2000      	movs	r0, #0
 c0051f6:	e7cc      	b.n	c005192 <mbedtls_asn1_get_len+0x2a>

0c0051f8 <mbedtls_asn1_get_tag>:

int mbedtls_asn1_get_tag( unsigned char **p,
                  const unsigned char *end,
                  size_t *len, int tag )
{
 c0051f8:	b470      	push	{r4, r5, r6}
    if( ( end - *p ) < 1 )
 c0051fa:	6804      	ldr	r4, [r0, #0]
 c0051fc:	1b0e      	subs	r6, r1, r4
 c0051fe:	2e00      	cmp	r6, #0
 c005200:	dd07      	ble.n	c005212 <mbedtls_asn1_get_tag+0x1a>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    if( **p != tag )
 c005202:	7826      	ldrb	r6, [r4, #0]
 c005204:	429e      	cmp	r6, r3
 c005206:	d108      	bne.n	c00521a <mbedtls_asn1_get_tag+0x22>
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );

    (*p)++;
 c005208:	3401      	adds	r4, #1
 c00520a:	6004      	str	r4, [r0, #0]

    return( mbedtls_asn1_get_len( p, end, len ) );
}
 c00520c:	bc70      	pop	{r4, r5, r6}
    return( mbedtls_asn1_get_len( p, end, len ) );
 c00520e:	f7ff bfab 	b.w	c005168 <mbedtls_asn1_get_len>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 c005212:	f06f 005f 	mvn.w	r0, #95	; 0x5f
}
 c005216:	bc70      	pop	{r4, r5, r6}
 c005218:	4770      	bx	lr
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
 c00521a:	f06f 0061 	mvn.w	r0, #97	; 0x61
 c00521e:	e7fa      	b.n	c005216 <mbedtls_asn1_get_tag+0x1e>

0c005220 <mbedtls_asn1_get_int>:
}

int mbedtls_asn1_get_int( unsigned char **p,
                  const unsigned char *end,
                  int *val )
{
 c005220:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c005222:	2302      	movs	r3, #2
{
 c005224:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c005226:	aa01      	add	r2, sp, #4
{
 c005228:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c00522a:	f7ff ffe5 	bl	c0051f8 <mbedtls_asn1_get_tag>
 c00522e:	b968      	cbnz	r0, c00524c <mbedtls_asn1_get_int+0x2c>
        return( ret );

    if( len == 0 || len > sizeof( int ) || ( **p & 0x80 ) != 0 )
 c005230:	9b01      	ldr	r3, [sp, #4]
 c005232:	3b01      	subs	r3, #1
 c005234:	2b03      	cmp	r3, #3
 c005236:	d814      	bhi.n	c005262 <mbedtls_asn1_get_int+0x42>
 c005238:	6823      	ldr	r3, [r4, #0]
 c00523a:	f993 3000 	ldrsb.w	r3, [r3]
 c00523e:	2b00      	cmp	r3, #0
 c005240:	db0f      	blt.n	c005262 <mbedtls_asn1_get_int+0x42>
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );

    *val = 0;
 c005242:	6028      	str	r0, [r5, #0]

    while( len-- > 0 )
 c005244:	9b01      	ldr	r3, [sp, #4]
 c005246:	1e5a      	subs	r2, r3, #1
 c005248:	9201      	str	r2, [sp, #4]
 c00524a:	b90b      	cbnz	r3, c005250 <mbedtls_asn1_get_int+0x30>
        *val = ( *val << 8 ) | **p;
        (*p)++;
    }

    return( 0 );
}
 c00524c:	b003      	add	sp, #12
 c00524e:	bd30      	pop	{r4, r5, pc}
        *val = ( *val << 8 ) | **p;
 c005250:	6823      	ldr	r3, [r4, #0]
 c005252:	6829      	ldr	r1, [r5, #0]
 c005254:	f813 2b01 	ldrb.w	r2, [r3], #1
 c005258:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 c00525c:	602a      	str	r2, [r5, #0]
        (*p)++;
 c00525e:	6023      	str	r3, [r4, #0]
 c005260:	e7f0      	b.n	c005244 <mbedtls_asn1_get_int+0x24>
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
 c005262:	f06f 0063 	mvn.w	r0, #99	; 0x63
 c005266:	e7f1      	b.n	c00524c <mbedtls_asn1_get_int+0x2c>

0c005268 <mbedtls_asn1_get_mpi>:

#if defined(MBEDTLS_BIGNUM_C)
int mbedtls_asn1_get_mpi( unsigned char **p,
                  const unsigned char *end,
                  mbedtls_mpi *X )
{
 c005268:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c00526a:	2302      	movs	r3, #2
{
 c00526c:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c00526e:	aa01      	add	r2, sp, #4
{
 c005270:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c005272:	f7ff ffc1 	bl	c0051f8 <mbedtls_asn1_get_tag>
 c005276:	b940      	cbnz	r0, c00528a <mbedtls_asn1_get_mpi+0x22>
        return( ret );

    ret = mbedtls_mpi_read_binary( X, *p, len );
 c005278:	9a01      	ldr	r2, [sp, #4]
 c00527a:	4628      	mov	r0, r5
 c00527c:	6821      	ldr	r1, [r4, #0]
 c00527e:	f000 f9e6 	bl	c00564e <mbedtls_mpi_read_binary>

    *p += len;
 c005282:	6823      	ldr	r3, [r4, #0]
 c005284:	9a01      	ldr	r2, [sp, #4]
 c005286:	4413      	add	r3, r2
 c005288:	6023      	str	r3, [r4, #0]

    return( ret );
}
 c00528a:	b003      	add	sp, #12
 c00528c:	bd30      	pop	{r4, r5, pc}

0c00528e <mpi_sub_hlp>:
static void mpi_sub_hlp( size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d )
{
    size_t i;
    mbedtls_mpi_uint c, z;

    for( i = c = 0; i < n; i++, s++, d++ )
 c00528e:	2300      	movs	r3, #0
{
 c005290:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = c = 0; i < n; i++, s++, d++ )
 c005292:	461c      	mov	r4, r3
 c005294:	1f16      	subs	r6, r2, #4
 c005296:	4284      	cmp	r4, r0
 c005298:	d103      	bne.n	c0052a2 <mpi_sub_hlp+0x14>
 c00529a:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    {
        z = ( *d <  c );     *d -=  c;
        c = ( *d < *s ) + z; *d -= *s;
    }

    while( c != 0 )
 c00529e:	b9b3      	cbnz	r3, c0052ce <mpi_sub_hlp+0x40>
    {
        z = ( *d < c ); *d -= c;
        c = z; d++;
    }
}
 c0052a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        z = ( *d <  c );     *d -=  c;
 c0052a2:	f856 cf04 	ldr.w	ip, [r6, #4]!
 c0052a6:	ebac 0503 	sub.w	r5, ip, r3
 c0052aa:	6035      	str	r5, [r6, #0]
        c = ( *d < *s ) + z; *d -= *s;
 c0052ac:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
    for( i = c = 0; i < n; i++, s++, d++ )
 c0052b0:	3401      	adds	r4, #1
        c = ( *d < *s ) + z; *d -= *s;
 c0052b2:	42bd      	cmp	r5, r7
 c0052b4:	bf2c      	ite	cs
 c0052b6:	f04f 0e00 	movcs.w	lr, #0
 c0052ba:	f04f 0e01 	movcc.w	lr, #1
 c0052be:	1bed      	subs	r5, r5, r7
 c0052c0:	459c      	cmp	ip, r3
 c0052c2:	bf2c      	ite	cs
 c0052c4:	4673      	movcs	r3, lr
 c0052c6:	f10e 0301 	addcc.w	r3, lr, #1
 c0052ca:	6035      	str	r5, [r6, #0]
    for( i = c = 0; i < n; i++, s++, d++ )
 c0052cc:	e7e3      	b.n	c005296 <mpi_sub_hlp+0x8>
        z = ( *d < c ); *d -= c;
 c0052ce:	6811      	ldr	r1, [r2, #0]
 c0052d0:	1ac8      	subs	r0, r1, r3
        c = z; d++;
 c0052d2:	4299      	cmp	r1, r3
 c0052d4:	bf2c      	ite	cs
 c0052d6:	2300      	movcs	r3, #0
 c0052d8:	2301      	movcc	r3, #1
        z = ( *d < c ); *d -= c;
 c0052da:	f842 0b04 	str.w	r0, [r2], #4
        c = z; d++;
 c0052de:	e7de      	b.n	c00529e <mpi_sub_hlp+0x10>

0c0052e0 <mpi_mul_hlp>:
 * appears to need this to prevent bad ARM code generation at -O3.
 */
__attribute__ ((noinline))
#endif
void mpi_mul_hlp( size_t i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b )
{
 c0052e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 c0052e2:	4605      	mov	r5, r0
        MULADDC_INIT
        MULADDC_CORE
        MULADDC_STOP
    }
#else /* MULADDC_HUIT */
    for( ; i >= 16; i -= 16 )
 c0052e4:	4607      	mov	r7, r0
    mbedtls_mpi_uint c = 0, t = 0;
 c0052e6:	2400      	movs	r4, #0
    for( ; i >= 16; i -= 16 )
 c0052e8:	2f0f      	cmp	r7, #15
 c0052ea:	d84b      	bhi.n	c005384 <mpi_mul_hlp+0xa4>
 c0052ec:	f06f 000f 	mvn.w	r0, #15
 c0052f0:	092e      	lsrs	r6, r5, #4
 c0052f2:	fb00 5506 	mla	r5, r0, r6, r5
        MULADDC_CORE   MULADDC_CORE
        MULADDC_CORE   MULADDC_CORE
        MULADDC_STOP
    }

    for( ; i >= 8; i -= 8 )
 c0052f6:	2d07      	cmp	r5, #7
 c0052f8:	d93a      	bls.n	c005370 <mpi_mul_hlp+0x90>
    {
        MULADDC_INIT
 c0052fa:	460e      	mov	r6, r1
 c0052fc:	f856 0b04 	ldr.w	r0, [r6], #4
 c005300:	6811      	ldr	r1, [r2, #0]
 c005302:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005306:	f842 1b04 	str.w	r1, [r2], #4
 c00530a:	f856 0b04 	ldr.w	r0, [r6], #4
 c00530e:	6811      	ldr	r1, [r2, #0]
 c005310:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005314:	f842 1b04 	str.w	r1, [r2], #4
 c005318:	f856 0b04 	ldr.w	r0, [r6], #4
 c00531c:	6811      	ldr	r1, [r2, #0]
 c00531e:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005322:	f842 1b04 	str.w	r1, [r2], #4
 c005326:	f856 0b04 	ldr.w	r0, [r6], #4
 c00532a:	6811      	ldr	r1, [r2, #0]
 c00532c:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005330:	f842 1b04 	str.w	r1, [r2], #4
 c005334:	f856 0b04 	ldr.w	r0, [r6], #4
 c005338:	6811      	ldr	r1, [r2, #0]
 c00533a:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00533e:	f842 1b04 	str.w	r1, [r2], #4
 c005342:	f856 0b04 	ldr.w	r0, [r6], #4
 c005346:	6811      	ldr	r1, [r2, #0]
 c005348:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00534c:	f842 1b04 	str.w	r1, [r2], #4
 c005350:	f856 0b04 	ldr.w	r0, [r6], #4
 c005354:	6811      	ldr	r1, [r2, #0]
 c005356:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00535a:	f842 1b04 	str.w	r1, [r2], #4
 c00535e:	f856 0b04 	ldr.w	r0, [r6], #4
 c005362:	6811      	ldr	r1, [r2, #0]
 c005364:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005368:	f842 1b04 	str.w	r1, [r2], #4
 c00536c:	4631      	mov	r1, r6
    for( ; i >= 8; i -= 8 )
 c00536e:	3d08      	subs	r5, #8
        MULADDC_CORE   MULADDC_CORE
        MULADDC_CORE   MULADDC_CORE
        MULADDC_STOP
    }

    for( ; i > 0; i-- )
 c005370:	2d00      	cmp	r5, #0
 c005372:	d17b      	bne.n	c00546c <mpi_mul_hlp+0x18c>
#endif /* MULADDC_HUIT */

    t++;

    do {
        *d += c; c = ( *d < c ); d++;
 c005374:	6813      	ldr	r3, [r2, #0]
 c005376:	191c      	adds	r4, r3, r4
 c005378:	f842 4b04 	str.w	r4, [r2], #4
 c00537c:	f04f 0401 	mov.w	r4, #1
    }
    while( c != 0 );
 c005380:	d2f8      	bcs.n	c005374 <mpi_mul_hlp+0x94>
}
 c005382:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MULADDC_INIT
 c005384:	460e      	mov	r6, r1
 c005386:	f856 0b04 	ldr.w	r0, [r6], #4
 c00538a:	6811      	ldr	r1, [r2, #0]
 c00538c:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005390:	f842 1b04 	str.w	r1, [r2], #4
 c005394:	f856 0b04 	ldr.w	r0, [r6], #4
 c005398:	6811      	ldr	r1, [r2, #0]
 c00539a:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00539e:	f842 1b04 	str.w	r1, [r2], #4
 c0053a2:	f856 0b04 	ldr.w	r0, [r6], #4
 c0053a6:	6811      	ldr	r1, [r2, #0]
 c0053a8:	fbe3 1460 	umaal	r1, r4, r3, r0
 c0053ac:	f842 1b04 	str.w	r1, [r2], #4
 c0053b0:	f856 0b04 	ldr.w	r0, [r6], #4
 c0053b4:	6811      	ldr	r1, [r2, #0]
 c0053b6:	fbe3 1460 	umaal	r1, r4, r3, r0
 c0053ba:	f842 1b04 	str.w	r1, [r2], #4
 c0053be:	f856 0b04 	ldr.w	r0, [r6], #4
 c0053c2:	6811      	ldr	r1, [r2, #0]
 c0053c4:	fbe3 1460 	umaal	r1, r4, r3, r0
 c0053c8:	f842 1b04 	str.w	r1, [r2], #4
 c0053cc:	f856 0b04 	ldr.w	r0, [r6], #4
 c0053d0:	6811      	ldr	r1, [r2, #0]
 c0053d2:	fbe3 1460 	umaal	r1, r4, r3, r0
 c0053d6:	f842 1b04 	str.w	r1, [r2], #4
 c0053da:	f856 0b04 	ldr.w	r0, [r6], #4
 c0053de:	6811      	ldr	r1, [r2, #0]
 c0053e0:	fbe3 1460 	umaal	r1, r4, r3, r0
 c0053e4:	f842 1b04 	str.w	r1, [r2], #4
 c0053e8:	f856 0b04 	ldr.w	r0, [r6], #4
 c0053ec:	6811      	ldr	r1, [r2, #0]
 c0053ee:	fbe3 1460 	umaal	r1, r4, r3, r0
 c0053f2:	f842 1b04 	str.w	r1, [r2], #4
 c0053f6:	f856 0b04 	ldr.w	r0, [r6], #4
 c0053fa:	6811      	ldr	r1, [r2, #0]
 c0053fc:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005400:	f842 1b04 	str.w	r1, [r2], #4
 c005404:	f856 0b04 	ldr.w	r0, [r6], #4
 c005408:	6811      	ldr	r1, [r2, #0]
 c00540a:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00540e:	f842 1b04 	str.w	r1, [r2], #4
 c005412:	f856 0b04 	ldr.w	r0, [r6], #4
 c005416:	6811      	ldr	r1, [r2, #0]
 c005418:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00541c:	f842 1b04 	str.w	r1, [r2], #4
 c005420:	f856 0b04 	ldr.w	r0, [r6], #4
 c005424:	6811      	ldr	r1, [r2, #0]
 c005426:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00542a:	f842 1b04 	str.w	r1, [r2], #4
 c00542e:	f856 0b04 	ldr.w	r0, [r6], #4
 c005432:	6811      	ldr	r1, [r2, #0]
 c005434:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005438:	f842 1b04 	str.w	r1, [r2], #4
 c00543c:	f856 0b04 	ldr.w	r0, [r6], #4
 c005440:	6811      	ldr	r1, [r2, #0]
 c005442:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005446:	f842 1b04 	str.w	r1, [r2], #4
 c00544a:	f856 0b04 	ldr.w	r0, [r6], #4
 c00544e:	6811      	ldr	r1, [r2, #0]
 c005450:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005454:	f842 1b04 	str.w	r1, [r2], #4
 c005458:	f856 0b04 	ldr.w	r0, [r6], #4
 c00545c:	6811      	ldr	r1, [r2, #0]
 c00545e:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005462:	f842 1b04 	str.w	r1, [r2], #4
    for( ; i >= 16; i -= 16 )
 c005466:	3f10      	subs	r7, #16
        MULADDC_INIT
 c005468:	4631      	mov	r1, r6
    for( ; i >= 16; i -= 16 )
 c00546a:	e73d      	b.n	c0052e8 <mpi_mul_hlp+0x8>
        MULADDC_INIT
 c00546c:	460e      	mov	r6, r1
 c00546e:	f856 0b04 	ldr.w	r0, [r6], #4
 c005472:	6811      	ldr	r1, [r2, #0]
 c005474:	fbe3 1460 	umaal	r1, r4, r3, r0
 c005478:	f842 1b04 	str.w	r1, [r2], #4
    for( ; i > 0; i-- )
 c00547c:	3d01      	subs	r5, #1
        MULADDC_INIT
 c00547e:	4631      	mov	r1, r6
    for( ; i > 0; i-- )
 c005480:	e776      	b.n	c005370 <mpi_mul_hlp+0x90>

0c005482 <mpi_bigendian_to_host.part.0>:
    for( cur_limb_left = p, cur_limb_right = p + ( limbs - 1 );
 c005482:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 c005486:	3901      	subs	r1, #1
 c005488:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 c00548c:	4281      	cmp	r1, r0
 c00548e:	4603      	mov	r3, r0
 c005490:	d200      	bcs.n	c005494 <mpi_bigendian_to_host.part.0+0x12>
}
 c005492:	4770      	bx	lr
            return( __builtin_bswap32(x) );
 c005494:	681b      	ldr	r3, [r3, #0]
 c005496:	680a      	ldr	r2, [r1, #0]
 c005498:	ba1b      	rev	r3, r3
 c00549a:	ba12      	rev	r2, r2
        *cur_limb_left  = mpi_uint_bigendian_to_host( *cur_limb_right );
 c00549c:	f840 2b04 	str.w	r2, [r0], #4
        *cur_limb_right = tmp;
 c0054a0:	f841 3904 	str.w	r3, [r1], #-4
         cur_limb_left++, cur_limb_right-- )
 c0054a4:	e7f2      	b.n	c00548c <mpi_bigendian_to_host.part.0+0xa>

0c0054a6 <mbedtls_mpi_init>:
    X->n = 0;
 c0054a6:	2300      	movs	r3, #0
 c0054a8:	2201      	movs	r2, #1
    X->p = NULL;
 c0054aa:	6083      	str	r3, [r0, #8]
    X->n = 0;
 c0054ac:	e9c0 2300 	strd	r2, r3, [r0]
}
 c0054b0:	4770      	bx	lr

0c0054b2 <mbedtls_mpi_free>:
{
 c0054b2:	b510      	push	{r4, lr}
    if( X == NULL )
 c0054b4:	4604      	mov	r4, r0
 c0054b6:	b168      	cbz	r0, c0054d4 <mbedtls_mpi_free+0x22>
    if( X->p != NULL )
 c0054b8:	6880      	ldr	r0, [r0, #8]
 c0054ba:	b130      	cbz	r0, c0054ca <mbedtls_mpi_free+0x18>
    mbedtls_platform_zeroize( v, ciL * n );
 c0054bc:	6861      	ldr	r1, [r4, #4]
 c0054be:	0089      	lsls	r1, r1, #2
 c0054c0:	f001 fc88 	bl	c006dd4 <mbedtls_platform_zeroize>
        mbedtls_free( X->p );
 c0054c4:	68a0      	ldr	r0, [r4, #8]
 c0054c6:	f001 fc75 	bl	c006db4 <mbedtls_free>
    X->n = 0;
 c0054ca:	2300      	movs	r3, #0
 c0054cc:	2201      	movs	r2, #1
 c0054ce:	e9c4 2300 	strd	r2, r3, [r4]
    X->p = NULL;
 c0054d2:	60a3      	str	r3, [r4, #8]
}
 c0054d4:	bd10      	pop	{r4, pc}

0c0054d6 <mbedtls_mpi_grow>:
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 c0054d6:	f242 7310 	movw	r3, #10000	; 0x2710
 c0054da:	4299      	cmp	r1, r3
{
 c0054dc:	b570      	push	{r4, r5, r6, lr}
 c0054de:	4604      	mov	r4, r0
 c0054e0:	460d      	mov	r5, r1
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 c0054e2:	d902      	bls.n	c0054ea <mbedtls_mpi_grow+0x14>
        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
 c0054e4:	f06f 000f 	mvn.w	r0, #15
}
 c0054e8:	bd70      	pop	{r4, r5, r6, pc}
    if( X->n < nblimbs )
 c0054ea:	6843      	ldr	r3, [r0, #4]
 c0054ec:	428b      	cmp	r3, r1
 c0054ee:	d216      	bcs.n	c00551e <mbedtls_mpi_grow+0x48>
        if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )
 c0054f0:	2104      	movs	r1, #4
 c0054f2:	4628      	mov	r0, r5
 c0054f4:	f001 fc58 	bl	c006da8 <mbedtls_calloc>
 c0054f8:	4606      	mov	r6, r0
 c0054fa:	2800      	cmp	r0, #0
 c0054fc:	d0f2      	beq.n	c0054e4 <mbedtls_mpi_grow+0xe>
        if( X->p != NULL )
 c0054fe:	68a1      	ldr	r1, [r4, #8]
 c005500:	b159      	cbz	r1, c00551a <mbedtls_mpi_grow+0x44>
            memcpy( p, X->p, X->n * ciL );
 c005502:	6862      	ldr	r2, [r4, #4]
 c005504:	0092      	lsls	r2, r2, #2
 c005506:	f003 fb41 	bl	c008b8c <memcpy>
    mbedtls_platform_zeroize( v, ciL * n );
 c00550a:	6861      	ldr	r1, [r4, #4]
 c00550c:	68a0      	ldr	r0, [r4, #8]
 c00550e:	0089      	lsls	r1, r1, #2
 c005510:	f001 fc60 	bl	c006dd4 <mbedtls_platform_zeroize>
            mbedtls_free( X->p );
 c005514:	68a0      	ldr	r0, [r4, #8]
 c005516:	f001 fc4d 	bl	c006db4 <mbedtls_free>
        X->p = p;
 c00551a:	e9c4 5601 	strd	r5, r6, [r4, #4]
    return( 0 );
 c00551e:	2000      	movs	r0, #0
 c005520:	e7e2      	b.n	c0054e8 <mbedtls_mpi_grow+0x12>

0c005522 <mbedtls_mpi_copy>:
    if( X == Y )
 c005522:	4288      	cmp	r0, r1
{
 c005524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c005526:	4606      	mov	r6, r0
 c005528:	460f      	mov	r7, r1
    if( X == Y )
 c00552a:	d003      	beq.n	c005534 <mbedtls_mpi_copy+0x12>
    if( Y->p == NULL )
 c00552c:	688d      	ldr	r5, [r1, #8]
 c00552e:	b91d      	cbnz	r5, c005538 <mbedtls_mpi_copy+0x16>
        mbedtls_mpi_free( X );
 c005530:	f7ff ffbf 	bl	c0054b2 <mbedtls_mpi_free>
        return( 0 );
 c005534:	2000      	movs	r0, #0
 c005536:	e011      	b.n	c00555c <mbedtls_mpi_copy+0x3a>
    for( i = Y->n - 1; i > 0; i-- )
 c005538:	684c      	ldr	r4, [r1, #4]
 c00553a:	3c01      	subs	r4, #1
 c00553c:	b11c      	cbz	r4, c005546 <mbedtls_mpi_copy+0x24>
        if( Y->p[i] != 0 )
 c00553e:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 c005542:	2b00      	cmp	r3, #0
 c005544:	d0f9      	beq.n	c00553a <mbedtls_mpi_copy+0x18>
    if( X->n < i )
 c005546:	6872      	ldr	r2, [r6, #4]
    X->s = Y->s;
 c005548:	683b      	ldr	r3, [r7, #0]
    i++;
 c00554a:	3401      	adds	r4, #1
    if( X->n < i )
 c00554c:	42a2      	cmp	r2, r4
    X->s = Y->s;
 c00554e:	6033      	str	r3, [r6, #0]
    if( X->n < i )
 c005550:	d205      	bcs.n	c00555e <mbedtls_mpi_copy+0x3c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i ) );
 c005552:	4621      	mov	r1, r4
 c005554:	4630      	mov	r0, r6
 c005556:	f7ff ffbe 	bl	c0054d6 <mbedtls_mpi_grow>
 c00555a:	b140      	cbz	r0, c00556e <mbedtls_mpi_copy+0x4c>
}
 c00555c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memset( X->p + i, 0, ( X->n - i ) * ciL );
 c00555e:	68b0      	ldr	r0, [r6, #8]
 c005560:	1b12      	subs	r2, r2, r4
 c005562:	2100      	movs	r1, #0
 c005564:	0092      	lsls	r2, r2, #2
 c005566:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 c00556a:	f003 fb1c 	bl	c008ba6 <memset>
    memcpy( X->p, Y->p, i * ciL );
 c00556e:	68b9      	ldr	r1, [r7, #8]
 c005570:	68b0      	ldr	r0, [r6, #8]
 c005572:	00a2      	lsls	r2, r4, #2
 c005574:	f003 fb0a 	bl	c008b8c <memcpy>
 c005578:	e7dc      	b.n	c005534 <mbedtls_mpi_copy+0x12>

0c00557a <mbedtls_mpi_lset>:
{
 c00557a:	b570      	push	{r4, r5, r6, lr}
 c00557c:	460e      	mov	r6, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 c00557e:	2101      	movs	r1, #1
{
 c005580:	4604      	mov	r4, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 c005582:	f7ff ffa8 	bl	c0054d6 <mbedtls_mpi_grow>
 c005586:	4605      	mov	r5, r0
 c005588:	b988      	cbnz	r0, c0055ae <mbedtls_mpi_lset+0x34>
    memset( X->p, 0, X->n * ciL );
 c00558a:	6862      	ldr	r2, [r4, #4]
 c00558c:	4601      	mov	r1, r0
 c00558e:	0092      	lsls	r2, r2, #2
 c005590:	68a0      	ldr	r0, [r4, #8]
 c005592:	f003 fb08 	bl	c008ba6 <memset>
    X->p[0] = ( z < 0 ) ? -z : z;
 c005596:	68a3      	ldr	r3, [r4, #8]
 c005598:	ea86 72e6 	eor.w	r2, r6, r6, asr #31
    X->s    = ( z < 0 ) ? -1 : 1;
 c00559c:	2e00      	cmp	r6, #0
    X->p[0] = ( z < 0 ) ? -z : z;
 c00559e:	eba2 72e6 	sub.w	r2, r2, r6, asr #31
 c0055a2:	601a      	str	r2, [r3, #0]
    X->s    = ( z < 0 ) ? -1 : 1;
 c0055a4:	bfb4      	ite	lt
 c0055a6:	f04f 33ff 	movlt.w	r3, #4294967295
 c0055aa:	2301      	movge	r3, #1
 c0055ac:	6023      	str	r3, [r4, #0]
}
 c0055ae:	4628      	mov	r0, r5
 c0055b0:	bd70      	pop	{r4, r5, r6, pc}

0c0055b2 <mbedtls_mpi_get_bit>:
    if( X->n * biL <= pos )
 c0055b2:	6843      	ldr	r3, [r0, #4]
 c0055b4:	ebb1 1f43 	cmp.w	r1, r3, lsl #5
    return( ( X->p[pos / biL] >> ( pos % biL ) ) & 0x01 );
 c0055b8:	bf3f      	itttt	cc
 c0055ba:	6883      	ldrcc	r3, [r0, #8]
 c0055bc:	094a      	lsrcc	r2, r1, #5
 c0055be:	f853 0022 	ldrcc.w	r0, [r3, r2, lsl #2]
 c0055c2:	f001 011f 	andcc.w	r1, r1, #31
 c0055c6:	bf3a      	itte	cc
 c0055c8:	fa20 f101 	lsrcc.w	r1, r0, r1
 c0055cc:	f001 0001 	andcc.w	r0, r1, #1
        return( 0 );
 c0055d0:	2000      	movcs	r0, #0
}
 c0055d2:	4770      	bx	lr

0c0055d4 <mbedtls_mpi_lsb>:
    size_t i, j, count = 0;
 c0055d4:	2100      	movs	r1, #0
    for( i = 0; i < X->n; i++ )
 c0055d6:	460a      	mov	r2, r1
{
 c0055d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = 0; i < X->n; i++ )
 c0055da:	6845      	ldr	r5, [r0, #4]
 c0055dc:	4295      	cmp	r5, r2
 c0055de:	d102      	bne.n	c0055e6 <mbedtls_mpi_lsb+0x12>
    return( 0 );
 c0055e0:	2400      	movs	r4, #0
}
 c0055e2:	4620      	mov	r0, r4
 c0055e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( ( ( X->p[i] >> j ) & 1 ) != 0 )
 c0055e6:	6883      	ldr	r3, [r0, #8]
 c0055e8:	f853 6022 	ldr.w	r6, [r3, r2, lsl #2]
        for( j = 0; j < biL; j++, count++ )
 c0055ec:	2300      	movs	r3, #0
            if( ( ( X->p[i] >> j ) & 1 ) != 0 )
 c0055ee:	fa26 f703 	lsr.w	r7, r6, r3
 c0055f2:	07ff      	lsls	r7, r7, #31
 c0055f4:	eb01 0403 	add.w	r4, r1, r3
 c0055f8:	d4f3      	bmi.n	c0055e2 <mbedtls_mpi_lsb+0xe>
        for( j = 0; j < biL; j++, count++ )
 c0055fa:	3301      	adds	r3, #1
 c0055fc:	2b20      	cmp	r3, #32
 c0055fe:	eb01 0403 	add.w	r4, r1, r3
 c005602:	d1f4      	bne.n	c0055ee <mbedtls_mpi_lsb+0x1a>
 c005604:	4621      	mov	r1, r4
    for( i = 0; i < X->n; i++ )
 c005606:	3201      	adds	r2, #1
 c005608:	e7e8      	b.n	c0055dc <mbedtls_mpi_lsb+0x8>

0c00560a <mbedtls_mpi_bitlen>:
{
 c00560a:	4602      	mov	r2, r0
    if( X->n == 0 )
 c00560c:	6840      	ldr	r0, [r0, #4]
 c00560e:	b188      	cbz	r0, c005634 <mbedtls_mpi_bitlen+0x2a>
    for( i = X->n - 1; i > 0; i-- )
 c005610:	6892      	ldr	r2, [r2, #8]
 c005612:	1e43      	subs	r3, r0, #1
 c005614:	b97b      	cbnz	r3, c005636 <mbedtls_mpi_bitlen+0x2c>
    j = biL - mbedtls_clz( X->p[i] );
 c005616:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    for( j = 0; j < biL; j++ )
 c00561a:	2000      	movs	r0, #0
    mbedtls_mpi_uint mask = (mbedtls_mpi_uint) 1 << (biL - 1);
 c00561c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
        if( x & mask ) break;
 c005620:	4211      	tst	r1, r2
 c005622:	d104      	bne.n	c00562e <mbedtls_mpi_bitlen+0x24>
    for( j = 0; j < biL; j++ )
 c005624:	3001      	adds	r0, #1
 c005626:	2820      	cmp	r0, #32
        mask >>= 1;
 c005628:	ea4f 0252 	mov.w	r2, r2, lsr #1
    for( j = 0; j < biL; j++ )
 c00562c:	d1f8      	bne.n	c005620 <mbedtls_mpi_bitlen+0x16>
    return( ( i * biL ) + j );
 c00562e:	3301      	adds	r3, #1
 c005630:	ebc0 1043 	rsb	r0, r0, r3, lsl #5
}
 c005634:	4770      	bx	lr
        if( X->p[i] != 0 )
 c005636:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 c00563a:	2900      	cmp	r1, #0
 c00563c:	d1eb      	bne.n	c005616 <mbedtls_mpi_bitlen+0xc>
    for( i = X->n - 1; i > 0; i-- )
 c00563e:	3b01      	subs	r3, #1
 c005640:	e7e8      	b.n	c005614 <mbedtls_mpi_bitlen+0xa>

0c005642 <mbedtls_mpi_size>:
{
 c005642:	b508      	push	{r3, lr}
    return( ( mbedtls_mpi_bitlen( X ) + 7 ) >> 3 );
 c005644:	f7ff ffe1 	bl	c00560a <mbedtls_mpi_bitlen>
 c005648:	3007      	adds	r0, #7
}
 c00564a:	08c0      	lsrs	r0, r0, #3
 c00564c:	bd08      	pop	{r3, pc}

0c00564e <mbedtls_mpi_read_binary>:
{
 c00564e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    size_t const limbs    = CHARS_TO_LIMBS( buflen );
 c005652:	f012 0503 	ands.w	r5, r2, #3
 c005656:	bf18      	it	ne
 c005658:	2501      	movne	r5, #1
    if( X->n != limbs )
 c00565a:	6843      	ldr	r3, [r0, #4]
    size_t const limbs    = CHARS_TO_LIMBS( buflen );
 c00565c:	eb05 0592 	add.w	r5, r5, r2, lsr #2
    if( X->n != limbs )
 c005660:	42ab      	cmp	r3, r5
{
 c005662:	4604      	mov	r4, r0
 c005664:	4688      	mov	r8, r1
 c005666:	4617      	mov	r7, r2
    if( X->n != limbs )
 c005668:	d108      	bne.n	c00567c <mbedtls_mpi_read_binary+0x2e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 c00566a:	2100      	movs	r1, #0
 c00566c:	4620      	mov	r0, r4
 c00566e:	f7ff ff84 	bl	c00557a <mbedtls_mpi_lset>
 c005672:	4606      	mov	r6, r0
 c005674:	b188      	cbz	r0, c00569a <mbedtls_mpi_read_binary+0x4c>
}
 c005676:	4630      	mov	r0, r6
 c005678:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        mbedtls_mpi_free( X );
 c00567c:	f7ff ff19 	bl	c0054b2 <mbedtls_mpi_free>
    X->n = 0;
 c005680:	2300      	movs	r3, #0
 c005682:	2201      	movs	r2, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
 c005684:	4629      	mov	r1, r5
 c005686:	4620      	mov	r0, r4
    X->n = 0;
 c005688:	e9c4 2300 	strd	r2, r3, [r4]
    X->p = NULL;
 c00568c:	60a3      	str	r3, [r4, #8]
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
 c00568e:	f7ff ff22 	bl	c0054d6 <mbedtls_mpi_grow>
 c005692:	4606      	mov	r6, r0
 c005694:	2800      	cmp	r0, #0
 c005696:	d0e8      	beq.n	c00566a <mbedtls_mpi_read_binary+0x1c>
 c005698:	e7ed      	b.n	c005676 <mbedtls_mpi_read_binary+0x28>
    if( buf != NULL )
 c00569a:	f1b8 0f00 	cmp.w	r8, #0
 c00569e:	d0ea      	beq.n	c005676 <mbedtls_mpi_read_binary+0x28>
        memcpy( Xp + overhead, buf, buflen );
 c0056a0:	68a3      	ldr	r3, [r4, #8]
    size_t const overhead = ( limbs * ciL ) - buflen;
 c0056a2:	ebc7 0085 	rsb	r0, r7, r5, lsl #2
        memcpy( Xp + overhead, buf, buflen );
 c0056a6:	463a      	mov	r2, r7
 c0056a8:	4641      	mov	r1, r8
 c0056aa:	4418      	add	r0, r3
 c0056ac:	f003 fa6e 	bl	c008b8c <memcpy>
    if( limbs == 0 )
 c0056b0:	2d00      	cmp	r5, #0
 c0056b2:	d0e0      	beq.n	c005676 <mbedtls_mpi_read_binary+0x28>
 c0056b4:	4629      	mov	r1, r5
 c0056b6:	68a0      	ldr	r0, [r4, #8]
 c0056b8:	f7ff fee3 	bl	c005482 <mpi_bigendian_to_host.part.0>
    return( ret );
 c0056bc:	e7db      	b.n	c005676 <mbedtls_mpi_read_binary+0x28>

0c0056be <mbedtls_mpi_write_binary>:
{
 c0056be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c0056c0:	4604      	mov	r4, r0
    stored_bytes = X->n * ciL;
 c0056c2:	6863      	ldr	r3, [r4, #4]
{
 c0056c4:	4608      	mov	r0, r1
    if( stored_bytes < buflen )
 c0056c6:	ebb2 0f83 	cmp.w	r2, r3, lsl #2
    stored_bytes = X->n * ciL;
 c0056ca:	ea4f 0583 	mov.w	r5, r3, lsl #2
    if( stored_bytes < buflen )
 c0056ce:	d91c      	bls.n	c00570a <mbedtls_mpi_write_binary+0x4c>
        p = buf + buflen - stored_bytes;
 c0056d0:	1b52      	subs	r2, r2, r5
 c0056d2:	188e      	adds	r6, r1, r2
        memset( buf, 0, buflen - stored_bytes );
 c0056d4:	2100      	movs	r1, #0
 c0056d6:	f003 fa66 	bl	c008ba6 <memset>
        p = buf + buflen - stored_bytes;
 c0056da:	4630      	mov	r0, r6
 c0056dc:	462a      	mov	r2, r5
    for( i = 0; i < bytes_to_copy; i++ )
 c0056de:	2300      	movs	r3, #0
 c0056e0:	1881      	adds	r1, r0, r2
 c0056e2:	429a      	cmp	r2, r3
 c0056e4:	d113      	bne.n	c00570e <mbedtls_mpi_write_binary+0x50>
    return( 0 );
 c0056e6:	2000      	movs	r0, #0
}
 c0056e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if( GET_BYTE( X, i ) != 0 )
 c0056ea:	68a7      	ldr	r7, [r4, #8]
 c0056ec:	f003 0103 	and.w	r1, r3, #3
 c0056f0:	f023 0c03 	bic.w	ip, r3, #3
 c0056f4:	00ce      	lsls	r6, r1, #3
 c0056f6:	f857 100c 	ldr.w	r1, [r7, ip]
 c0056fa:	40f1      	lsrs	r1, r6
 c0056fc:	f011 0fff 	tst.w	r1, #255	; 0xff
 c005700:	d111      	bne.n	c005726 <mbedtls_mpi_write_binary+0x68>
        for( i = bytes_to_copy; i < stored_bytes; i++ )
 c005702:	3301      	adds	r3, #1
 c005704:	42ab      	cmp	r3, r5
 c005706:	d1f0      	bne.n	c0056ea <mbedtls_mpi_write_binary+0x2c>
 c005708:	e7e9      	b.n	c0056de <mbedtls_mpi_write_binary+0x20>
 c00570a:	4613      	mov	r3, r2
 c00570c:	e7fa      	b.n	c005704 <mbedtls_mpi_write_binary+0x46>
        p[bytes_to_copy - i - 1] = GET_BYTE( X, i );
 c00570e:	68a7      	ldr	r7, [r4, #8]
 c005710:	f003 0003 	and.w	r0, r3, #3
 c005714:	f023 0603 	bic.w	r6, r3, #3
 c005718:	00c5      	lsls	r5, r0, #3
 c00571a:	59b8      	ldr	r0, [r7, r6]
    for( i = 0; i < bytes_to_copy; i++ )
 c00571c:	3301      	adds	r3, #1
        p[bytes_to_copy - i - 1] = GET_BYTE( X, i );
 c00571e:	40e8      	lsrs	r0, r5
 c005720:	f801 0d01 	strb.w	r0, [r1, #-1]!
    for( i = 0; i < bytes_to_copy; i++ )
 c005724:	e7dd      	b.n	c0056e2 <mbedtls_mpi_write_binary+0x24>
                return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
 c005726:	f06f 0007 	mvn.w	r0, #7
 c00572a:	e7dd      	b.n	c0056e8 <mbedtls_mpi_write_binary+0x2a>

0c00572c <mbedtls_mpi_shift_l>:
{
 c00572c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00572e:	4604      	mov	r4, r0
 c005730:	460e      	mov	r6, r1
    v0 = count / (biL    );
 c005732:	094d      	lsrs	r5, r1, #5
    t1 = count & (biL - 1);
 c005734:	f001 071f 	and.w	r7, r1, #31
    i = mbedtls_mpi_bitlen( X ) + count;
 c005738:	f7ff ff67 	bl	c00560a <mbedtls_mpi_bitlen>
    if( X->n * biL < i )
 c00573c:	6863      	ldr	r3, [r4, #4]
    i = mbedtls_mpi_bitlen( X ) + count;
 c00573e:	4430      	add	r0, r6
    if( X->n * biL < i )
 c005740:	ebb0 1f43 	cmp.w	r0, r3, lsl #5
 c005744:	d804      	bhi.n	c005750 <mbedtls_mpi_shift_l+0x24>
    if( v0 > 0 )
 c005746:	2e1f      	cmp	r6, #31
 c005748:	d80e      	bhi.n	c005768 <mbedtls_mpi_shift_l+0x3c>
    if( t1 > 0 )
 c00574a:	bb5f      	cbnz	r7, c0057a4 <mbedtls_mpi_shift_l+0x78>
    ret = 0;
 c00574c:	2000      	movs	r0, #0
 c00574e:	e00a      	b.n	c005766 <mbedtls_mpi_shift_l+0x3a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, BITS_TO_LIMBS( i ) ) );
 c005750:	f010 011f 	ands.w	r1, r0, #31
 c005754:	bf18      	it	ne
 c005756:	2101      	movne	r1, #1
 c005758:	eb01 1150 	add.w	r1, r1, r0, lsr #5
 c00575c:	4620      	mov	r0, r4
 c00575e:	f7ff feba 	bl	c0054d6 <mbedtls_mpi_grow>
 c005762:	2800      	cmp	r0, #0
 c005764:	d0ef      	beq.n	c005746 <mbedtls_mpi_shift_l+0x1a>
}
 c005766:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        for( i = X->n; i > v0; i-- )
 c005768:	f06f 0003 	mvn.w	r0, #3
 c00576c:	6863      	ldr	r3, [r4, #4]
 c00576e:	4368      	muls	r0, r5
 c005770:	4619      	mov	r1, r3
 c005772:	009a      	lsls	r2, r3, #2
 c005774:	42a9      	cmp	r1, r5
 c005776:	f1a2 0204 	sub.w	r2, r2, #4
 c00577a:	d80a      	bhi.n	c005792 <mbedtls_mpi_shift_l+0x66>
 c00577c:	42ab      	cmp	r3, r5
 c00577e:	bf28      	it	cs
 c005780:	462b      	movcs	r3, r5
            X->p[i - 1] = 0;
 c005782:	2200      	movs	r2, #0
 c005784:	009b      	lsls	r3, r3, #2
        for( ; i > 0; i-- )
 c005786:	3b04      	subs	r3, #4
 c005788:	1d19      	adds	r1, r3, #4
 c00578a:	d0de      	beq.n	c00574a <mbedtls_mpi_shift_l+0x1e>
            X->p[i - 1] = 0;
 c00578c:	68a1      	ldr	r1, [r4, #8]
 c00578e:	50ca      	str	r2, [r1, r3]
        for( ; i > 0; i-- )
 c005790:	e7f9      	b.n	c005786 <mbedtls_mpi_shift_l+0x5a>
            X->p[i - 1] = X->p[i - v0 - 1];
 c005792:	68a6      	ldr	r6, [r4, #8]
        for( i = X->n; i > v0; i-- )
 c005794:	3901      	subs	r1, #1
            X->p[i - 1] = X->p[i - v0 - 1];
 c005796:	eb06 0c02 	add.w	ip, r6, r2
 c00579a:	f85c c000 	ldr.w	ip, [ip, r0]
 c00579e:	f846 c002 	str.w	ip, [r6, r2]
        for( i = X->n; i > v0; i-- )
 c0057a2:	e7e7      	b.n	c005774 <mbedtls_mpi_shift_l+0x48>
    mbedtls_mpi_uint r0 = 0, r1;
 c0057a4:	2200      	movs	r2, #0
        for( i = v0; i < X->n; i++ )
 c0057a6:	6866      	ldr	r6, [r4, #4]
            r1 = X->p[i] >> (biL - t1);
 c0057a8:	f1c7 0c20 	rsb	ip, r7, #32
        for( i = v0; i < X->n; i++ )
 c0057ac:	42ae      	cmp	r6, r5
 c0057ae:	d9cd      	bls.n	c00574c <mbedtls_mpi_shift_l+0x20>
            r1 = X->p[i] >> (biL - t1);
 c0057b0:	68a0      	ldr	r0, [r4, #8]
 c0057b2:	f850 1025 	ldr.w	r1, [r0, r5, lsl #2]
            X->p[i] <<= t1;
 c0057b6:	fa01 f307 	lsl.w	r3, r1, r7
            X->p[i] |= r0;
 c0057ba:	4313      	orrs	r3, r2
 c0057bc:	f840 3025 	str.w	r3, [r0, r5, lsl #2]
            r0 = r1;
 c0057c0:	fa21 f20c 	lsr.w	r2, r1, ip
        for( i = v0; i < X->n; i++ )
 c0057c4:	3501      	adds	r5, #1
 c0057c6:	e7f1      	b.n	c0057ac <mbedtls_mpi_shift_l+0x80>

0c0057c8 <mbedtls_mpi_shift_r>:
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c0057c8:	6843      	ldr	r3, [r0, #4]
{
 c0057ca:	b4f0      	push	{r4, r5, r6, r7}
    v0 = count /  biL;
 c0057cc:	094e      	lsrs	r6, r1, #5
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c0057ce:	42b3      	cmp	r3, r6
    v1 = count & (biL - 1);
 c0057d0:	f001 041f 	and.w	r4, r1, #31
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c0057d4:	d301      	bcc.n	c0057da <mbedtls_mpi_shift_r+0x12>
 c0057d6:	d104      	bne.n	c0057e2 <mbedtls_mpi_shift_r+0x1a>
 c0057d8:	b35c      	cbz	r4, c005832 <mbedtls_mpi_shift_r+0x6a>
}
 c0057da:	bcf0      	pop	{r4, r5, r6, r7}
        return mbedtls_mpi_lset( X, 0 );
 c0057dc:	2100      	movs	r1, #0
 c0057de:	f7ff becc 	b.w	c00557a <mbedtls_mpi_lset>
    if( v0 > 0 )
 c0057e2:	291f      	cmp	r1, #31
 c0057e4:	d827      	bhi.n	c005836 <mbedtls_mpi_shift_r+0x6e>
    if( v1 > 0 )
 c0057e6:	bb04      	cbnz	r4, c00582a <mbedtls_mpi_shift_r+0x62>
}
 c0057e8:	bcf0      	pop	{r4, r5, r6, r7}
 c0057ea:	2000      	movs	r0, #0
 c0057ec:	4770      	bx	lr
            X->p[i] = X->p[i + v0];
 c0057ee:	6882      	ldr	r2, [r0, #8]
 c0057f0:	5957      	ldr	r7, [r2, r5]
 c0057f2:	3504      	adds	r5, #4
 c0057f4:	f842 7021 	str.w	r7, [r2, r1, lsl #2]
        for( i = 0; i < X->n - v0; i++ )
 c0057f8:	3101      	adds	r1, #1
 c0057fa:	1b9a      	subs	r2, r3, r6
 c0057fc:	428a      	cmp	r2, r1
 c0057fe:	d8f6      	bhi.n	c0057ee <mbedtls_mpi_shift_r+0x26>
            X->p[i] = 0;
 c005800:	2100      	movs	r1, #0
        for( ; i < X->n; i++ )
 c005802:	4293      	cmp	r3, r2
 c005804:	d9ef      	bls.n	c0057e6 <mbedtls_mpi_shift_r+0x1e>
            X->p[i] = 0;
 c005806:	6885      	ldr	r5, [r0, #8]
 c005808:	f845 1022 	str.w	r1, [r5, r2, lsl #2]
        for( ; i < X->n; i++ )
 c00580c:	3201      	adds	r2, #1
 c00580e:	e7f8      	b.n	c005802 <mbedtls_mpi_shift_r+0x3a>
            r1 = X->p[i - 1] << (biL - v1);
 c005810:	6886      	ldr	r6, [r0, #8]
 c005812:	f856 5023 	ldr.w	r5, [r6, r3, lsl #2]
            X->p[i - 1] >>= v1;
 c005816:	fa25 f204 	lsr.w	r2, r5, r4
            X->p[i - 1] |= r0;
 c00581a:	430a      	orrs	r2, r1
 c00581c:	f846 2023 	str.w	r2, [r6, r3, lsl #2]
            r0 = r1;
 c005820:	fa05 f107 	lsl.w	r1, r5, r7
        for( i = X->n; i > 0; i-- )
 c005824:	3b01      	subs	r3, #1
 c005826:	d2f3      	bcs.n	c005810 <mbedtls_mpi_shift_r+0x48>
 c005828:	e7de      	b.n	c0057e8 <mbedtls_mpi_shift_r+0x20>
    mbedtls_mpi_uint r0 = 0, r1;
 c00582a:	2100      	movs	r1, #0
            r1 = X->p[i - 1] << (biL - v1);
 c00582c:	f1c4 0720 	rsb	r7, r4, #32
 c005830:	e7f8      	b.n	c005824 <mbedtls_mpi_shift_r+0x5c>
    if( v0 > 0 )
 c005832:	291f      	cmp	r1, #31
 c005834:	d9d8      	bls.n	c0057e8 <mbedtls_mpi_shift_r+0x20>
{
 c005836:	2100      	movs	r1, #0
 c005838:	00b5      	lsls	r5, r6, #2
 c00583a:	e7de      	b.n	c0057fa <mbedtls_mpi_shift_r+0x32>

0c00583c <mbedtls_mpi_cmp_abs>:
{
 c00583c:	b530      	push	{r4, r5, lr}
    for( i = X->n; i > 0; i-- )
 c00583e:	6843      	ldr	r3, [r0, #4]
 c005840:	b92b      	cbnz	r3, c00584e <mbedtls_mpi_cmp_abs+0x12>
    for( j = Y->n; j > 0; j-- )
 c005842:	684a      	ldr	r2, [r1, #4]
 c005844:	b962      	cbnz	r2, c005860 <mbedtls_mpi_cmp_abs+0x24>
    if( i == 0 && j == 0 )
 c005846:	1e18      	subs	r0, r3, #0
 c005848:	bf18      	it	ne
 c00584a:	2001      	movne	r0, #1
 c00584c:	e028      	b.n	c0058a0 <mbedtls_mpi_cmp_abs+0x64>
        if( X->p[i - 1] != 0 )
 c00584e:	6882      	ldr	r2, [r0, #8]
 c005850:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 c005854:	f852 2c04 	ldr.w	r2, [r2, #-4]
 c005858:	2a00      	cmp	r2, #0
 c00585a:	d1f2      	bne.n	c005842 <mbedtls_mpi_cmp_abs+0x6>
    for( i = X->n; i > 0; i-- )
 c00585c:	3b01      	subs	r3, #1
 c00585e:	e7ef      	b.n	c005840 <mbedtls_mpi_cmp_abs+0x4>
        if( Y->p[j - 1] != 0 )
 c005860:	688c      	ldr	r4, [r1, #8]
 c005862:	eb04 0582 	add.w	r5, r4, r2, lsl #2
 c005866:	f855 5c04 	ldr.w	r5, [r5, #-4]
 c00586a:	b985      	cbnz	r5, c00588e <mbedtls_mpi_cmp_abs+0x52>
    for( j = Y->n; j > 0; j-- )
 c00586c:	3a01      	subs	r2, #1
 c00586e:	e7e9      	b.n	c005844 <mbedtls_mpi_cmp_abs+0x8>
        if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
 c005870:	6882      	ldr	r2, [r0, #8]
 c005872:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 c005876:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 c00587a:	4291      	cmp	r1, r2
 c00587c:	d805      	bhi.n	c00588a <mbedtls_mpi_cmp_abs+0x4e>
        if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
 c00587e:	f103 33ff 	add.w	r3, r3, #4294967295
 c005882:	d20a      	bcs.n	c00589a <mbedtls_mpi_cmp_abs+0x5e>
    if( j > i ) return( -1 );
 c005884:	f04f 30ff 	mov.w	r0, #4294967295
 c005888:	e00a      	b.n	c0058a0 <mbedtls_mpi_cmp_abs+0x64>
    if( i > j ) return(  1 );
 c00588a:	2001      	movs	r0, #1
 c00588c:	e008      	b.n	c0058a0 <mbedtls_mpi_cmp_abs+0x64>
    if( i == 0 && j == 0 )
 c00588e:	b10b      	cbz	r3, c005894 <mbedtls_mpi_cmp_abs+0x58>
    if( i > j ) return(  1 );
 c005890:	4293      	cmp	r3, r2
 c005892:	d8fa      	bhi.n	c00588a <mbedtls_mpi_cmp_abs+0x4e>
    if( j > i ) return( -1 );
 c005894:	4293      	cmp	r3, r2
 c005896:	d3f5      	bcc.n	c005884 <mbedtls_mpi_cmp_abs+0x48>
 c005898:	3b01      	subs	r3, #1
    for( ; i > 0; i-- )
 c00589a:	1c5a      	adds	r2, r3, #1
 c00589c:	d1e8      	bne.n	c005870 <mbedtls_mpi_cmp_abs+0x34>
    return( 0 );
 c00589e:	2000      	movs	r0, #0
}
 c0058a0:	bd30      	pop	{r4, r5, pc}

0c0058a2 <mpi_montmul>:
/*
 * Montgomery multiplication: A = A * B * R^-1 mod N  (HAC 14.36)
 */
static int mpi_montmul( mbedtls_mpi *A, const mbedtls_mpi *B, const mbedtls_mpi *N, mbedtls_mpi_uint mm,
                         const mbedtls_mpi *T )
{
 c0058a2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0058a6:	4615      	mov	r5, r2
 c0058a8:	9301      	str	r3, [sp, #4]
    size_t i, n, m;
    mbedtls_mpi_uint u0, u1, *d;

    if( T->n < N->n + 1 || T->p == NULL )
 c0058aa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
{
 c0058ac:	4606      	mov	r6, r0
    if( T->n < N->n + 1 || T->p == NULL )
 c0058ae:	685a      	ldr	r2, [r3, #4]
 c0058b0:	686b      	ldr	r3, [r5, #4]
{
 c0058b2:	468a      	mov	sl, r1
    if( T->n < N->n + 1 || T->p == NULL )
 c0058b4:	3301      	adds	r3, #1
 c0058b6:	429a      	cmp	r2, r3
 c0058b8:	d357      	bcc.n	c00596a <mpi_montmul+0xc8>
 c0058ba:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 c0058bc:	6898      	ldr	r0, [r3, #8]
 c0058be:	2800      	cmp	r0, #0
 c0058c0:	d053      	beq.n	c00596a <mpi_montmul+0xc8>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );

    memset( T->p, 0, T->n * ciL );
 c0058c2:	2100      	movs	r1, #0
 c0058c4:	0092      	lsls	r2, r2, #2
 c0058c6:	f003 f96e 	bl	c008ba6 <memset>

    d = T->p;
 c0058ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    n = N->n;
 c0058cc:	f8d5 9004 	ldr.w	r9, [r5, #4]
    d = T->p;
 c0058d0:	689b      	ldr	r3, [r3, #8]
    m = ( B->n < n ) ? B->n : n;

    for( i = 0; i < n; i++ )
 c0058d2:	2400      	movs	r4, #0
    d = T->p;
 c0058d4:	9300      	str	r3, [sp, #0]
    m = ( B->n < n ) ? B->n : n;
 c0058d6:	f8da 3004 	ldr.w	r3, [sl, #4]
        u1 = ( d[0] + u0 * B->p[0] ) * mm;

        mpi_mul_hlp( m, B->p, d, u0 );
        mpi_mul_hlp( n, N->p, d, u1 );

        *d++ = u0; d[n + 1] = 0;
 c0058da:	f109 0701 	add.w	r7, r9, #1
    m = ( B->n < n ) ? B->n : n;
 c0058de:	454b      	cmp	r3, r9
 c0058e0:	bf28      	it	cs
 c0058e2:	464b      	movcs	r3, r9
 c0058e4:	ee07 3a90 	vmov	s15, r3
    d = T->p;
 c0058e8:	f8dd 8000 	ldr.w	r8, [sp]
        *d++ = u0; d[n + 1] = 0;
 c0058ec:	00bf      	lsls	r7, r7, #2
    for( i = 0; i < n; i++ )
 c0058ee:	454c      	cmp	r4, r9
 c0058f0:	68b0      	ldr	r0, [r6, #8]
 c0058f2:	d119      	bne.n	c005928 <mpi_montmul+0x86>
    }

    memcpy( A->p, d, ( n + 1 ) * ciL );
 c0058f4:	9b00      	ldr	r3, [sp, #0]
 c0058f6:	1f39      	subs	r1, r7, #4
 c0058f8:	440b      	add	r3, r1
 c0058fa:	463a      	mov	r2, r7
 c0058fc:	4619      	mov	r1, r3
 c0058fe:	f003 f945 	bl	c008b8c <memcpy>

    if( mbedtls_mpi_cmp_abs( A, N ) >= 0 )
 c005902:	4629      	mov	r1, r5
 c005904:	4630      	mov	r0, r6
 c005906:	f7ff ff99 	bl	c00583c <mbedtls_mpi_cmp_abs>
 c00590a:	2800      	cmp	r0, #0
        mpi_sub_hlp( n, N->p, A->p );
    else
        /* prevent timing attacks */
        mpi_sub_hlp( n, A->p, T->p );
 c00590c:	bfb8      	it	lt
 c00590e:	9b0c      	ldrlt	r3, [sp, #48]	; 0x30
 c005910:	4620      	mov	r0, r4
        mpi_sub_hlp( n, N->p, A->p );
 c005912:	bfa7      	ittee	ge
 c005914:	68b2      	ldrge	r2, [r6, #8]
 c005916:	68a9      	ldrge	r1, [r5, #8]
        mpi_sub_hlp( n, A->p, T->p );
 c005918:	689a      	ldrlt	r2, [r3, #8]
 c00591a:	68b1      	ldrlt	r1, [r6, #8]
 c00591c:	f7ff fcb7 	bl	c00528e <mpi_sub_hlp>

    return( 0 );
 c005920:	2000      	movs	r0, #0
}
 c005922:	b003      	add	sp, #12
 c005924:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c005928:	f8da 1008 	ldr.w	r1, [sl, #8]
        u0 = A->p[i];
 c00592c:	f850 b024 	ldr.w	fp, [r0, r4, lsl #2]
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c005930:	680b      	ldr	r3, [r1, #0]
 c005932:	f8d8 0000 	ldr.w	r0, [r8]
 c005936:	9a01      	ldr	r2, [sp, #4]
 c005938:	fb03 030b 	mla	r3, r3, fp, r0
 c00593c:	4353      	muls	r3, r2
        mpi_mul_hlp( m, B->p, d, u0 );
 c00593e:	ee17 0a90 	vmov	r0, s15
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c005942:	ee07 3a10 	vmov	s14, r3
        mpi_mul_hlp( m, B->p, d, u0 );
 c005946:	4642      	mov	r2, r8
 c005948:	465b      	mov	r3, fp
 c00594a:	f7ff fcc9 	bl	c0052e0 <mpi_mul_hlp>
        mpi_mul_hlp( n, N->p, d, u1 );
 c00594e:	4642      	mov	r2, r8
 c005950:	ee17 3a10 	vmov	r3, s14
 c005954:	4648      	mov	r0, r9
 c005956:	68a9      	ldr	r1, [r5, #8]
 c005958:	f7ff fcc2 	bl	c0052e0 <mpi_mul_hlp>
        *d++ = u0; d[n + 1] = 0;
 c00595c:	2300      	movs	r3, #0
 c00595e:	f848 bb04 	str.w	fp, [r8], #4
 c005962:	f848 3007 	str.w	r3, [r8, r7]
    for( i = 0; i < n; i++ )
 c005966:	3401      	adds	r4, #1
 c005968:	e7c1      	b.n	c0058ee <mpi_montmul+0x4c>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c00596a:	f06f 0003 	mvn.w	r0, #3
 c00596e:	e7d8      	b.n	c005922 <mpi_montmul+0x80>

0c005970 <mbedtls_mpi_cmp_mpi>:
{
 c005970:	4602      	mov	r2, r0
 c005972:	b530      	push	{r4, r5, lr}
    for( i = X->n; i > 0; i-- )
 c005974:	6843      	ldr	r3, [r0, #4]
 c005976:	b923      	cbnz	r3, c005982 <mbedtls_mpi_cmp_mpi+0x12>
    for( j = Y->n; j > 0; j-- )
 c005978:	6848      	ldr	r0, [r1, #4]
 c00597a:	b958      	cbnz	r0, c005994 <mbedtls_mpi_cmp_mpi+0x24>
    if( i == 0 && j == 0 )
 c00597c:	2b00      	cmp	r3, #0
 c00597e:	d138      	bne.n	c0059f2 <mbedtls_mpi_cmp_mpi+0x82>
 c005980:	e031      	b.n	c0059e6 <mbedtls_mpi_cmp_mpi+0x76>
        if( X->p[i - 1] != 0 )
 c005982:	6890      	ldr	r0, [r2, #8]
 c005984:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 c005988:	f850 0c04 	ldr.w	r0, [r0, #-4]
 c00598c:	2800      	cmp	r0, #0
 c00598e:	d1f3      	bne.n	c005978 <mbedtls_mpi_cmp_mpi+0x8>
    for( i = X->n; i > 0; i-- )
 c005990:	3b01      	subs	r3, #1
 c005992:	e7f0      	b.n	c005976 <mbedtls_mpi_cmp_mpi+0x6>
        if( Y->p[j - 1] != 0 )
 c005994:	688c      	ldr	r4, [r1, #8]
 c005996:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 c00599a:	f855 5c04 	ldr.w	r5, [r5, #-4]
 c00599e:	bb25      	cbnz	r5, c0059ea <mbedtls_mpi_cmp_mpi+0x7a>
    for( j = Y->n; j > 0; j-- )
 c0059a0:	3801      	subs	r0, #1
 c0059a2:	e7ea      	b.n	c00597a <mbedtls_mpi_cmp_mpi+0xa>
    if( j > i ) return( -Y->s );
 c0059a4:	4283      	cmp	r3, r0
 c0059a6:	6809      	ldr	r1, [r1, #0]
 c0059a8:	d201      	bcs.n	c0059ae <mbedtls_mpi_cmp_mpi+0x3e>
 c0059aa:	4248      	negs	r0, r1
 c0059ac:	e022      	b.n	c0059f4 <mbedtls_mpi_cmp_mpi+0x84>
    if( X->s > 0 && Y->s < 0 ) return(  1 );
 c0059ae:	6810      	ldr	r0, [r2, #0]
 c0059b0:	2800      	cmp	r0, #0
 c0059b2:	dd03      	ble.n	c0059bc <mbedtls_mpi_cmp_mpi+0x4c>
 c0059b4:	2900      	cmp	r1, #0
 c0059b6:	da13      	bge.n	c0059e0 <mbedtls_mpi_cmp_mpi+0x70>
 c0059b8:	2001      	movs	r0, #1
 c0059ba:	e01b      	b.n	c0059f4 <mbedtls_mpi_cmp_mpi+0x84>
    if( Y->s > 0 && X->s < 0 ) return( -1 );
 c0059bc:	2900      	cmp	r1, #0
 c0059be:	dd0f      	ble.n	c0059e0 <mbedtls_mpi_cmp_mpi+0x70>
 c0059c0:	b170      	cbz	r0, c0059e0 <mbedtls_mpi_cmp_mpi+0x70>
 c0059c2:	f04f 30ff 	mov.w	r0, #4294967295
 c0059c6:	e015      	b.n	c0059f4 <mbedtls_mpi_cmp_mpi+0x84>
        if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
 c0059c8:	6891      	ldr	r1, [r2, #8]
 c0059ca:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
 c0059ce:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
 c0059d2:	428d      	cmp	r5, r1
 c0059d4:	d80e      	bhi.n	c0059f4 <mbedtls_mpi_cmp_mpi+0x84>
        if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
 c0059d6:	f103 33ff 	add.w	r3, r3, #4294967295
 c0059da:	d202      	bcs.n	c0059e2 <mbedtls_mpi_cmp_mpi+0x72>
 c0059dc:	4240      	negs	r0, r0
 c0059de:	e009      	b.n	c0059f4 <mbedtls_mpi_cmp_mpi+0x84>
 c0059e0:	3b01      	subs	r3, #1
    for( ; i > 0; i-- )
 c0059e2:	1c59      	adds	r1, r3, #1
 c0059e4:	d1f0      	bne.n	c0059c8 <mbedtls_mpi_cmp_mpi+0x58>
    return( 0 );
 c0059e6:	2000      	movs	r0, #0
 c0059e8:	e004      	b.n	c0059f4 <mbedtls_mpi_cmp_mpi+0x84>
    if( i == 0 && j == 0 )
 c0059ea:	2b00      	cmp	r3, #0
 c0059ec:	d0da      	beq.n	c0059a4 <mbedtls_mpi_cmp_mpi+0x34>
    if( i > j ) return(  X->s );
 c0059ee:	4283      	cmp	r3, r0
 c0059f0:	d9d8      	bls.n	c0059a4 <mbedtls_mpi_cmp_mpi+0x34>
 c0059f2:	6810      	ldr	r0, [r2, #0]
}
 c0059f4:	bd30      	pop	{r4, r5, pc}

0c0059f6 <mbedtls_mpi_cmp_int>:
{
 c0059f6:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    *p  = ( z < 0 ) ? -z : z;
 c0059f8:	ea81 73e1 	eor.w	r3, r1, r1, asr #31
 c0059fc:	eba3 73e1 	sub.w	r3, r3, r1, asr #31
    Y.s = ( z < 0 ) ? -1 : 1;
 c005a00:	2900      	cmp	r1, #0
    *p  = ( z < 0 ) ? -z : z;
 c005a02:	9300      	str	r3, [sp, #0]
    Y.s = ( z < 0 ) ? -1 : 1;
 c005a04:	bfb4      	ite	lt
 c005a06:	f04f 33ff 	movlt.w	r3, #4294967295
 c005a0a:	2301      	movge	r3, #1
 c005a0c:	9301      	str	r3, [sp, #4]
    Y.n = 1;
 c005a0e:	2301      	movs	r3, #1
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 c005a10:	a901      	add	r1, sp, #4
    Y.n = 1;
 c005a12:	9302      	str	r3, [sp, #8]
    Y.p = p;
 c005a14:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 c005a18:	f7ff ffaa 	bl	c005970 <mbedtls_mpi_cmp_mpi>
}
 c005a1c:	b005      	add	sp, #20
 c005a1e:	f85d fb04 	ldr.w	pc, [sp], #4

0c005a22 <mbedtls_mpi_add_abs>:
    if( X == B )
 c005a22:	4290      	cmp	r0, r2
{
 c005a24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c005a28:	4607      	mov	r7, r0
 c005a2a:	460d      	mov	r5, r1
 c005a2c:	4616      	mov	r6, r2
    if( X == B )
 c005a2e:	d002      	beq.n	c005a36 <mbedtls_mpi_add_abs+0x14>
    if( X != A )
 c005a30:	4288      	cmp	r0, r1
 c005a32:	d129      	bne.n	c005a88 <mbedtls_mpi_add_abs+0x66>
{
 c005a34:	4635      	mov	r5, r6
    X->s = 1;
 c005a36:	2301      	movs	r3, #1
    for( j = B->n; j > 0; j-- )
 c005a38:	686e      	ldr	r6, [r5, #4]
    X->s = 1;
 c005a3a:	603b      	str	r3, [r7, #0]
    for( j = B->n; j > 0; j-- )
 c005a3c:	bb66      	cbnz	r6, c005a98 <mbedtls_mpi_add_abs+0x76>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 c005a3e:	4631      	mov	r1, r6
 c005a40:	4638      	mov	r0, r7
 c005a42:	f7ff fd48 	bl	c0054d6 <mbedtls_mpi_grow>
 c005a46:	4604      	mov	r4, r0
 c005a48:	bb18      	cbnz	r0, c005a92 <mbedtls_mpi_add_abs+0x70>
    o = B->p; p = X->p; c = 0;
 c005a4a:	68a9      	ldr	r1, [r5, #8]
 c005a4c:	4605      	mov	r5, r0
 c005a4e:	68bb      	ldr	r3, [r7, #8]
    for( i = 0; i < j; i++, o++, p++ )
 c005a50:	4286      	cmp	r6, r0
 c005a52:	d12a      	bne.n	c005aaa <mbedtls_mpi_add_abs+0x88>
 c005a54:	eb03 0386 	add.w	r3, r3, r6, lsl #2
    while( c != 0 )
 c005a58:	b1dd      	cbz	r5, c005a92 <mbedtls_mpi_add_abs+0x70>
        if( i >= X->n )
 c005a5a:	687a      	ldr	r2, [r7, #4]
 c005a5c:	f106 0801 	add.w	r8, r6, #1
 c005a60:	42b2      	cmp	r2, r6
 c005a62:	d808      	bhi.n	c005a76 <mbedtls_mpi_add_abs+0x54>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 c005a64:	4641      	mov	r1, r8
 c005a66:	4638      	mov	r0, r7
 c005a68:	f7ff fd35 	bl	c0054d6 <mbedtls_mpi_grow>
 c005a6c:	2800      	cmp	r0, #0
 c005a6e:	d12f      	bne.n	c005ad0 <mbedtls_mpi_add_abs+0xae>
            p = X->p + i;
 c005a70:	68bb      	ldr	r3, [r7, #8]
 c005a72:	eb03 0386 	add.w	r3, r3, r6, lsl #2
        *p += c; c = ( *p < c ); i++; p++;
 c005a76:	681a      	ldr	r2, [r3, #0]
 c005a78:	4646      	mov	r6, r8
 c005a7a:	1955      	adds	r5, r2, r5
 c005a7c:	f843 5b04 	str.w	r5, [r3], #4
 c005a80:	bf2c      	ite	cs
 c005a82:	2501      	movcs	r5, #1
 c005a84:	2500      	movcc	r5, #0
 c005a86:	e7e7      	b.n	c005a58 <mbedtls_mpi_add_abs+0x36>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 c005a88:	f7ff fd4b 	bl	c005522 <mbedtls_mpi_copy>
 c005a8c:	4604      	mov	r4, r0
 c005a8e:	2800      	cmp	r0, #0
 c005a90:	d0d0      	beq.n	c005a34 <mbedtls_mpi_add_abs+0x12>
}
 c005a92:	4620      	mov	r0, r4
 c005a94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( B->p[j - 1] != 0 )
 c005a98:	68ab      	ldr	r3, [r5, #8]
 c005a9a:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 c005a9e:	f853 3c04 	ldr.w	r3, [r3, #-4]
 c005aa2:	2b00      	cmp	r3, #0
 c005aa4:	d1cb      	bne.n	c005a3e <mbedtls_mpi_add_abs+0x1c>
    for( j = B->n; j > 0; j-- )
 c005aa6:	3e01      	subs	r6, #1
 c005aa8:	e7c8      	b.n	c005a3c <mbedtls_mpi_add_abs+0x1a>
        *p +=  c; c  = ( *p <  c );
 c005aaa:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 c005aae:	eb12 0c05 	adds.w	ip, r2, r5
 c005ab2:	f851 2020 	ldr.w	r2, [r1, r0, lsl #2]
 c005ab6:	bf2c      	ite	cs
 c005ab8:	2501      	movcs	r5, #1
 c005aba:	2500      	movcc	r5, #0
        *p += tmp; c += ( *p < tmp );
 c005abc:	eb1c 0202 	adds.w	r2, ip, r2
 c005ac0:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
 c005ac4:	bf2c      	ite	cs
 c005ac6:	2201      	movcs	r2, #1
 c005ac8:	2200      	movcc	r2, #0
    for( i = 0; i < j; i++, o++, p++ )
 c005aca:	3001      	adds	r0, #1
        *p += tmp; c += ( *p < tmp );
 c005acc:	4415      	add	r5, r2
    for( i = 0; i < j; i++, o++, p++ )
 c005ace:	e7bf      	b.n	c005a50 <mbedtls_mpi_add_abs+0x2e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 c005ad0:	4604      	mov	r4, r0
    return( ret );
 c005ad2:	e7de      	b.n	c005a92 <mbedtls_mpi_add_abs+0x70>

0c005ad4 <mbedtls_mpi_sub_abs>:
{
 c005ad4:	b5f0      	push	{r4, r5, r6, r7, lr}
 c005ad6:	460f      	mov	r7, r1
 c005ad8:	4606      	mov	r6, r0
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c005ada:	4611      	mov	r1, r2
 c005adc:	4638      	mov	r0, r7
{
 c005ade:	b085      	sub	sp, #20
 c005ae0:	4615      	mov	r5, r2
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c005ae2:	f7ff feab 	bl	c00583c <mbedtls_mpi_cmp_abs>
 c005ae6:	2800      	cmp	r0, #0
 c005ae8:	db2e      	blt.n	c005b48 <mbedtls_mpi_sub_abs+0x74>
    X->n = 0;
 c005aea:	2300      	movs	r3, #0
 c005aec:	2201      	movs	r2, #1
    if( X == B )
 c005aee:	42b5      	cmp	r5, r6
    X->n = 0;
 c005af0:	e9cd 2301 	strd	r2, r3, [sp, #4]
    X->p = NULL;
 c005af4:	9303      	str	r3, [sp, #12]
    if( X == B )
 c005af6:	d106      	bne.n	c005b06 <mbedtls_mpi_sub_abs+0x32>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
 c005af8:	4629      	mov	r1, r5
 c005afa:	a801      	add	r0, sp, #4
 c005afc:	f7ff fd11 	bl	c005522 <mbedtls_mpi_copy>
 c005b00:	4604      	mov	r4, r0
 c005b02:	b998      	cbnz	r0, c005b2c <mbedtls_mpi_sub_abs+0x58>
        B = &TB;
 c005b04:	ad01      	add	r5, sp, #4
    if( X != A )
 c005b06:	42b7      	cmp	r7, r6
 c005b08:	d109      	bne.n	c005b1e <mbedtls_mpi_sub_abs+0x4a>
    X->s = 1;
 c005b0a:	e9d5 0101 	ldrd	r0, r1, [r5, #4]
 c005b0e:	2301      	movs	r3, #1
 c005b10:	6033      	str	r3, [r6, #0]
    for( n = B->n; n > 0; n-- )
 c005b12:	b988      	cbnz	r0, c005b38 <mbedtls_mpi_sub_abs+0x64>
    mpi_sub_hlp( n, B->p, X->p );
 c005b14:	68b2      	ldr	r2, [r6, #8]
 c005b16:	f7ff fbba 	bl	c00528e <mpi_sub_hlp>
    ret = 0;
 c005b1a:	2400      	movs	r4, #0
 c005b1c:	e006      	b.n	c005b2c <mbedtls_mpi_sub_abs+0x58>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 c005b1e:	4639      	mov	r1, r7
 c005b20:	4630      	mov	r0, r6
 c005b22:	f7ff fcfe 	bl	c005522 <mbedtls_mpi_copy>
 c005b26:	4604      	mov	r4, r0
 c005b28:	2800      	cmp	r0, #0
 c005b2a:	d0ee      	beq.n	c005b0a <mbedtls_mpi_sub_abs+0x36>
    mbedtls_mpi_free( &TB );
 c005b2c:	a801      	add	r0, sp, #4
 c005b2e:	f7ff fcc0 	bl	c0054b2 <mbedtls_mpi_free>
}
 c005b32:	4620      	mov	r0, r4
 c005b34:	b005      	add	sp, #20
 c005b36:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( B->p[n - 1] != 0 )
 c005b38:	eb01 0380 	add.w	r3, r1, r0, lsl #2
 c005b3c:	f853 3c04 	ldr.w	r3, [r3, #-4]
 c005b40:	2b00      	cmp	r3, #0
 c005b42:	d1e7      	bne.n	c005b14 <mbedtls_mpi_sub_abs+0x40>
    for( n = B->n; n > 0; n-- )
 c005b44:	3801      	subs	r0, #1
 c005b46:	e7e4      	b.n	c005b12 <mbedtls_mpi_sub_abs+0x3e>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 c005b48:	f06f 0409 	mvn.w	r4, #9
 c005b4c:	e7f1      	b.n	c005b32 <mbedtls_mpi_sub_abs+0x5e>

0c005b4e <mbedtls_mpi_add_mpi>:
{
 c005b4e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    s = A->s;
 c005b50:	680d      	ldr	r5, [r1, #0]
    if( A->s * B->s < 0 )
 c005b52:	6813      	ldr	r3, [r2, #0]
{
 c005b54:	4604      	mov	r4, r0
    if( A->s * B->s < 0 )
 c005b56:	436b      	muls	r3, r5
{
 c005b58:	460f      	mov	r7, r1
 c005b5a:	4616      	mov	r6, r2
    if( A->s * B->s < 0 )
 c005b5c:	d516      	bpl.n	c005b8c <mbedtls_mpi_add_mpi+0x3e>
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 c005b5e:	4611      	mov	r1, r2
 c005b60:	4638      	mov	r0, r7
 c005b62:	f7ff fe6b 	bl	c00583c <mbedtls_mpi_cmp_abs>
 c005b66:	2800      	cmp	r0, #0
 c005b68:	db06      	blt.n	c005b78 <mbedtls_mpi_add_mpi+0x2a>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 c005b6a:	4632      	mov	r2, r6
 c005b6c:	4639      	mov	r1, r7
 c005b6e:	4620      	mov	r0, r4
 c005b70:	f7ff ffb0 	bl	c005ad4 <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c005b74:	b140      	cbz	r0, c005b88 <mbedtls_mpi_add_mpi+0x3a>
}
 c005b76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 c005b78:	463a      	mov	r2, r7
 c005b7a:	4631      	mov	r1, r6
 c005b7c:	4620      	mov	r0, r4
 c005b7e:	f7ff ffa9 	bl	c005ad4 <mbedtls_mpi_sub_abs>
 c005b82:	2800      	cmp	r0, #0
 c005b84:	d1f7      	bne.n	c005b76 <mbedtls_mpi_add_mpi+0x28>
            X->s = -s;
 c005b86:	426d      	negs	r5, r5
        X->s = s;
 c005b88:	6025      	str	r5, [r4, #0]
    return( ret );
 c005b8a:	e7f4      	b.n	c005b76 <mbedtls_mpi_add_mpi+0x28>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c005b8c:	f7ff ff49 	bl	c005a22 <mbedtls_mpi_add_abs>
 c005b90:	e7f0      	b.n	c005b74 <mbedtls_mpi_add_mpi+0x26>

0c005b92 <mbedtls_mpi_sub_mpi>:
{
 c005b92:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    s = A->s;
 c005b94:	680d      	ldr	r5, [r1, #0]
    if( A->s * B->s > 0 )
 c005b96:	6813      	ldr	r3, [r2, #0]
{
 c005b98:	4604      	mov	r4, r0
    if( A->s * B->s > 0 )
 c005b9a:	436b      	muls	r3, r5
 c005b9c:	2b00      	cmp	r3, #0
{
 c005b9e:	460f      	mov	r7, r1
 c005ba0:	4616      	mov	r6, r2
    if( A->s * B->s > 0 )
 c005ba2:	dd16      	ble.n	c005bd2 <mbedtls_mpi_sub_mpi+0x40>
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 c005ba4:	4611      	mov	r1, r2
 c005ba6:	4638      	mov	r0, r7
 c005ba8:	f7ff fe48 	bl	c00583c <mbedtls_mpi_cmp_abs>
 c005bac:	2800      	cmp	r0, #0
 c005bae:	db06      	blt.n	c005bbe <mbedtls_mpi_sub_mpi+0x2c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 c005bb0:	4632      	mov	r2, r6
 c005bb2:	4639      	mov	r1, r7
 c005bb4:	4620      	mov	r0, r4
 c005bb6:	f7ff ff8d 	bl	c005ad4 <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c005bba:	b140      	cbz	r0, c005bce <mbedtls_mpi_sub_mpi+0x3c>
}
 c005bbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 c005bbe:	463a      	mov	r2, r7
 c005bc0:	4631      	mov	r1, r6
 c005bc2:	4620      	mov	r0, r4
 c005bc4:	f7ff ff86 	bl	c005ad4 <mbedtls_mpi_sub_abs>
 c005bc8:	2800      	cmp	r0, #0
 c005bca:	d1f7      	bne.n	c005bbc <mbedtls_mpi_sub_mpi+0x2a>
            X->s = -s;
 c005bcc:	426d      	negs	r5, r5
        X->s = s;
 c005bce:	6025      	str	r5, [r4, #0]
    return( ret );
 c005bd0:	e7f4      	b.n	c005bbc <mbedtls_mpi_sub_mpi+0x2a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c005bd2:	f7ff ff26 	bl	c005a22 <mbedtls_mpi_add_abs>
 c005bd6:	e7f0      	b.n	c005bba <mbedtls_mpi_sub_mpi+0x28>

0c005bd8 <mbedtls_mpi_sub_int>:
{
 c005bd8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    p[0] = ( b < 0 ) ? -b : b;
 c005bda:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 c005bde:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
    _B.s = ( b < 0 ) ? -1 : 1;
 c005be2:	2a00      	cmp	r2, #0
    p[0] = ( b < 0 ) ? -b : b;
 c005be4:	9300      	str	r3, [sp, #0]
    _B.s = ( b < 0 ) ? -1 : 1;
 c005be6:	bfb4      	ite	lt
 c005be8:	f04f 33ff 	movlt.w	r3, #4294967295
 c005bec:	2301      	movge	r3, #1
 c005bee:	9301      	str	r3, [sp, #4]
    _B.n = 1;
 c005bf0:	2301      	movs	r3, #1
    return( mbedtls_mpi_sub_mpi( X, A, &_B ) );
 c005bf2:	aa01      	add	r2, sp, #4
    _B.n = 1;
 c005bf4:	9302      	str	r3, [sp, #8]
    _B.p = p;
 c005bf6:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_sub_mpi( X, A, &_B ) );
 c005bfa:	f7ff ffca 	bl	c005b92 <mbedtls_mpi_sub_mpi>
}
 c005bfe:	b005      	add	sp, #20
 c005c00:	f85d fb04 	ldr.w	pc, [sp], #4

0c005c04 <mbedtls_mpi_mul_mpi>:
{
 c005c04:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    X->n = 0;
 c005c08:	2300      	movs	r3, #0
{
 c005c0a:	4615      	mov	r5, r2
    X->n = 0;
 c005c0c:	2201      	movs	r2, #1
{
 c005c0e:	b087      	sub	sp, #28
    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 c005c10:	4288      	cmp	r0, r1
{
 c005c12:	4680      	mov	r8, r0
 c005c14:	460e      	mov	r6, r1
    X->n = 0;
 c005c16:	e9cd 2300 	strd	r2, r3, [sp]
    X->s = 1;
 c005c1a:	e9cd 3202 	strd	r3, r2, [sp, #8]
    X->p = NULL;
 c005c1e:	e9cd 3304 	strd	r3, r3, [sp, #16]
    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 c005c22:	d105      	bne.n	c005c30 <mbedtls_mpi_mul_mpi+0x2c>
 c005c24:	4668      	mov	r0, sp
 c005c26:	f7ff fc7c 	bl	c005522 <mbedtls_mpi_copy>
 c005c2a:	4604      	mov	r4, r0
 c005c2c:	b9e8      	cbnz	r0, c005c6a <mbedtls_mpi_mul_mpi+0x66>
 c005c2e:	466e      	mov	r6, sp
    if( X == B ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) ); B = &TB; }
 c005c30:	45a8      	cmp	r8, r5
 c005c32:	d106      	bne.n	c005c42 <mbedtls_mpi_mul_mpi+0x3e>
 c005c34:	4641      	mov	r1, r8
 c005c36:	a803      	add	r0, sp, #12
 c005c38:	f7ff fc73 	bl	c005522 <mbedtls_mpi_copy>
 c005c3c:	4604      	mov	r4, r0
 c005c3e:	b9a0      	cbnz	r0, c005c6a <mbedtls_mpi_mul_mpi+0x66>
 c005c40:	ad03      	add	r5, sp, #12
    for( i = A->n; i > 0; i-- )
 c005c42:	f8d6 9004 	ldr.w	r9, [r6, #4]
 c005c46:	f1b9 0f00 	cmp.w	r9, #0
 c005c4a:	d118      	bne.n	c005c7e <mbedtls_mpi_mul_mpi+0x7a>
    for( j = B->n; j > 0; j-- )
 c005c4c:	686f      	ldr	r7, [r5, #4]
 c005c4e:	bb07      	cbnz	r7, c005c92 <mbedtls_mpi_mul_mpi+0x8e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + j ) );
 c005c50:	4640      	mov	r0, r8
 c005c52:	eb09 0107 	add.w	r1, r9, r7
 c005c56:	f7ff fc3e 	bl	c0054d6 <mbedtls_mpi_grow>
 c005c5a:	4604      	mov	r4, r0
 c005c5c:	b928      	cbnz	r0, c005c6a <mbedtls_mpi_mul_mpi+0x66>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 c005c5e:	4601      	mov	r1, r0
 c005c60:	4640      	mov	r0, r8
 c005c62:	f7ff fc8a 	bl	c00557a <mbedtls_mpi_lset>
 c005c66:	4604      	mov	r4, r0
 c005c68:	b338      	cbz	r0, c005cba <mbedtls_mpi_mul_mpi+0xb6>
    mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TA );
 c005c6a:	a803      	add	r0, sp, #12
 c005c6c:	f7ff fc21 	bl	c0054b2 <mbedtls_mpi_free>
 c005c70:	4668      	mov	r0, sp
 c005c72:	f7ff fc1e 	bl	c0054b2 <mbedtls_mpi_free>
}
 c005c76:	4620      	mov	r0, r4
 c005c78:	b007      	add	sp, #28
 c005c7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if( A->p[i - 1] != 0 )
 c005c7e:	68b3      	ldr	r3, [r6, #8]
 c005c80:	eb03 0389 	add.w	r3, r3, r9, lsl #2
 c005c84:	f853 3c04 	ldr.w	r3, [r3, #-4]
 c005c88:	2b00      	cmp	r3, #0
 c005c8a:	d1df      	bne.n	c005c4c <mbedtls_mpi_mul_mpi+0x48>
    for( i = A->n; i > 0; i-- )
 c005c8c:	f109 39ff 	add.w	r9, r9, #4294967295
 c005c90:	e7d9      	b.n	c005c46 <mbedtls_mpi_mul_mpi+0x42>
        if( B->p[j - 1] != 0 )
 c005c92:	68ab      	ldr	r3, [r5, #8]
 c005c94:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 c005c98:	f853 3c04 	ldr.w	r3, [r3, #-4]
 c005c9c:	2b00      	cmp	r3, #0
 c005c9e:	d1d7      	bne.n	c005c50 <mbedtls_mpi_mul_mpi+0x4c>
    for( j = B->n; j > 0; j-- )
 c005ca0:	3f01      	subs	r7, #1
 c005ca2:	e7d4      	b.n	c005c4e <mbedtls_mpi_mul_mpi+0x4a>
        mpi_mul_hlp( i, A->p, X->p + j - 1, B->p[j - 1] );
 c005ca4:	68ab      	ldr	r3, [r5, #8]
 c005ca6:	f8d8 2008 	ldr.w	r2, [r8, #8]
 c005caa:	4648      	mov	r0, r9
 c005cac:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
 c005cb0:	68b1      	ldr	r1, [r6, #8]
 c005cb2:	eb02 0287 	add.w	r2, r2, r7, lsl #2
 c005cb6:	f7ff fb13 	bl	c0052e0 <mpi_mul_hlp>
    for( ; j > 0; j-- )
 c005cba:	3f01      	subs	r7, #1
 c005cbc:	d2f2      	bcs.n	c005ca4 <mbedtls_mpi_mul_mpi+0xa0>
    X->s = A->s * B->s;
 c005cbe:	6832      	ldr	r2, [r6, #0]
 c005cc0:	682b      	ldr	r3, [r5, #0]
 c005cc2:	4353      	muls	r3, r2
 c005cc4:	f8c8 3000 	str.w	r3, [r8]
 c005cc8:	e7cf      	b.n	c005c6a <mbedtls_mpi_mul_mpi+0x66>

0c005cca <mbedtls_mpi_mul_int>:
{
 c005cca:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    _B.s = 1;
 c005ccc:	2301      	movs	r3, #1
    p[0] = b;
 c005cce:	9200      	str	r2, [sp, #0]
    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
 c005cd0:	aa01      	add	r2, sp, #4
    _B.n = 1;
 c005cd2:	e9cd 3301 	strd	r3, r3, [sp, #4]
    _B.p = p;
 c005cd6:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
 c005cda:	f7ff ff93 	bl	c005c04 <mbedtls_mpi_mul_mpi>
}
 c005cde:	b005      	add	sp, #20
 c005ce0:	f85d fb04 	ldr.w	pc, [sp], #4

0c005ce4 <mbedtls_mpi_div_mpi>:
{
 c005ce4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c005ce8:	ed2d 8b02 	vpush	{d8}
 c005cec:	4606      	mov	r6, r0
 c005cee:	4688      	mov	r8, r1
 c005cf0:	b095      	sub	sp, #84	; 0x54
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 c005cf2:	2100      	movs	r1, #0
 c005cf4:	4618      	mov	r0, r3
{
 c005cf6:	4691      	mov	r9, r2
 c005cf8:	ee08 3a90 	vmov	s17, r3
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 c005cfc:	f7ff fe7b 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c005d00:	2800      	cmp	r0, #0
 c005d02:	f000 81a9 	beq.w	c006058 <mbedtls_mpi_div_mpi+0x374>
    X->n = 0;
 c005d06:	2400      	movs	r4, #0
 c005d08:	2501      	movs	r5, #1
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c005d0a:	ee18 1a90 	vmov	r1, s17
 c005d0e:	4648      	mov	r0, r9
    X->n = 0;
 c005d10:	e9cd 5405 	strd	r5, r4, [sp, #20]
    X->s = 1;
 c005d14:	e9cd 4507 	strd	r4, r5, [sp, #28]
    X->p = NULL;
 c005d18:	e9cd 4409 	strd	r4, r4, [sp, #36]	; 0x24
    X->n = 0;
 c005d1c:	e9cd 540b 	strd	r5, r4, [sp, #44]	; 0x2c
    X->s = 1;
 c005d20:	e9cd 450d 	strd	r4, r5, [sp, #52]	; 0x34
    X->p = NULL;
 c005d24:	e9cd 440f 	strd	r4, r4, [sp, #60]	; 0x3c
    X->n = 0;
 c005d28:	e9cd 5411 	strd	r5, r4, [sp, #68]	; 0x44
    X->p = NULL;
 c005d2c:	9413      	str	r4, [sp, #76]	; 0x4c
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c005d2e:	f7ff fd85 	bl	c00583c <mbedtls_mpi_cmp_abs>
 c005d32:	42a0      	cmp	r0, r4
 c005d34:	da29      	bge.n	c005d8a <mbedtls_mpi_div_mpi+0xa6>
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 c005d36:	b94e      	cbnz	r6, c005d4c <mbedtls_mpi_div_mpi+0x68>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 c005d38:	f1b8 0f00 	cmp.w	r8, #0
 c005d3c:	d11d      	bne.n	c005d7a <mbedtls_mpi_div_mpi+0x96>
        return( 0 );
 c005d3e:	2400      	movs	r4, #0
}
 c005d40:	4620      	mov	r0, r4
 c005d42:	b015      	add	sp, #84	; 0x54
 c005d44:	ecbd 8b02 	vpop	{d8}
 c005d48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 c005d4c:	4621      	mov	r1, r4
 c005d4e:	4630      	mov	r0, r6
 c005d50:	f7ff fc13 	bl	c00557a <mbedtls_mpi_lset>
 c005d54:	4604      	mov	r4, r0
 c005d56:	2800      	cmp	r0, #0
 c005d58:	d0ee      	beq.n	c005d38 <mbedtls_mpi_div_mpi+0x54>
    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
 c005d5a:	a805      	add	r0, sp, #20
 c005d5c:	f7ff fba9 	bl	c0054b2 <mbedtls_mpi_free>
 c005d60:	a808      	add	r0, sp, #32
 c005d62:	f7ff fba6 	bl	c0054b2 <mbedtls_mpi_free>
 c005d66:	a80b      	add	r0, sp, #44	; 0x2c
 c005d68:	f7ff fba3 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T1 ); mbedtls_mpi_free( &T2 );
 c005d6c:	a80e      	add	r0, sp, #56	; 0x38
 c005d6e:	f7ff fba0 	bl	c0054b2 <mbedtls_mpi_free>
 c005d72:	a811      	add	r0, sp, #68	; 0x44
 c005d74:	f7ff fb9d 	bl	c0054b2 <mbedtls_mpi_free>
    return( ret );
 c005d78:	e7e2      	b.n	c005d40 <mbedtls_mpi_div_mpi+0x5c>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 c005d7a:	4649      	mov	r1, r9
 c005d7c:	4640      	mov	r0, r8
 c005d7e:	f7ff fbd0 	bl	c005522 <mbedtls_mpi_copy>
 c005d82:	4604      	mov	r4, r0
 c005d84:	2800      	cmp	r0, #0
 c005d86:	d1e8      	bne.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
 c005d88:	e7d9      	b.n	c005d3e <mbedtls_mpi_div_mpi+0x5a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &X, A ) );
 c005d8a:	4649      	mov	r1, r9
 c005d8c:	a805      	add	r0, sp, #20
 c005d8e:	f7ff fbc8 	bl	c005522 <mbedtls_mpi_copy>
 c005d92:	4604      	mov	r4, r0
 c005d94:	2800      	cmp	r0, #0
 c005d96:	d1e0      	bne.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, B ) );
 c005d98:	af08      	add	r7, sp, #32
 c005d9a:	ee18 1a90 	vmov	r1, s17
 c005d9e:	4638      	mov	r0, r7
 c005da0:	f7ff fbbf 	bl	c005522 <mbedtls_mpi_copy>
 c005da4:	4604      	mov	r4, r0
 c005da6:	2800      	cmp	r0, #0
 c005da8:	d1d7      	bne.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 c005daa:	f8d9 1004 	ldr.w	r1, [r9, #4]
 c005dae:	a80b      	add	r0, sp, #44	; 0x2c
 c005db0:	3102      	adds	r1, #2
    X.s = Y.s = 1;
 c005db2:	9508      	str	r5, [sp, #32]
 c005db4:	9505      	str	r5, [sp, #20]
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 c005db6:	f7ff fb8e 	bl	c0054d6 <mbedtls_mpi_grow>
 c005dba:	4604      	mov	r4, r0
 c005dbc:	2800      	cmp	r0, #0
 c005dbe:	d1cc      	bne.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Z,  0 ) );
 c005dc0:	4601      	mov	r1, r0
 c005dc2:	a80b      	add	r0, sp, #44	; 0x2c
 c005dc4:	f7ff fbd9 	bl	c00557a <mbedtls_mpi_lset>
 c005dc8:	4604      	mov	r4, r0
 c005dca:	2800      	cmp	r0, #0
 c005dcc:	d1c5      	bne.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T1, 2 ) );
 c005dce:	2102      	movs	r1, #2
 c005dd0:	a80e      	add	r0, sp, #56	; 0x38
 c005dd2:	f7ff fb80 	bl	c0054d6 <mbedtls_mpi_grow>
 c005dd6:	4604      	mov	r4, r0
 c005dd8:	2800      	cmp	r0, #0
 c005dda:	d1be      	bne.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T2, 3 ) );
 c005ddc:	2103      	movs	r1, #3
 c005dde:	a811      	add	r0, sp, #68	; 0x44
 c005de0:	f7ff fb79 	bl	c0054d6 <mbedtls_mpi_grow>
 c005de4:	4604      	mov	r4, r0
 c005de6:	2800      	cmp	r0, #0
 c005de8:	d1b7      	bne.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
    k = mbedtls_mpi_bitlen( &Y ) % biL;
 c005dea:	4638      	mov	r0, r7
 c005dec:	f7ff fc0d 	bl	c00560a <mbedtls_mpi_bitlen>
 c005df0:	f000 001f 	and.w	r0, r0, #31
    if( k < biL - 1 )
 c005df4:	281f      	cmp	r0, #31
 c005df6:	d075      	beq.n	c005ee4 <mbedtls_mpi_div_mpi+0x200>
        k = biL - 1 - k;
 c005df8:	f1c0 031f 	rsb	r3, r0, #31
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 c005dfc:	4619      	mov	r1, r3
 c005dfe:	a805      	add	r0, sp, #20
        k = biL - 1 - k;
 c005e00:	ee08 3a10 	vmov	s16, r3
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 c005e04:	f7ff fc92 	bl	c00572c <mbedtls_mpi_shift_l>
 c005e08:	4604      	mov	r4, r0
 c005e0a:	2800      	cmp	r0, #0
 c005e0c:	d1a5      	bne.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, k ) );
 c005e0e:	ee18 1a10 	vmov	r1, s16
 c005e12:	4638      	mov	r0, r7
 c005e14:	f7ff fc8a 	bl	c00572c <mbedtls_mpi_shift_l>
 c005e18:	4604      	mov	r4, r0
 c005e1a:	2800      	cmp	r0, #0
 c005e1c:	d19d      	bne.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
    n = X.n - 1;
 c005e1e:	9d06      	ldr	r5, [sp, #24]
    t = Y.n - 1;
 c005e20:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
 c005e24:	4638      	mov	r0, r7
 c005e26:	eba5 030a 	sub.w	r3, r5, sl
 c005e2a:	ea4f 1b43 	mov.w	fp, r3, lsl #5
 c005e2e:	4659      	mov	r1, fp
 c005e30:	9300      	str	r3, [sp, #0]
 c005e32:	f7ff fc7b 	bl	c00572c <mbedtls_mpi_shift_l>
 c005e36:	4604      	mov	r4, r0
 c005e38:	2800      	cmp	r0, #0
 c005e3a:	d18e      	bne.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
        Z.p[n - t]++;
 c005e3c:	9b00      	ldr	r3, [sp, #0]
 c005e3e:	009b      	lsls	r3, r3, #2
    while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
 c005e40:	4639      	mov	r1, r7
 c005e42:	a805      	add	r0, sp, #20
 c005e44:	9300      	str	r3, [sp, #0]
 c005e46:	f7ff fd93 	bl	c005970 <mbedtls_mpi_cmp_mpi>
 c005e4a:	2800      	cmp	r0, #0
 c005e4c:	9b00      	ldr	r3, [sp, #0]
 c005e4e:	da4c      	bge.n	c005eea <mbedtls_mpi_div_mpi+0x206>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, biL * ( n - t ) ) );
 c005e50:	4659      	mov	r1, fp
 c005e52:	4638      	mov	r0, r7
 c005e54:	f7ff fcb8 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c005e58:	4604      	mov	r4, r0
 c005e5a:	2800      	cmp	r0, #0
 c005e5c:	f47f af7d 	bne.w	c005d5a <mbedtls_mpi_div_mpi+0x76>
    t = Y.n - 1;
 c005e60:	f10a 33ff 	add.w	r3, sl, #4294967295
 c005e64:	9300      	str	r3, [sp, #0]
        if( X.p[i] >= Y.p[t] )
 c005e66:	009b      	lsls	r3, r3, #2
    n = X.n - 1;
 c005e68:	1e6f      	subs	r7, r5, #1
        if( X.p[i] >= Y.p[t] )
 c005e6a:	9301      	str	r3, [sp, #4]
 c005e6c:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c005e70:	f10a 4380 	add.w	r3, sl, #1073741824	; 0x40000000
 c005e74:	3b02      	subs	r3, #2
 c005e76:	3d01      	subs	r5, #1
 c005e78:	009b      	lsls	r3, r3, #2
 c005e7a:	eba5 0a0a 	sub.w	sl, r5, sl
 c005e7e:	9303      	str	r3, [sp, #12]
 c005e80:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
    for( i = n; i > t ; i-- )
 c005e84:	9b00      	ldr	r3, [sp, #0]
 c005e86:	429f      	cmp	r7, r3
 c005e88:	d83e      	bhi.n	c005f08 <mbedtls_mpi_div_mpi+0x224>
    if( Q != NULL )
 c005e8a:	b15e      	cbz	r6, c005ea4 <mbedtls_mpi_div_mpi+0x1c0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( Q, &Z ) );
 c005e8c:	4630      	mov	r0, r6
 c005e8e:	a90b      	add	r1, sp, #44	; 0x2c
 c005e90:	f7ff fb47 	bl	c005522 <mbedtls_mpi_copy>
 c005e94:	bb20      	cbnz	r0, c005ee0 <mbedtls_mpi_div_mpi+0x1fc>
        Q->s = A->s * B->s;
 c005e96:	ee18 3a90 	vmov	r3, s17
 c005e9a:	f8d9 2000 	ldr.w	r2, [r9]
 c005e9e:	681b      	ldr	r3, [r3, #0]
 c005ea0:	4353      	muls	r3, r2
 c005ea2:	6033      	str	r3, [r6, #0]
    if( R != NULL )
 c005ea4:	f1b8 0f00 	cmp.w	r8, #0
 c005ea8:	f43f af57 	beq.w	c005d5a <mbedtls_mpi_div_mpi+0x76>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &X, k ) );
 c005eac:	ee18 1a10 	vmov	r1, s16
 c005eb0:	a805      	add	r0, sp, #20
 c005eb2:	f7ff fc89 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c005eb6:	b998      	cbnz	r0, c005ee0 <mbedtls_mpi_div_mpi+0x1fc>
        X.s = A->s;
 c005eb8:	f8d9 3000 	ldr.w	r3, [r9]
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 c005ebc:	a905      	add	r1, sp, #20
 c005ebe:	4640      	mov	r0, r8
        X.s = A->s;
 c005ec0:	9305      	str	r3, [sp, #20]
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 c005ec2:	f7ff fb2e 	bl	c005522 <mbedtls_mpi_copy>
 c005ec6:	4601      	mov	r1, r0
 c005ec8:	2800      	cmp	r0, #0
 c005eca:	f040 80c3 	bne.w	c006054 <mbedtls_mpi_div_mpi+0x370>
        if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )
 c005ece:	4640      	mov	r0, r8
 c005ed0:	f7ff fd91 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c005ed4:	2800      	cmp	r0, #0
 c005ed6:	f47f af40 	bne.w	c005d5a <mbedtls_mpi_div_mpi+0x76>
            R->s = 1;
 c005eda:	2301      	movs	r3, #1
 c005edc:	f8c8 3000 	str.w	r3, [r8]
 c005ee0:	4604      	mov	r4, r0
 c005ee2:	e73a      	b.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
    else k = 0;
 c005ee4:	ee08 4a10 	vmov	s16, r4
 c005ee8:	e799      	b.n	c005e1e <mbedtls_mpi_div_mpi+0x13a>
        Z.p[n - t]++;
 c005eea:	990d      	ldr	r1, [sp, #52]	; 0x34
 c005eec:	9300      	str	r3, [sp, #0]
 c005eee:	58ca      	ldr	r2, [r1, r3]
 c005ef0:	3201      	adds	r2, #1
 c005ef2:	50ca      	str	r2, [r1, r3]
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
 c005ef4:	a905      	add	r1, sp, #20
 c005ef6:	463a      	mov	r2, r7
 c005ef8:	4608      	mov	r0, r1
 c005efa:	f7ff fe4a 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c005efe:	9b00      	ldr	r3, [sp, #0]
 c005f00:	4604      	mov	r4, r0
 c005f02:	2800      	cmp	r0, #0
 c005f04:	d09c      	beq.n	c005e40 <mbedtls_mpi_div_mpi+0x15c>
 c005f06:	e728      	b.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
        if( X.p[i] >= Y.p[t] )
 c005f08:	9801      	ldr	r0, [sp, #4]
 c005f0a:	9b07      	ldr	r3, [sp, #28]
 c005f0c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 c005f0e:	ea4f 0b87 	mov.w	fp, r7, lsl #2
 c005f12:	5812      	ldr	r2, [r2, r0]
 c005f14:	f853 1027 	ldr.w	r1, [r3, r7, lsl #2]
 c005f18:	f1ab 0004 	sub.w	r0, fp, #4
 c005f1c:	9002      	str	r0, [sp, #8]
 c005f1e:	980d      	ldr	r0, [sp, #52]	; 0x34
 c005f20:	4291      	cmp	r1, r2
 c005f22:	eb00 050a 	add.w	r5, r0, sl
 c005f26:	d37e      	bcc.n	c006026 <mbedtls_mpi_div_mpi+0x342>
            Z.p[i - t - 1] = ~0;
 c005f28:	f04f 33ff 	mov.w	r3, #4294967295
 c005f2c:	f840 300a 	str.w	r3, [r0, sl]
        Z.p[i - t - 1]++;
 c005f30:	682b      	ldr	r3, [r5, #0]
 c005f32:	3301      	adds	r3, #1
 c005f34:	602b      	str	r3, [r5, #0]
            T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 c005f36:	f1ab 0508 	sub.w	r5, fp, #8
            Z.p[i - t - 1]--;
 c005f3a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c005f3c:	2100      	movs	r1, #0
            Z.p[i - t - 1]--;
 c005f3e:	f852 300a 	ldr.w	r3, [r2, sl]
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c005f42:	a80e      	add	r0, sp, #56	; 0x38
            Z.p[i - t - 1]--;
 c005f44:	3b01      	subs	r3, #1
 c005f46:	f842 300a 	str.w	r3, [r2, sl]
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c005f4a:	f7ff fb16 	bl	c00557a <mbedtls_mpi_lset>
 c005f4e:	2800      	cmp	r0, #0
 c005f50:	d1c6      	bne.n	c005ee0 <mbedtls_mpi_div_mpi+0x1fc>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c005f52:	9b00      	ldr	r3, [sp, #0]
 c005f54:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 c005f56:	2b00      	cmp	r3, #0
 c005f58:	d07a      	beq.n	c006050 <mbedtls_mpi_div_mpi+0x36c>
 c005f5a:	9b03      	ldr	r3, [sp, #12]
 c005f5c:	58d1      	ldr	r1, [r2, r3]
 c005f5e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 c005f60:	6019      	str	r1, [r3, #0]
            T1.p[1] = Y.p[t];
 c005f62:	9901      	ldr	r1, [sp, #4]
 c005f64:	5852      	ldr	r2, [r2, r1]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 c005f66:	a90e      	add	r1, sp, #56	; 0x38
            T1.p[1] = Y.p[t];
 c005f68:	605a      	str	r2, [r3, #4]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 c005f6a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 c005f6c:	4608      	mov	r0, r1
 c005f6e:	f853 200a 	ldr.w	r2, [r3, sl]
 c005f72:	f7ff feaa 	bl	c005cca <mbedtls_mpi_mul_int>
 c005f76:	4601      	mov	r1, r0
 c005f78:	2800      	cmp	r0, #0
 c005f7a:	d16b      	bne.n	c006054 <mbedtls_mpi_div_mpi+0x370>
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T2, 0 ) );
 c005f7c:	a811      	add	r0, sp, #68	; 0x44
 c005f7e:	f7ff fafc 	bl	c00557a <mbedtls_mpi_lset>
 c005f82:	2800      	cmp	r0, #0
 c005f84:	d1ac      	bne.n	c005ee0 <mbedtls_mpi_div_mpi+0x1fc>
            T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 c005f86:	9a07      	ldr	r2, [sp, #28]
 c005f88:	2f01      	cmp	r7, #1
 c005f8a:	bf18      	it	ne
 c005f8c:	5950      	ldrne	r0, [r2, r5]
 c005f8e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
            T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
 c005f90:	9902      	ldr	r1, [sp, #8]
            T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 c005f92:	6018      	str	r0, [r3, #0]
            T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
 c005f94:	5851      	ldr	r1, [r2, r1]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 c005f96:	a80e      	add	r0, sp, #56	; 0x38
            T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
 c005f98:	6059      	str	r1, [r3, #4]
            T2.p[2] = X.p[i];
 c005f9a:	f852 200b 	ldr.w	r2, [r2, fp]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 c005f9e:	a911      	add	r1, sp, #68	; 0x44
            T2.p[2] = X.p[i];
 c005fa0:	609a      	str	r2, [r3, #8]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 c005fa2:	f7ff fce5 	bl	c005970 <mbedtls_mpi_cmp_mpi>
 c005fa6:	2800      	cmp	r0, #0
 c005fa8:	dcc7      	bgt.n	c005f3a <mbedtls_mpi_div_mpi+0x256>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );
 c005faa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 c005fac:	a908      	add	r1, sp, #32
 c005fae:	f853 200a 	ldr.w	r2, [r3, sl]
 c005fb2:	a80e      	add	r0, sp, #56	; 0x38
 c005fb4:	f7ff fe89 	bl	c005cca <mbedtls_mpi_mul_int>
 c005fb8:	2800      	cmp	r0, #0
 c005fba:	d191      	bne.n	c005ee0 <mbedtls_mpi_div_mpi+0x1fc>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1,  biL * ( i - t - 1 ) ) );
 c005fbc:	ea4f 05ca 	mov.w	r5, sl, lsl #3
 c005fc0:	4629      	mov	r1, r5
 c005fc2:	a80e      	add	r0, sp, #56	; 0x38
 c005fc4:	f7ff fbb2 	bl	c00572c <mbedtls_mpi_shift_l>
 c005fc8:	2800      	cmp	r0, #0
 c005fca:	d189      	bne.n	c005ee0 <mbedtls_mpi_div_mpi+0x1fc>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &T1 ) );
 c005fcc:	a905      	add	r1, sp, #20
 c005fce:	4608      	mov	r0, r1
 c005fd0:	aa0e      	add	r2, sp, #56	; 0x38
 c005fd2:	f7ff fdde 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c005fd6:	4601      	mov	r1, r0
 c005fd8:	2800      	cmp	r0, #0
 c005fda:	d13b      	bne.n	c006054 <mbedtls_mpi_div_mpi+0x370>
        if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
 c005fdc:	a805      	add	r0, sp, #20
 c005fde:	f7ff fd0a 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c005fe2:	2800      	cmp	r0, #0
 c005fe4:	da1b      	bge.n	c00601e <mbedtls_mpi_div_mpi+0x33a>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T1, &Y ) );
 c005fe6:	a908      	add	r1, sp, #32
 c005fe8:	a80e      	add	r0, sp, #56	; 0x38
 c005fea:	f7ff fa9a 	bl	c005522 <mbedtls_mpi_copy>
 c005fee:	2800      	cmp	r0, #0
 c005ff0:	f47f af76 	bne.w	c005ee0 <mbedtls_mpi_div_mpi+0x1fc>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1, biL * ( i - t - 1 ) ) );
 c005ff4:	4629      	mov	r1, r5
 c005ff6:	a80e      	add	r0, sp, #56	; 0x38
 c005ff8:	f7ff fb98 	bl	c00572c <mbedtls_mpi_shift_l>
 c005ffc:	2800      	cmp	r0, #0
 c005ffe:	f47f af6f 	bne.w	c005ee0 <mbedtls_mpi_div_mpi+0x1fc>
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &X, &X, &T1 ) );
 c006002:	a905      	add	r1, sp, #20
 c006004:	4608      	mov	r0, r1
 c006006:	aa0e      	add	r2, sp, #56	; 0x38
 c006008:	f7ff fda1 	bl	c005b4e <mbedtls_mpi_add_mpi>
 c00600c:	2800      	cmp	r0, #0
 c00600e:	f47f af67 	bne.w	c005ee0 <mbedtls_mpi_div_mpi+0x1fc>
            Z.p[i - t - 1]--;
 c006012:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 c006014:	f852 300a 	ldr.w	r3, [r2, sl]
 c006018:	3b01      	subs	r3, #1
 c00601a:	f842 300a 	str.w	r3, [r2, sl]
    for( i = n; i > t ; i-- )
 c00601e:	3f01      	subs	r7, #1
 c006020:	f1aa 0a04 	sub.w	sl, sl, #4
 c006024:	e72e      	b.n	c005e84 <mbedtls_mpi_div_mpi+0x1a0>
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 c006026:	9802      	ldr	r0, [sp, #8]
 c006028:	5818      	ldr	r0, [r3, r0]
    if( 0 == d || u1 >= d )
 c00602a:	b172      	cbz	r2, c00604a <mbedtls_mpi_div_mpi+0x366>
    quotient = dividend / d;
 c00602c:	2300      	movs	r3, #0
 c00602e:	f003 fdcb 	bl	c009bc8 <__aeabi_uldivmod>
 c006032:	460b      	mov	r3, r1
    return (mbedtls_mpi_uint) quotient;
 c006034:	2100      	movs	r1, #0
    quotient = dividend / d;
 c006036:	4602      	mov	r2, r0
    return (mbedtls_mpi_uint) quotient;
 c006038:	f04f 30ff 	mov.w	r0, #4294967295
 c00603c:	4299      	cmp	r1, r3
 c00603e:	bf08      	it	eq
 c006040:	4290      	cmpeq	r0, r2
 c006042:	d200      	bcs.n	c006046 <mbedtls_mpi_div_mpi+0x362>
 c006044:	4602      	mov	r2, r0
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 c006046:	602a      	str	r2, [r5, #0]
 c006048:	e772      	b.n	c005f30 <mbedtls_mpi_div_mpi+0x24c>
        return ( ~0 );
 c00604a:	f04f 32ff 	mov.w	r2, #4294967295
 c00604e:	e7fa      	b.n	c006046 <mbedtls_mpi_div_mpi+0x362>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c006050:	9900      	ldr	r1, [sp, #0]
 c006052:	e784      	b.n	c005f5e <mbedtls_mpi_div_mpi+0x27a>
 c006054:	460c      	mov	r4, r1
 c006056:	e680      	b.n	c005d5a <mbedtls_mpi_div_mpi+0x76>
        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
 c006058:	f06f 040b 	mvn.w	r4, #11
 c00605c:	e670      	b.n	c005d40 <mbedtls_mpi_div_mpi+0x5c>

0c00605e <mbedtls_mpi_mod_mpi>:
{
 c00605e:	b570      	push	{r4, r5, r6, lr}
 c006060:	4604      	mov	r4, r0
 c006062:	460d      	mov	r5, r1
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 c006064:	4610      	mov	r0, r2
 c006066:	2100      	movs	r1, #0
{
 c006068:	4616      	mov	r6, r2
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 c00606a:	f7ff fcc4 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c00606e:	2800      	cmp	r0, #0
 c006070:	db24      	blt.n	c0060bc <mbedtls_mpi_mod_mpi+0x5e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( NULL, R, A, B ) );
 c006072:	462a      	mov	r2, r5
 c006074:	4633      	mov	r3, r6
 c006076:	4621      	mov	r1, r4
 c006078:	2000      	movs	r0, #0
 c00607a:	f7ff fe33 	bl	c005ce4 <mbedtls_mpi_div_mpi>
 c00607e:	4605      	mov	r5, r0
 c006080:	b138      	cbz	r0, c006092 <mbedtls_mpi_mod_mpi+0x34>
}
 c006082:	4628      	mov	r0, r5
 c006084:	bd70      	pop	{r4, r5, r6, pc}
      MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( R, R, B ) );
 c006086:	4632      	mov	r2, r6
 c006088:	4621      	mov	r1, r4
 c00608a:	4620      	mov	r0, r4
 c00608c:	f7ff fd5f 	bl	c005b4e <mbedtls_mpi_add_mpi>
 c006090:	b990      	cbnz	r0, c0060b8 <mbedtls_mpi_mod_mpi+0x5a>
    while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
 c006092:	2100      	movs	r1, #0
 c006094:	4620      	mov	r0, r4
 c006096:	f7ff fcae 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c00609a:	2800      	cmp	r0, #0
 c00609c:	dbf3      	blt.n	c006086 <mbedtls_mpi_mod_mpi+0x28>
    while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )
 c00609e:	4631      	mov	r1, r6
 c0060a0:	4620      	mov	r0, r4
 c0060a2:	f7ff fc65 	bl	c005970 <mbedtls_mpi_cmp_mpi>
 c0060a6:	2800      	cmp	r0, #0
 c0060a8:	dbeb      	blt.n	c006082 <mbedtls_mpi_mod_mpi+0x24>
      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( R, R, B ) );
 c0060aa:	4632      	mov	r2, r6
 c0060ac:	4621      	mov	r1, r4
 c0060ae:	4620      	mov	r0, r4
 c0060b0:	f7ff fd6f 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c0060b4:	2800      	cmp	r0, #0
 c0060b6:	d0f2      	beq.n	c00609e <mbedtls_mpi_mod_mpi+0x40>
 c0060b8:	4605      	mov	r5, r0
 c0060ba:	e7e2      	b.n	c006082 <mbedtls_mpi_mod_mpi+0x24>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 c0060bc:	f06f 0509 	mvn.w	r5, #9
 c0060c0:	e7df      	b.n	c006082 <mbedtls_mpi_mod_mpi+0x24>

0c0060c2 <mbedtls_mpi_exp_mod>:
 * Sliding-window exponentiation: X = A^E mod N  (HAC 14.85)
 */
int mbedtls_mpi_exp_mod( mbedtls_mpi *X, const mbedtls_mpi *A,
                         const mbedtls_mpi *E, const mbedtls_mpi *N,
                         mbedtls_mpi *_RR )
{
 c0060c2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0060c6:	4605      	mov	r5, r0
 c0060c8:	f2ad 6d54 	subw	sp, sp, #1620	; 0x654
 c0060cc:	4688      	mov	r8, r1
    MPI_VALIDATE_RET( X != NULL );
    MPI_VALIDATE_RET( A != NULL );
    MPI_VALIDATE_RET( E != NULL );
    MPI_VALIDATE_RET( N != NULL );

    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 c0060ce:	4618      	mov	r0, r3
 c0060d0:	2100      	movs	r1, #0
{
 c0060d2:	461c      	mov	r4, r3
 c0060d4:	9202      	str	r2, [sp, #8]
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 c0060d6:	f7ff fc8e 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c0060da:	2800      	cmp	r0, #0
 c0060dc:	f340 821c 	ble.w	c006518 <mbedtls_mpi_exp_mod+0x456>
 c0060e0:	68a3      	ldr	r3, [r4, #8]
 c0060e2:	681e      	ldr	r6, [r3, #0]
 c0060e4:	f016 0301 	ands.w	r3, r6, #1
 c0060e8:	9304      	str	r3, [sp, #16]
 c0060ea:	f000 8215 	beq.w	c006518 <mbedtls_mpi_exp_mod+0x456>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );

    if( mbedtls_mpi_cmp_int( E, 0 ) < 0 )
 c0060ee:	2100      	movs	r1, #0
 c0060f0:	9802      	ldr	r0, [sp, #8]
 c0060f2:	f7ff fc80 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c0060f6:	2800      	cmp	r0, #0
 c0060f8:	f2c0 820e 	blt.w	c006518 <mbedtls_mpi_exp_mod+0x456>
    x += ( ( m0 + 2 ) & 4 ) << 1;
 c0060fc:	2103      	movs	r1, #3
 c0060fe:	1cb7      	adds	r7, r6, #2
 c006100:	007f      	lsls	r7, r7, #1
 c006102:	f007 0708 	and.w	r7, r7, #8
 c006106:	4437      	add	r7, r6
        x *= ( 2 - ( m0 * x ) );
 c006108:	fb07 f306 	mul.w	r3, r7, r6
    for( i = biL; i >= 8; i /= 2 )
 c00610c:	3901      	subs	r1, #1
        x *= ( 2 - ( m0 * x ) );
 c00610e:	f1c3 0302 	rsb	r3, r3, #2
 c006112:	fb03 f707 	mul.w	r7, r3, r7
    for( i = biL; i >= 8; i /= 2 )
 c006116:	d1f7      	bne.n	c006108 <mbedtls_mpi_exp_mod+0x46>
    X->s = 1;
 c006118:	2301      	movs	r3, #1
     * Init temps and window size
     */
    mpi_montg_init( &mm, N );
    mbedtls_mpi_init( &RR ); mbedtls_mpi_init( &T );
    mbedtls_mpi_init( &Apos );
    memset( W, 0, sizeof( W ) );
 c00611a:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 c00611e:	a814      	add	r0, sp, #80	; 0x50
    X->n = 0;
 c006120:	e9cd 3108 	strd	r3, r1, [sp, #32]
    X->s = 1;
 c006124:	e9cd 130a 	strd	r1, r3, [sp, #40]	; 0x28
    X->p = NULL;
 c006128:	e9cd 110c 	strd	r1, r1, [sp, #48]	; 0x30
    X->n = 0;
 c00612c:	e9cd 310e 	strd	r3, r1, [sp, #56]	; 0x38
    X->p = NULL;
 c006130:	9110      	str	r1, [sp, #64]	; 0x40
    memset( W, 0, sizeof( W ) );
 c006132:	f002 fd38 	bl	c008ba6 <memset>

    i = mbedtls_mpi_bitlen( E );
 c006136:	9802      	ldr	r0, [sp, #8]
 c006138:	f7ff fa67 	bl	c00560a <mbedtls_mpi_bitlen>

    wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
 c00613c:	f5b0 7f28 	cmp.w	r0, #672	; 0x2a0
 c006140:	f080 80e2 	bcs.w	c006308 <mbedtls_mpi_exp_mod+0x246>
 c006144:	28ef      	cmp	r0, #239	; 0xef
 c006146:	f200 80e1 	bhi.w	c00630c <mbedtls_mpi_exp_mod+0x24a>
 c00614a:	284f      	cmp	r0, #79	; 0x4f
 c00614c:	f200 80e0 	bhi.w	c006310 <mbedtls_mpi_exp_mod+0x24e>
 c006150:	9b04      	ldr	r3, [sp, #16]
 c006152:	2817      	cmp	r0, #23
 c006154:	bf94      	ite	ls
 c006156:	461e      	movls	r6, r3
 c006158:	2603      	movhi	r6, #3
#if( MBEDTLS_MPI_WINDOW_SIZE < 6 )
    if( wsize > MBEDTLS_MPI_WINDOW_SIZE )
        wsize = MBEDTLS_MPI_WINDOW_SIZE;
#endif

    j = N->n + 1;
 c00615a:	6861      	ldr	r1, [r4, #4]
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 c00615c:	4628      	mov	r0, r5
    j = N->n + 1;
 c00615e:	f101 0901 	add.w	r9, r1, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 c006162:	4649      	mov	r1, r9
 c006164:	f7ff f9b7 	bl	c0054d6 <mbedtls_mpi_grow>
 c006168:	4602      	mov	r2, r0
 c00616a:	2800      	cmp	r0, #0
 c00616c:	f040 81a9 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[1],  j ) );
 c006170:	4649      	mov	r1, r9
 c006172:	a817      	add	r0, sp, #92	; 0x5c
 c006174:	f7ff f9af 	bl	c0054d6 <mbedtls_mpi_grow>
 c006178:	4602      	mov	r2, r0
 c00617a:	2800      	cmp	r0, #0
 c00617c:	f040 81a1 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T, j * 2 ) );
 c006180:	ea4f 0149 	mov.w	r1, r9, lsl #1
 c006184:	a80b      	add	r0, sp, #44	; 0x2c
 c006186:	f7ff f9a6 	bl	c0054d6 <mbedtls_mpi_grow>
 c00618a:	4602      	mov	r2, r0
 c00618c:	2800      	cmp	r0, #0
 c00618e:	f040 8198 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>

    /*
     * Compensate for negative A (and correct at the end)
     */
    neg = ( A->s == -1 );
 c006192:	f8d8 3000 	ldr.w	r3, [r8]
 c006196:	9303      	str	r3, [sp, #12]
    if( neg )
 c006198:	3301      	adds	r3, #1
 c00619a:	d10b      	bne.n	c0061b4 <mbedtls_mpi_exp_mod+0xf2>
    {
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Apos, A ) );
 c00619c:	4641      	mov	r1, r8
 c00619e:	a80e      	add	r0, sp, #56	; 0x38
 c0061a0:	f7ff f9bf 	bl	c005522 <mbedtls_mpi_copy>
 c0061a4:	4602      	mov	r2, r0
 c0061a6:	2800      	cmp	r0, #0
 c0061a8:	f040 818b 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
        Apos.s = 1;
 c0061ac:	2301      	movs	r3, #1
        A = &Apos;
 c0061ae:	f10d 0838 	add.w	r8, sp, #56	; 0x38
        Apos.s = 1;
 c0061b2:	930e      	str	r3, [sp, #56]	; 0x38
    }

    /*
     * If 1st call, pre-compute R^2 mod N
     */
    if( _RR == NULL || _RR->p == NULL )
 c0061b4:	f8dd 3678 	ldr.w	r3, [sp, #1656]	; 0x678
 c0061b8:	b11b      	cbz	r3, c0061c2 <mbedtls_mpi_exp_mod+0x100>
 c0061ba:	689b      	ldr	r3, [r3, #8]
 c0061bc:	2b00      	cmp	r3, #0
 c0061be:	f040 80a9 	bne.w	c006314 <mbedtls_mpi_exp_mod+0x252>
    {
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &RR, 1 ) );
 c0061c2:	2101      	movs	r1, #1
 c0061c4:	a808      	add	r0, sp, #32
 c0061c6:	f7ff f9d8 	bl	c00557a <mbedtls_mpi_lset>
 c0061ca:	4602      	mov	r2, r0
 c0061cc:	2800      	cmp	r0, #0
 c0061ce:	f040 8178 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &RR, N->n * 2 * biL ) );
 c0061d2:	6861      	ldr	r1, [r4, #4]
 c0061d4:	a808      	add	r0, sp, #32
 c0061d6:	0189      	lsls	r1, r1, #6
 c0061d8:	f7ff faa8 	bl	c00572c <mbedtls_mpi_shift_l>
 c0061dc:	4602      	mov	r2, r0
 c0061de:	2800      	cmp	r0, #0
 c0061e0:	f040 816f 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &RR, &RR, N ) );
 c0061e4:	a908      	add	r1, sp, #32
 c0061e6:	4622      	mov	r2, r4
 c0061e8:	4608      	mov	r0, r1
 c0061ea:	f7ff ff38 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c0061ee:	4602      	mov	r2, r0
 c0061f0:	2800      	cmp	r0, #0
 c0061f2:	f040 8166 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>

        if( _RR != NULL )
 c0061f6:	f8dd 3678 	ldr.w	r3, [sp, #1656]	; 0x678
 c0061fa:	b13b      	cbz	r3, c00620c <mbedtls_mpi_exp_mod+0x14a>
            memcpy( _RR, &RR, sizeof( mbedtls_mpi ) );
 c0061fc:	f8dd 2678 	ldr.w	r2, [sp, #1656]	; 0x678
 c006200:	ab08      	add	r3, sp, #32
 c006202:	cb03      	ldmia	r3!, {r0, r1}
 c006204:	6010      	str	r0, [r2, #0]
 c006206:	6818      	ldr	r0, [r3, #0]
 c006208:	6051      	str	r1, [r2, #4]
 c00620a:	6090      	str	r0, [r2, #8]
        memcpy( &RR, _RR, sizeof( mbedtls_mpi ) );

    /*
     * W[1] = A * R^2 * R^-1 mod N = A * R mod N
     */
    if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 )
 c00620c:	4621      	mov	r1, r4
 c00620e:	4640      	mov	r0, r8
 c006210:	f7ff fbae 	bl	c005970 <mbedtls_mpi_cmp_mpi>
 c006214:	2800      	cmp	r0, #0
 c006216:	f2c0 8086 	blt.w	c006326 <mbedtls_mpi_exp_mod+0x264>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &W[1], A, N ) );
 c00621a:	4622      	mov	r2, r4
 c00621c:	4641      	mov	r1, r8
 c00621e:	a817      	add	r0, sp, #92	; 0x5c
 c006220:	f7ff ff1d 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c006224:	4602      	mov	r2, r0
 c006226:	2800      	cmp	r0, #0
 c006228:	f040 814b 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
    else
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[1], A ) );

    MBEDTLS_MPI_CHK( mpi_montmul( &W[1], &RR, N, mm, &T ) );
 c00622c:	f10d 092c 	add.w	r9, sp, #44	; 0x2c
 c006230:	4622      	mov	r2, r4
    *mm = ~x + 1;
 c006232:	427b      	negs	r3, r7
    MBEDTLS_MPI_CHK( mpi_montmul( &W[1], &RR, N, mm, &T ) );
 c006234:	f8cd 9000 	str.w	r9, [sp]
 c006238:	a908      	add	r1, sp, #32
 c00623a:	a817      	add	r0, sp, #92	; 0x5c
 c00623c:	9305      	str	r3, [sp, #20]
 c00623e:	f7ff fb30 	bl	c0058a2 <mpi_montmul>
 c006242:	4602      	mov	r2, r0
 c006244:	2800      	cmp	r0, #0
 c006246:	f040 813c 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>

    /*
     * X = R^2 * R^-1 mod N = R mod N
     */
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &RR ) );
 c00624a:	4628      	mov	r0, r5
 c00624c:	a908      	add	r1, sp, #32
 c00624e:	f7ff f968 	bl	c005522 <mbedtls_mpi_copy>
 c006252:	4602      	mov	r2, r0
 c006254:	2800      	cmp	r0, #0
 c006256:	f040 8134 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
    mbedtls_mpi_uint z = 1;
 c00625a:	2701      	movs	r7, #1
 c00625c:	aa07      	add	r2, sp, #28
    U.p = &z;
 c00625e:	9213      	str	r2, [sp, #76]	; 0x4c
    return( mpi_montmul( A, &U, N, mm, T ) );
 c006260:	4628      	mov	r0, r5
 c006262:	4622      	mov	r2, r4
 c006264:	9b05      	ldr	r3, [sp, #20]
 c006266:	f8cd 9000 	str.w	r9, [sp]
 c00626a:	a911      	add	r1, sp, #68	; 0x44
    U.n = U.s = (int) z;
 c00626c:	e9cd 7711 	strd	r7, r7, [sp, #68]	; 0x44
    mbedtls_mpi_uint z = 1;
 c006270:	9707      	str	r7, [sp, #28]
    return( mpi_montmul( A, &U, N, mm, T ) );
 c006272:	f7ff fb16 	bl	c0058a2 <mpi_montmul>
    MBEDTLS_MPI_CHK( mpi_montred( X, N, mm, &T ) );
 c006276:	4602      	mov	r2, r0
 c006278:	2800      	cmp	r0, #0
 c00627a:	f040 8122 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>

    if( wsize > 1 )
 c00627e:	42be      	cmp	r6, r7
 c006280:	9b05      	ldr	r3, [sp, #20]
 c006282:	d155      	bne.n	c006330 <mbedtls_mpi_exp_mod+0x26e>

    nblimbs = E->n;
    bufsize = 0;
    nbits   = 0;
    wbits   = 0;
    state   = 0;
 c006284:	f04f 0800 	mov.w	r8, #0
    nbits   = 0;
 c006288:	4647      	mov	r7, r8
    bufsize = 0;
 c00628a:	46c1      	mov	r9, r8
    wbits   = 0;
 c00628c:	46c2      	mov	sl, r8
    nblimbs = E->n;
 c00628e:	9a02      	ldr	r2, [sp, #8]
 c006290:	f8d2 b004 	ldr.w	fp, [r2, #4]

    while( 1 )
    {
        if( bufsize == 0 )
 c006294:	f1b9 0f00 	cmp.w	r9, #0
 c006298:	f040 80ac 	bne.w	c0063f4 <mbedtls_mpi_exp_mod+0x332>
        {
            if( nblimbs == 0 )
 c00629c:	f1bb 0f00 	cmp.w	fp, #0
 c0062a0:	f040 80a4 	bne.w	c0063ec <mbedtls_mpi_exp_mod+0x32a>
    {
        MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );

        wbits <<= 1;

        if( ( wbits & ( one << wsize ) ) != 0 )
 c0062a4:	f04f 0901 	mov.w	r9, #1
 c0062a8:	f10d 082c 	add.w	r8, sp, #44	; 0x2c
 c0062ac:	fa09 f906 	lsl.w	r9, r9, r6
    for( i = 0; i < nbits; i++ )
 c0062b0:	45bb      	cmp	fp, r7
 c0062b2:	f040 80e7 	bne.w	c006484 <mbedtls_mpi_exp_mod+0x3c2>
    mbedtls_mpi_uint z = 1;
 c0062b6:	2201      	movs	r2, #1
 c0062b8:	a907      	add	r1, sp, #28
    U.n = U.s = (int) z;
 c0062ba:	e9cd 2211 	strd	r2, r2, [sp, #68]	; 0x44
    mbedtls_mpi_uint z = 1;
 c0062be:	9207      	str	r2, [sp, #28]
    U.p = &z;
 c0062c0:	9113      	str	r1, [sp, #76]	; 0x4c
    return( mpi_montmul( A, &U, N, mm, T ) );
 c0062c2:	4622      	mov	r2, r4
 c0062c4:	4628      	mov	r0, r5
 c0062c6:	f8cd 8000 	str.w	r8, [sp]
 c0062ca:	a911      	add	r1, sp, #68	; 0x44
 c0062cc:	f7ff fae9 	bl	c0058a2 <mpi_montmul>
    }

    /*
     * X = A^E * R * R^-1 mod N = A^E mod N
     */
    MBEDTLS_MPI_CHK( mpi_montred( X, N, mm, &T ) );
 c0062d0:	4602      	mov	r2, r0
 c0062d2:	2800      	cmp	r0, #0
 c0062d4:	f040 80f5 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>

    if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 )
 c0062d8:	9b03      	ldr	r3, [sp, #12]
 c0062da:	3301      	adds	r3, #1
 c0062dc:	f040 80f1 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
 c0062e0:	9b02      	ldr	r3, [sp, #8]
 c0062e2:	685b      	ldr	r3, [r3, #4]
 c0062e4:	2b00      	cmp	r3, #0
 c0062e6:	f000 80ec 	beq.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
 c0062ea:	9b02      	ldr	r3, [sp, #8]
 c0062ec:	689b      	ldr	r3, [r3, #8]
 c0062ee:	681b      	ldr	r3, [r3, #0]
 c0062f0:	07db      	lsls	r3, r3, #31
 c0062f2:	f140 80e6 	bpl.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
    {
        X->s = -1;
 c0062f6:	9b03      	ldr	r3, [sp, #12]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
 c0062f8:	462a      	mov	r2, r5
 c0062fa:	4621      	mov	r1, r4
 c0062fc:	4628      	mov	r0, r5
        X->s = -1;
 c0062fe:	602b      	str	r3, [r5, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
 c006300:	f7ff fc25 	bl	c005b4e <mbedtls_mpi_add_mpi>
 c006304:	4602      	mov	r2, r0
    }

cleanup:
 c006306:	e0dc      	b.n	c0064c2 <mbedtls_mpi_exp_mod+0x400>
    wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
 c006308:	2606      	movs	r6, #6
 c00630a:	e726      	b.n	c00615a <mbedtls_mpi_exp_mod+0x98>
 c00630c:	2605      	movs	r6, #5
 c00630e:	e724      	b.n	c00615a <mbedtls_mpi_exp_mod+0x98>
 c006310:	2604      	movs	r6, #4
 c006312:	e722      	b.n	c00615a <mbedtls_mpi_exp_mod+0x98>
        memcpy( &RR, _RR, sizeof( mbedtls_mpi ) );
 c006314:	f8dd 2678 	ldr.w	r2, [sp, #1656]	; 0x678
 c006318:	ab08      	add	r3, sp, #32
 c00631a:	6810      	ldr	r0, [r2, #0]
 c00631c:	6851      	ldr	r1, [r2, #4]
 c00631e:	c303      	stmia	r3!, {r0, r1}
 c006320:	6890      	ldr	r0, [r2, #8]
 c006322:	6018      	str	r0, [r3, #0]
 c006324:	e772      	b.n	c00620c <mbedtls_mpi_exp_mod+0x14a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[1], A ) );
 c006326:	4641      	mov	r1, r8
 c006328:	a817      	add	r0, sp, #92	; 0x5c
 c00632a:	f7ff f8fa 	bl	c005522 <mbedtls_mpi_copy>
 c00632e:	e779      	b.n	c006224 <mbedtls_mpi_exp_mod+0x162>
 c006330:	f106 3bff 	add.w	fp, r6, #4294967295
 c006334:	fa07 f80b 	lsl.w	r8, r7, fp
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[j], N->n + 1 ) );
 c006338:	270c      	movs	r7, #12
 c00633a:	6861      	ldr	r1, [r4, #4]
 c00633c:	9305      	str	r3, [sp, #20]
 c00633e:	fa07 f70b 	lsl.w	r7, r7, fp
 c006342:	ab14      	add	r3, sp, #80	; 0x50
 c006344:	441f      	add	r7, r3
 c006346:	4638      	mov	r0, r7
 c006348:	3101      	adds	r1, #1
 c00634a:	f7ff f8c4 	bl	c0054d6 <mbedtls_mpi_grow>
 c00634e:	4602      	mov	r2, r0
 c006350:	2800      	cmp	r0, #0
 c006352:	f040 80b6 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[j], &W[1]    ) );
 c006356:	4638      	mov	r0, r7
 c006358:	a917      	add	r1, sp, #92	; 0x5c
 c00635a:	f7ff f8e2 	bl	c005522 <mbedtls_mpi_copy>
 c00635e:	4602      	mov	r2, r0
 c006360:	2800      	cmp	r0, #0
 c006362:	f040 80ae 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
        for( i = 0; i < wsize - 1; i++ )
 c006366:	4682      	mov	sl, r0
            MBEDTLS_MPI_CHK( mpi_montmul( &W[j], &W[j], N, mm, &T ) );
 c006368:	9b05      	ldr	r3, [sp, #20]
 c00636a:	4622      	mov	r2, r4
 c00636c:	4639      	mov	r1, r7
 c00636e:	4638      	mov	r0, r7
 c006370:	f8cd 9000 	str.w	r9, [sp]
 c006374:	9305      	str	r3, [sp, #20]
 c006376:	f7ff fa94 	bl	c0058a2 <mpi_montmul>
 c00637a:	4602      	mov	r2, r0
 c00637c:	2800      	cmp	r0, #0
 c00637e:	f040 80a0 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
        for( i = 0; i < wsize - 1; i++ )
 c006382:	f10a 0a01 	add.w	sl, sl, #1
 c006386:	45d3      	cmp	fp, sl
 c006388:	9b05      	ldr	r3, [sp, #20]
 c00638a:	d8ee      	bhi.n	c00636a <mbedtls_mpi_exp_mod+0x2a8>
        for( i = j + 1; i < ( one << wsize ); i++ )
 c00638c:	f04f 0a01 	mov.w	sl, #1
 c006390:	46bb      	mov	fp, r7
 c006392:	f108 0801 	add.w	r8, r8, #1
 c006396:	fa0a fa06 	lsl.w	sl, sl, r6
            MBEDTLS_MPI_CHK( mpi_montmul( &W[i], &W[1], N, mm, &T ) );
 c00639a:	af0b      	add	r7, sp, #44	; 0x2c
        for( i = j + 1; i < ( one << wsize ); i++ )
 c00639c:	45c2      	cmp	sl, r8
 c00639e:	f67f af71 	bls.w	c006284 <mbedtls_mpi_exp_mod+0x1c2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[i], N->n + 1 ) );
 c0063a2:	6861      	ldr	r1, [r4, #4]
 c0063a4:	f10b 090c 	add.w	r9, fp, #12
 c0063a8:	4648      	mov	r0, r9
 c0063aa:	3101      	adds	r1, #1
 c0063ac:	9305      	str	r3, [sp, #20]
 c0063ae:	f7ff f892 	bl	c0054d6 <mbedtls_mpi_grow>
 c0063b2:	4602      	mov	r2, r0
 c0063b4:	2800      	cmp	r0, #0
 c0063b6:	f040 8084 	bne.w	c0064c2 <mbedtls_mpi_exp_mod+0x400>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[i], &W[i - 1] ) );
 c0063ba:	4659      	mov	r1, fp
 c0063bc:	4648      	mov	r0, r9
 c0063be:	f7ff f8b0 	bl	c005522 <mbedtls_mpi_copy>
 c0063c2:	4602      	mov	r2, r0
 c0063c4:	2800      	cmp	r0, #0
 c0063c6:	d17c      	bne.n	c0064c2 <mbedtls_mpi_exp_mod+0x400>
            MBEDTLS_MPI_CHK( mpi_montmul( &W[i], &W[1], N, mm, &T ) );
 c0063c8:	4622      	mov	r2, r4
 c0063ca:	4648      	mov	r0, r9
 c0063cc:	9b05      	ldr	r3, [sp, #20]
 c0063ce:	9700      	str	r7, [sp, #0]
 c0063d0:	a917      	add	r1, sp, #92	; 0x5c
 c0063d2:	f7ff fa66 	bl	c0058a2 <mpi_montmul>
 c0063d6:	4602      	mov	r2, r0
 c0063d8:	2800      	cmp	r0, #0
 c0063da:	d172      	bne.n	c0064c2 <mbedtls_mpi_exp_mod+0x400>
        for( i = j + 1; i < ( one << wsize ); i++ )
 c0063dc:	46cb      	mov	fp, r9
 c0063de:	9b05      	ldr	r3, [sp, #20]
 c0063e0:	f108 0801 	add.w	r8, r8, #1
 c0063e4:	e7da      	b.n	c00639c <mbedtls_mpi_exp_mod+0x2da>
        state = 2;
 c0063e6:	f04f 0802 	mov.w	r8, #2
 c0063ea:	e753      	b.n	c006294 <mbedtls_mpi_exp_mod+0x1d2>
            bufsize = sizeof( mbedtls_mpi_uint ) << 3;
 c0063ec:	f04f 0920 	mov.w	r9, #32
            nblimbs--;
 c0063f0:	f10b 3bff 	add.w	fp, fp, #4294967295
        ei = (E->p[nblimbs] >> bufsize) & 1;
 c0063f4:	9a02      	ldr	r2, [sp, #8]
        bufsize--;
 c0063f6:	f109 39ff 	add.w	r9, r9, #4294967295
        ei = (E->p[nblimbs] >> bufsize) & 1;
 c0063fa:	6892      	ldr	r2, [r2, #8]
 c0063fc:	f852 202b 	ldr.w	r2, [r2, fp, lsl #2]
 c006400:	fa22 f209 	lsr.w	r2, r2, r9
        if( ei == 0 && state == 0 )
 c006404:	f012 0201 	ands.w	r2, r2, #1
 c006408:	d113      	bne.n	c006432 <mbedtls_mpi_exp_mod+0x370>
 c00640a:	f1b8 0f00 	cmp.w	r8, #0
 c00640e:	f43f af41 	beq.w	c006294 <mbedtls_mpi_exp_mod+0x1d2>
        if( ei == 0 && state == 1 )
 c006412:	f1b8 0f01 	cmp.w	r8, #1
 c006416:	d10c      	bne.n	c006432 <mbedtls_mpi_exp_mod+0x370>
            MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
 c006418:	aa0b      	add	r2, sp, #44	; 0x2c
 c00641a:	9200      	str	r2, [sp, #0]
 c00641c:	4629      	mov	r1, r5
 c00641e:	4622      	mov	r2, r4
 c006420:	4628      	mov	r0, r5
 c006422:	9305      	str	r3, [sp, #20]
 c006424:	f7ff fa3d 	bl	c0058a2 <mpi_montmul>
 c006428:	4602      	mov	r2, r0
 c00642a:	2800      	cmp	r0, #0
 c00642c:	d149      	bne.n	c0064c2 <mbedtls_mpi_exp_mod+0x400>
 c00642e:	9b05      	ldr	r3, [sp, #20]
 c006430:	e730      	b.n	c006294 <mbedtls_mpi_exp_mod+0x1d2>
        nbits++;
 c006432:	3701      	adds	r7, #1
        wbits |= ( ei << ( wsize - nbits ) );
 c006434:	1bf1      	subs	r1, r6, r7
 c006436:	408a      	lsls	r2, r1
        if( nbits == wsize )
 c006438:	42be      	cmp	r6, r7
        wbits |= ( ei << ( wsize - nbits ) );
 c00643a:	ea4a 0a02 	orr.w	sl, sl, r2
        if( nbits == wsize )
 c00643e:	d1d2      	bne.n	c0063e6 <mbedtls_mpi_exp_mod+0x324>
            for( i = 0; i < wsize; i++ )
 c006440:	f04f 0800 	mov.w	r8, #0
                MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
 c006444:	aa0b      	add	r2, sp, #44	; 0x2c
 c006446:	9200      	str	r2, [sp, #0]
 c006448:	4629      	mov	r1, r5
 c00644a:	4622      	mov	r2, r4
 c00644c:	4628      	mov	r0, r5
 c00644e:	9305      	str	r3, [sp, #20]
 c006450:	f7ff fa27 	bl	c0058a2 <mpi_montmul>
 c006454:	4602      	mov	r2, r0
 c006456:	bba0      	cbnz	r0, c0064c2 <mbedtls_mpi_exp_mod+0x400>
            for( i = 0; i < wsize; i++ )
 c006458:	f108 0801 	add.w	r8, r8, #1
 c00645c:	4547      	cmp	r7, r8
 c00645e:	9b05      	ldr	r3, [sp, #20]
 c006460:	d8f0      	bhi.n	c006444 <mbedtls_mpi_exp_mod+0x382>
            MBEDTLS_MPI_CHK( mpi_montmul( X, &W[wbits], N, mm, &T ) );
 c006462:	210c      	movs	r1, #12
 c006464:	aa0b      	add	r2, sp, #44	; 0x2c
 c006466:	a814      	add	r0, sp, #80	; 0x50
 c006468:	fb01 010a 	mla	r1, r1, sl, r0
 c00646c:	9200      	str	r2, [sp, #0]
 c00646e:	4628      	mov	r0, r5
 c006470:	4622      	mov	r2, r4
 c006472:	f7ff fa16 	bl	c0058a2 <mpi_montmul>
 c006476:	4602      	mov	r2, r0
 c006478:	bb18      	cbnz	r0, c0064c2 <mbedtls_mpi_exp_mod+0x400>
            nbits = 0;
 c00647a:	4607      	mov	r7, r0
            wbits = 0;
 c00647c:	4682      	mov	sl, r0
            state--;
 c00647e:	f8dd 8010 	ldr.w	r8, [sp, #16]
 c006482:	e7d4      	b.n	c00642e <mbedtls_mpi_exp_mod+0x36c>
        MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
 c006484:	4622      	mov	r2, r4
 c006486:	4629      	mov	r1, r5
 c006488:	4628      	mov	r0, r5
 c00648a:	f8cd 8000 	str.w	r8, [sp]
 c00648e:	9304      	str	r3, [sp, #16]
 c006490:	f7ff fa07 	bl	c0058a2 <mpi_montmul>
 c006494:	4602      	mov	r2, r0
 c006496:	b9a0      	cbnz	r0, c0064c2 <mbedtls_mpi_exp_mod+0x400>
        wbits <<= 1;
 c006498:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
        if( ( wbits & ( one << wsize ) ) != 0 )
 c00649c:	ea19 0f0a 	tst.w	r9, sl
 c0064a0:	9b04      	ldr	r3, [sp, #16]
 c0064a2:	d102      	bne.n	c0064aa <mbedtls_mpi_exp_mod+0x3e8>
    for( i = 0; i < nbits; i++ )
 c0064a4:	f10b 0b01 	add.w	fp, fp, #1
 c0064a8:	e702      	b.n	c0062b0 <mbedtls_mpi_exp_mod+0x1ee>
            MBEDTLS_MPI_CHK( mpi_montmul( X, &W[1], N, mm, &T ) );
 c0064aa:	4622      	mov	r2, r4
 c0064ac:	4628      	mov	r0, r5
 c0064ae:	f8cd 8000 	str.w	r8, [sp]
 c0064b2:	a917      	add	r1, sp, #92	; 0x5c
 c0064b4:	9304      	str	r3, [sp, #16]
 c0064b6:	f7ff f9f4 	bl	c0058a2 <mpi_montmul>
 c0064ba:	9b04      	ldr	r3, [sp, #16]
 c0064bc:	4602      	mov	r2, r0
 c0064be:	2800      	cmp	r0, #0
 c0064c0:	d0f0      	beq.n	c0064a4 <mbedtls_mpi_exp_mod+0x3e2>

    for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
 c0064c2:	2301      	movs	r3, #1
        mbedtls_mpi_free( &W[i] );
 c0064c4:	250c      	movs	r5, #12
    for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
 c0064c6:	1e74      	subs	r4, r6, #1
 c0064c8:	fa03 f404 	lsl.w	r4, r3, r4
 c0064cc:	fa03 f606 	lsl.w	r6, r3, r6
 c0064d0:	42a6      	cmp	r6, r4
 c0064d2:	9202      	str	r2, [sp, #8]
 c0064d4:	d818      	bhi.n	c006508 <mbedtls_mpi_exp_mod+0x446>

    mbedtls_mpi_free( &W[1] ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &Apos );
 c0064d6:	a817      	add	r0, sp, #92	; 0x5c
 c0064d8:	f7fe ffeb 	bl	c0054b2 <mbedtls_mpi_free>
 c0064dc:	a80b      	add	r0, sp, #44	; 0x2c
 c0064de:	f7fe ffe8 	bl	c0054b2 <mbedtls_mpi_free>
 c0064e2:	a80e      	add	r0, sp, #56	; 0x38
 c0064e4:	f7fe ffe5 	bl	c0054b2 <mbedtls_mpi_free>

    if( _RR == NULL || _RR->p == NULL )
 c0064e8:	f8dd 3678 	ldr.w	r3, [sp, #1656]	; 0x678
 c0064ec:	9a02      	ldr	r2, [sp, #8]
 c0064ee:	b10b      	cbz	r3, c0064f4 <mbedtls_mpi_exp_mod+0x432>
 c0064f0:	689b      	ldr	r3, [r3, #8]
 c0064f2:	b923      	cbnz	r3, c0064fe <mbedtls_mpi_exp_mod+0x43c>
        mbedtls_mpi_free( &RR );
 c0064f4:	a808      	add	r0, sp, #32
 c0064f6:	9202      	str	r2, [sp, #8]
 c0064f8:	f7fe ffdb 	bl	c0054b2 <mbedtls_mpi_free>
 c0064fc:	9a02      	ldr	r2, [sp, #8]

    return( ret );
}
 c0064fe:	4610      	mov	r0, r2
 c006500:	f20d 6d54 	addw	sp, sp, #1620	; 0x654
 c006504:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        mbedtls_mpi_free( &W[i] );
 c006508:	ab14      	add	r3, sp, #80	; 0x50
 c00650a:	fb05 3004 	mla	r0, r5, r4, r3
 c00650e:	f7fe ffd0 	bl	c0054b2 <mbedtls_mpi_free>
    for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
 c006512:	3401      	adds	r4, #1
 c006514:	9a02      	ldr	r2, [sp, #8]
 c006516:	e7db      	b.n	c0064d0 <mbedtls_mpi_exp_mod+0x40e>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c006518:	f06f 0203 	mvn.w	r2, #3
 c00651c:	e7ef      	b.n	c0064fe <mbedtls_mpi_exp_mod+0x43c>

0c00651e <mbedtls_mpi_gcd>:

/*
 * Greatest common divisor: G = gcd(A, B)  (HAC 14.54)
 */
int mbedtls_mpi_gcd( mbedtls_mpi *G, const mbedtls_mpi *A, const mbedtls_mpi *B )
{
 c00651e:	b5f0      	push	{r4, r5, r6, r7, lr}
    X->n = 0;
 c006520:	2300      	movs	r3, #0
 c006522:	2701      	movs	r7, #1
{
 c006524:	b08b      	sub	sp, #44	; 0x2c
 c006526:	4605      	mov	r5, r0
    MPI_VALIDATE_RET( A != NULL );
    MPI_VALIDATE_RET( B != NULL );

    mbedtls_mpi_init( &TG ); mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TB );

    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
 c006528:	a804      	add	r0, sp, #16
{
 c00652a:	4616      	mov	r6, r2
    X->n = 0;
 c00652c:	e9cd 7301 	strd	r7, r3, [sp, #4]
    X->s = 1;
 c006530:	e9cd 3703 	strd	r3, r7, [sp, #12]
    X->p = NULL;
 c006534:	e9cd 3305 	strd	r3, r3, [sp, #20]
    X->n = 0;
 c006538:	e9cd 7307 	strd	r7, r3, [sp, #28]
    X->p = NULL;
 c00653c:	9309      	str	r3, [sp, #36]	; 0x24
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
 c00653e:	f7fe fff0 	bl	c005522 <mbedtls_mpi_copy>
 c006542:	4604      	mov	r4, r0
 c006544:	2800      	cmp	r0, #0
 c006546:	d157      	bne.n	c0065f8 <mbedtls_mpi_gcd+0xda>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
 c006548:	4631      	mov	r1, r6
 c00654a:	a807      	add	r0, sp, #28
 c00654c:	f7fe ffe9 	bl	c005522 <mbedtls_mpi_copy>
 c006550:	4604      	mov	r4, r0
 c006552:	2800      	cmp	r0, #0
 c006554:	d150      	bne.n	c0065f8 <mbedtls_mpi_gcd+0xda>

    lz = mbedtls_mpi_lsb( &TA );
 c006556:	a804      	add	r0, sp, #16
 c006558:	f7ff f83c 	bl	c0055d4 <mbedtls_mpi_lsb>
 c00655c:	4606      	mov	r6, r0
    lzt = mbedtls_mpi_lsb( &TB );
 c00655e:	a807      	add	r0, sp, #28
 c006560:	f7ff f838 	bl	c0055d4 <mbedtls_mpi_lsb>

    if( lzt < lz )
 c006564:	4286      	cmp	r6, r0
 c006566:	bf28      	it	cs
 c006568:	4606      	movcs	r6, r0
        lz = lzt;

    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, lz ) );
 c00656a:	a804      	add	r0, sp, #16
 c00656c:	4631      	mov	r1, r6
 c00656e:	f7ff f92b 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c006572:	4604      	mov	r4, r0
 c006574:	2800      	cmp	r0, #0
 c006576:	d13f      	bne.n	c0065f8 <mbedtls_mpi_gcd+0xda>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, lz ) );
 c006578:	4631      	mov	r1, r6
 c00657a:	a807      	add	r0, sp, #28
 c00657c:	f7ff f924 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c006580:	4604      	mov	r4, r0
 c006582:	2800      	cmp	r0, #0
 c006584:	d138      	bne.n	c0065f8 <mbedtls_mpi_gcd+0xda>

    TA.s = TB.s = 1;
 c006586:	9707      	str	r7, [sp, #28]
 c006588:	9704      	str	r7, [sp, #16]

    while( mbedtls_mpi_cmp_int( &TA, 0 ) != 0 )
 c00658a:	2100      	movs	r1, #0
 c00658c:	a804      	add	r0, sp, #16
 c00658e:	f7ff fa32 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c006592:	b958      	cbnz	r0, c0065ac <mbedtls_mpi_gcd+0x8e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TB, &TB, &TA ) );
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
        }
    }

    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &TB, lz ) );
 c006594:	4631      	mov	r1, r6
 c006596:	a807      	add	r0, sp, #28
 c006598:	f7ff f8c8 	bl	c00572c <mbedtls_mpi_shift_l>
 c00659c:	4604      	mov	r4, r0
 c00659e:	bb58      	cbnz	r0, c0065f8 <mbedtls_mpi_gcd+0xda>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( G, &TB ) );
 c0065a0:	4628      	mov	r0, r5
 c0065a2:	a907      	add	r1, sp, #28
 c0065a4:	f7fe ffbd 	bl	c005522 <mbedtls_mpi_copy>
 c0065a8:	4604      	mov	r4, r0

cleanup:
 c0065aa:	e025      	b.n	c0065f8 <mbedtls_mpi_gcd+0xda>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, mbedtls_mpi_lsb( &TA ) ) );
 c0065ac:	a804      	add	r0, sp, #16
 c0065ae:	f7ff f811 	bl	c0055d4 <mbedtls_mpi_lsb>
 c0065b2:	4601      	mov	r1, r0
 c0065b4:	a804      	add	r0, sp, #16
 c0065b6:	f7ff f907 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c0065ba:	4604      	mov	r4, r0
 c0065bc:	b9e0      	cbnz	r0, c0065f8 <mbedtls_mpi_gcd+0xda>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, mbedtls_mpi_lsb( &TB ) ) );
 c0065be:	a807      	add	r0, sp, #28
 c0065c0:	f7ff f808 	bl	c0055d4 <mbedtls_mpi_lsb>
 c0065c4:	4601      	mov	r1, r0
 c0065c6:	a807      	add	r0, sp, #28
 c0065c8:	f7ff f8fe 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c0065cc:	4604      	mov	r4, r0
 c0065ce:	b998      	cbnz	r0, c0065f8 <mbedtls_mpi_gcd+0xda>
        if( mbedtls_mpi_cmp_mpi( &TA, &TB ) >= 0 )
 c0065d0:	a907      	add	r1, sp, #28
 c0065d2:	a804      	add	r0, sp, #16
 c0065d4:	f7ff f9cc 	bl	c005970 <mbedtls_mpi_cmp_mpi>
 c0065d8:	2800      	cmp	r0, #0
 c0065da:	db19      	blt.n	c006610 <mbedtls_mpi_gcd+0xf2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TA, &TA, &TB ) );
 c0065dc:	a904      	add	r1, sp, #16
 c0065de:	4608      	mov	r0, r1
 c0065e0:	aa07      	add	r2, sp, #28
 c0065e2:	f7ff fa77 	bl	c005ad4 <mbedtls_mpi_sub_abs>
 c0065e6:	4604      	mov	r4, r0
 c0065e8:	b930      	cbnz	r0, c0065f8 <mbedtls_mpi_gcd+0xda>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, 1 ) );
 c0065ea:	2101      	movs	r1, #1
 c0065ec:	a804      	add	r0, sp, #16
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
 c0065ee:	f7ff f8eb 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c0065f2:	4604      	mov	r4, r0
 c0065f4:	2800      	cmp	r0, #0
 c0065f6:	d0c8      	beq.n	c00658a <mbedtls_mpi_gcd+0x6c>

    mbedtls_mpi_free( &TG ); mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TB );
 c0065f8:	a801      	add	r0, sp, #4
 c0065fa:	f7fe ff5a 	bl	c0054b2 <mbedtls_mpi_free>
 c0065fe:	a804      	add	r0, sp, #16
 c006600:	f7fe ff57 	bl	c0054b2 <mbedtls_mpi_free>
 c006604:	a807      	add	r0, sp, #28
 c006606:	f7fe ff54 	bl	c0054b2 <mbedtls_mpi_free>

    return( ret );
}
 c00660a:	4620      	mov	r0, r4
 c00660c:	b00b      	add	sp, #44	; 0x2c
 c00660e:	bdf0      	pop	{r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TB, &TB, &TA ) );
 c006610:	a907      	add	r1, sp, #28
 c006612:	4608      	mov	r0, r1
 c006614:	aa04      	add	r2, sp, #16
 c006616:	f7ff fa5d 	bl	c005ad4 <mbedtls_mpi_sub_abs>
 c00661a:	4604      	mov	r4, r0
 c00661c:	2800      	cmp	r0, #0
 c00661e:	d1eb      	bne.n	c0065f8 <mbedtls_mpi_gcd+0xda>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
 c006620:	2101      	movs	r1, #1
 c006622:	a807      	add	r0, sp, #28
 c006624:	e7e3      	b.n	c0065ee <mbedtls_mpi_gcd+0xd0>

0c006626 <mbedtls_mpi_fill_random>:
 * deterministic, eg for tests).
 */
int mbedtls_mpi_fill_random( mbedtls_mpi *X, size_t size,
                     int (*f_rng)(void *, unsigned char *, size_t),
                     void *p_rng )
{
 c006626:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    int ret;
    size_t const limbs = CHARS_TO_LIMBS( size );
 c00662a:	f011 0503 	ands.w	r5, r1, #3
 c00662e:	bf18      	it	ne
 c006630:	2501      	movne	r5, #1
{
 c006632:	4699      	mov	r9, r3

    MPI_VALIDATE_RET( X     != NULL );
    MPI_VALIDATE_RET( f_rng != NULL );

    /* Ensure that target MPI has exactly the necessary number of limbs */
    if( X->n != limbs )
 c006634:	6843      	ldr	r3, [r0, #4]
    size_t const limbs = CHARS_TO_LIMBS( size );
 c006636:	eb05 0591 	add.w	r5, r5, r1, lsr #2
    if( X->n != limbs )
 c00663a:	42ab      	cmp	r3, r5
{
 c00663c:	4604      	mov	r4, r0
 c00663e:	460f      	mov	r7, r1
 c006640:	4690      	mov	r8, r2
    if( X->n != limbs )
 c006642:	d108      	bne.n	c006656 <mbedtls_mpi_fill_random+0x30>
    {
        mbedtls_mpi_free( X );
        mbedtls_mpi_init( X );
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
    }
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 c006644:	2100      	movs	r1, #0
 c006646:	4620      	mov	r0, r4
 c006648:	f7fe ff97 	bl	c00557a <mbedtls_mpi_lset>
 c00664c:	4606      	mov	r6, r0
 c00664e:	b188      	cbz	r0, c006674 <mbedtls_mpi_fill_random+0x4e>

    mpi_bigendian_to_host( X->p, limbs );

cleanup:
    return( ret );
}
 c006650:	4630      	mov	r0, r6
 c006652:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        mbedtls_mpi_free( X );
 c006656:	f7fe ff2c 	bl	c0054b2 <mbedtls_mpi_free>
    X->n = 0;
 c00665a:	2300      	movs	r3, #0
 c00665c:	2201      	movs	r2, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
 c00665e:	4629      	mov	r1, r5
 c006660:	4620      	mov	r0, r4
    X->n = 0;
 c006662:	e9c4 2300 	strd	r2, r3, [r4]
    X->p = NULL;
 c006666:	60a3      	str	r3, [r4, #8]
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
 c006668:	f7fe ff35 	bl	c0054d6 <mbedtls_mpi_grow>
 c00666c:	4606      	mov	r6, r0
 c00666e:	2800      	cmp	r0, #0
 c006670:	d0e8      	beq.n	c006644 <mbedtls_mpi_fill_random+0x1e>
 c006672:	e7ed      	b.n	c006650 <mbedtls_mpi_fill_random+0x2a>
    f_rng( p_rng, Xp + overhead, size );
 c006674:	68a1      	ldr	r1, [r4, #8]
    size_t const overhead = ( limbs * ciL ) - size;
 c006676:	ebc7 0385 	rsb	r3, r7, r5, lsl #2
    f_rng( p_rng, Xp + overhead, size );
 c00667a:	463a      	mov	r2, r7
 c00667c:	4648      	mov	r0, r9
 c00667e:	4419      	add	r1, r3
 c006680:	47c0      	blx	r8
    if( limbs == 0 )
 c006682:	2d00      	cmp	r5, #0
 c006684:	d0e4      	beq.n	c006650 <mbedtls_mpi_fill_random+0x2a>
 c006686:	4629      	mov	r1, r5
 c006688:	68a0      	ldr	r0, [r4, #8]
 c00668a:	f7fe fefa 	bl	c005482 <mpi_bigendian_to_host.part.0>
    return( ret );
 c00668e:	e7df      	b.n	c006650 <mbedtls_mpi_fill_random+0x2a>

0c006690 <mbedtls_mpi_inv_mod>:

/*
 * Modular inverse: X = A^-1 mod N  (HAC 14.61 / 14.64)
 */
int mbedtls_mpi_inv_mod( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *N )
{
 c006690:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c006694:	4606      	mov	r6, r0
 c006696:	4688      	mov	r8, r1
    mbedtls_mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
    MPI_VALIDATE_RET( X != NULL );
    MPI_VALIDATE_RET( A != NULL );
    MPI_VALIDATE_RET( N != NULL );

    if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
 c006698:	4610      	mov	r0, r2
 c00669a:	2101      	movs	r1, #1
{
 c00669c:	b09c      	sub	sp, #112	; 0x70
 c00669e:	4615      	mov	r5, r2
    if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
 c0066a0:	f7ff f9a9 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c0066a4:	2800      	cmp	r0, #0
 c0066a6:	f340 814c 	ble.w	c006942 <mbedtls_mpi_inv_mod+0x2b2>
    X->n = 0;
 c0066aa:	2300      	movs	r3, #0
 c0066ac:	2701      	movs	r7, #1

    mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TU ); mbedtls_mpi_init( &U1 ); mbedtls_mpi_init( &U2 );
    mbedtls_mpi_init( &G ); mbedtls_mpi_init( &TB ); mbedtls_mpi_init( &TV );
    mbedtls_mpi_init( &V1 ); mbedtls_mpi_init( &V2 );

    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
 c0066ae:	462a      	mov	r2, r5
 c0066b0:	4641      	mov	r1, r8
 c0066b2:	a801      	add	r0, sp, #4
    X->n = 0;
 c0066b4:	e9cd 7304 	strd	r7, r3, [sp, #16]
    X->s = 1;
 c0066b8:	e9cd 3706 	strd	r3, r7, [sp, #24]
    X->p = NULL;
 c0066bc:	e9cd 3308 	strd	r3, r3, [sp, #32]
    X->n = 0;
 c0066c0:	e9cd 730a 	strd	r7, r3, [sp, #40]	; 0x28
    X->s = 1;
 c0066c4:	e9cd 370c 	strd	r3, r7, [sp, #48]	; 0x30
    X->p = NULL;
 c0066c8:	e9cd 330e 	strd	r3, r3, [sp, #56]	; 0x38
    X->n = 0;
 c0066cc:	e9cd 7301 	strd	r7, r3, [sp, #4]
 c0066d0:	e9cd 7310 	strd	r7, r3, [sp, #64]	; 0x40
    X->s = 1;
 c0066d4:	e9cd 3712 	strd	r3, r7, [sp, #72]	; 0x48
    X->p = NULL;
 c0066d8:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
    X->n = 0;
 c0066dc:	e9cd 7316 	strd	r7, r3, [sp, #88]	; 0x58
    X->s = 1;
 c0066e0:	e9cd 3718 	strd	r3, r7, [sp, #96]	; 0x60
    X->p = NULL;
 c0066e4:	e9cd 331a 	strd	r3, r3, [sp, #104]	; 0x68
 c0066e8:	9303      	str	r3, [sp, #12]
    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
 c0066ea:	f7ff ff18 	bl	c00651e <mbedtls_mpi_gcd>
 c0066ee:	4604      	mov	r4, r0
 c0066f0:	2800      	cmp	r0, #0
 c0066f2:	f040 8097 	bne.w	c006824 <mbedtls_mpi_inv_mod+0x194>

    if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
 c0066f6:	4639      	mov	r1, r7
 c0066f8:	a801      	add	r0, sp, #4
 c0066fa:	f7ff f97c 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c0066fe:	2800      	cmp	r0, #0
 c006700:	f040 811c 	bne.w	c00693c <mbedtls_mpi_inv_mod+0x2ac>
    {
        ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
        goto cleanup;
    }

    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &TA, A, N ) );
 c006704:	462a      	mov	r2, r5
 c006706:	4641      	mov	r1, r8
 c006708:	a804      	add	r0, sp, #16
 c00670a:	f7ff fca8 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c00670e:	4604      	mov	r4, r0
 c006710:	2800      	cmp	r0, #0
 c006712:	f040 8087 	bne.w	c006824 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TU, &TA ) );
 c006716:	a904      	add	r1, sp, #16
 c006718:	a807      	add	r0, sp, #28
 c00671a:	f7fe ff02 	bl	c005522 <mbedtls_mpi_copy>
 c00671e:	4604      	mov	r4, r0
 c006720:	2800      	cmp	r0, #0
 c006722:	d17f      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, N ) );
 c006724:	4629      	mov	r1, r5
 c006726:	a810      	add	r0, sp, #64	; 0x40
 c006728:	f7fe fefb 	bl	c005522 <mbedtls_mpi_copy>
 c00672c:	4604      	mov	r4, r0
 c00672e:	2800      	cmp	r0, #0
 c006730:	d178      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TV, N ) );
 c006732:	4629      	mov	r1, r5
 c006734:	a813      	add	r0, sp, #76	; 0x4c
 c006736:	f7fe fef4 	bl	c005522 <mbedtls_mpi_copy>
 c00673a:	4604      	mov	r4, r0
 c00673c:	2800      	cmp	r0, #0
 c00673e:	d171      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>

    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U1, 1 ) );
 c006740:	4639      	mov	r1, r7
 c006742:	a80a      	add	r0, sp, #40	; 0x28
 c006744:	f7fe ff19 	bl	c00557a <mbedtls_mpi_lset>
 c006748:	4604      	mov	r4, r0
 c00674a:	2800      	cmp	r0, #0
 c00674c:	d16a      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U2, 0 ) );
 c00674e:	4601      	mov	r1, r0
 c006750:	a80d      	add	r0, sp, #52	; 0x34
 c006752:	f7fe ff12 	bl	c00557a <mbedtls_mpi_lset>
 c006756:	4604      	mov	r4, r0
 c006758:	2800      	cmp	r0, #0
 c00675a:	d163      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V1, 0 ) );
 c00675c:	4601      	mov	r1, r0
 c00675e:	a816      	add	r0, sp, #88	; 0x58
 c006760:	f7fe ff0b 	bl	c00557a <mbedtls_mpi_lset>
 c006764:	4604      	mov	r4, r0
 c006766:	2800      	cmp	r0, #0
 c006768:	d15c      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V2, 1 ) );
 c00676a:	4639      	mov	r1, r7
 c00676c:	a819      	add	r0, sp, #100	; 0x64
 c00676e:	f7fe ff04 	bl	c00557a <mbedtls_mpi_lset>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &U1, &U1, &TB ) );
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &TA ) );
            }

            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U1, 1 ) );
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
 c006772:	4604      	mov	r4, r0
 c006774:	2800      	cmp	r0, #0
 c006776:	d155      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
        while( ( TU.p[0] & 1 ) == 0 )
 c006778:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c00677a:	681b      	ldr	r3, [r3, #0]
 c00677c:	07d8      	lsls	r0, r3, #31
 c00677e:	d53c      	bpl.n	c0067fa <mbedtls_mpi_inv_mod+0x16a>
        }

        while( ( TV.p[0] & 1 ) == 0 )
 c006780:	9b15      	ldr	r3, [sp, #84]	; 0x54
 c006782:	681b      	ldr	r3, [r3, #0]
 c006784:	07db      	lsls	r3, r3, #31
 c006786:	f140 8082 	bpl.w	c00688e <mbedtls_mpi_inv_mod+0x1fe>

            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V1, 1 ) );
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V2, 1 ) );
        }

        if( mbedtls_mpi_cmp_mpi( &TU, &TV ) >= 0 )
 c00678a:	a913      	add	r1, sp, #76	; 0x4c
 c00678c:	a807      	add	r0, sp, #28
 c00678e:	f7ff f8ef 	bl	c005970 <mbedtls_mpi_cmp_mpi>
 c006792:	2800      	cmp	r0, #0
 c006794:	f2c0 80ab 	blt.w	c0068ee <mbedtls_mpi_inv_mod+0x25e>
        {
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TU, &TU, &TV ) );
 c006798:	a907      	add	r1, sp, #28
 c00679a:	4608      	mov	r0, r1
 c00679c:	aa13      	add	r2, sp, #76	; 0x4c
 c00679e:	f7ff f9f8 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c0067a2:	4604      	mov	r4, r0
 c0067a4:	2800      	cmp	r0, #0
 c0067a6:	d13d      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U1, &U1, &V1 ) );
 c0067a8:	a90a      	add	r1, sp, #40	; 0x28
 c0067aa:	4608      	mov	r0, r1
 c0067ac:	aa16      	add	r2, sp, #88	; 0x58
 c0067ae:	f7ff f9f0 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c0067b2:	4604      	mov	r4, r0
 c0067b4:	2800      	cmp	r0, #0
 c0067b6:	d135      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &V2 ) );
 c0067b8:	aa19      	add	r2, sp, #100	; 0x64
 c0067ba:	a90d      	add	r1, sp, #52	; 0x34
 c0067bc:	4608      	mov	r0, r1
 c0067be:	f7ff f9e8 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c0067c2:	4604      	mov	r4, r0
 c0067c4:	bb70      	cbnz	r0, c006824 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TV, &TV, &TU ) );
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, &U1 ) );
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &U2 ) );
        }
    }
    while( mbedtls_mpi_cmp_int( &TU, 0 ) != 0 );
 c0067c6:	2100      	movs	r1, #0
 c0067c8:	a807      	add	r0, sp, #28
 c0067ca:	f7ff f914 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c0067ce:	2800      	cmp	r0, #0
 c0067d0:	d1d2      	bne.n	c006778 <mbedtls_mpi_inv_mod+0xe8>

    while( mbedtls_mpi_cmp_int( &V1, 0 ) < 0 )
 c0067d2:	2100      	movs	r1, #0
 c0067d4:	a816      	add	r0, sp, #88	; 0x58
 c0067d6:	f7ff f90e 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c0067da:	2800      	cmp	r0, #0
 c0067dc:	f2c0 809a 	blt.w	c006914 <mbedtls_mpi_inv_mod+0x284>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, N ) );

    while( mbedtls_mpi_cmp_mpi( &V1, N ) >= 0 )
 c0067e0:	4629      	mov	r1, r5
 c0067e2:	a816      	add	r0, sp, #88	; 0x58
 c0067e4:	f7ff f8c4 	bl	c005970 <mbedtls_mpi_cmp_mpi>
 c0067e8:	2800      	cmp	r0, #0
 c0067ea:	f280 809d 	bge.w	c006928 <mbedtls_mpi_inv_mod+0x298>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, N ) );

    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &V1 ) );
 c0067ee:	4630      	mov	r0, r6
 c0067f0:	a916      	add	r1, sp, #88	; 0x58
 c0067f2:	f7fe fe96 	bl	c005522 <mbedtls_mpi_copy>
 c0067f6:	4604      	mov	r4, r0

cleanup:
 c0067f8:	e014      	b.n	c006824 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TU, 1 ) );
 c0067fa:	2101      	movs	r1, #1
 c0067fc:	a807      	add	r0, sp, #28
 c0067fe:	f7fe ffe3 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c006802:	4604      	mov	r4, r0
 c006804:	b970      	cbnz	r0, c006824 <mbedtls_mpi_inv_mod+0x194>
            if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
 c006806:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 c006808:	681b      	ldr	r3, [r3, #0]
 c00680a:	07df      	lsls	r7, r3, #31
 c00680c:	d429      	bmi.n	c006862 <mbedtls_mpi_inv_mod+0x1d2>
 c00680e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 c006810:	681b      	ldr	r3, [r3, #0]
 c006812:	07dc      	lsls	r4, r3, #31
 c006814:	d425      	bmi.n	c006862 <mbedtls_mpi_inv_mod+0x1d2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U1, 1 ) );
 c006816:	2101      	movs	r1, #1
 c006818:	a80a      	add	r0, sp, #40	; 0x28
 c00681a:	f7fe ffd5 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c00681e:	4604      	mov	r4, r0
 c006820:	2800      	cmp	r0, #0
 c006822:	d02f      	beq.n	c006884 <mbedtls_mpi_inv_mod+0x1f4>

    mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TU ); mbedtls_mpi_free( &U1 ); mbedtls_mpi_free( &U2 );
 c006824:	a804      	add	r0, sp, #16
 c006826:	f7fe fe44 	bl	c0054b2 <mbedtls_mpi_free>
 c00682a:	a807      	add	r0, sp, #28
 c00682c:	f7fe fe41 	bl	c0054b2 <mbedtls_mpi_free>
 c006830:	a80a      	add	r0, sp, #40	; 0x28
 c006832:	f7fe fe3e 	bl	c0054b2 <mbedtls_mpi_free>
 c006836:	a80d      	add	r0, sp, #52	; 0x34
 c006838:	f7fe fe3b 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &G ); mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TV );
 c00683c:	a801      	add	r0, sp, #4
 c00683e:	f7fe fe38 	bl	c0054b2 <mbedtls_mpi_free>
 c006842:	a810      	add	r0, sp, #64	; 0x40
 c006844:	f7fe fe35 	bl	c0054b2 <mbedtls_mpi_free>
 c006848:	a813      	add	r0, sp, #76	; 0x4c
 c00684a:	f7fe fe32 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &V1 ); mbedtls_mpi_free( &V2 );
 c00684e:	a816      	add	r0, sp, #88	; 0x58
 c006850:	f7fe fe2f 	bl	c0054b2 <mbedtls_mpi_free>
 c006854:	a819      	add	r0, sp, #100	; 0x64
 c006856:	f7fe fe2c 	bl	c0054b2 <mbedtls_mpi_free>

    return( ret );
}
 c00685a:	4620      	mov	r0, r4
 c00685c:	b01c      	add	sp, #112	; 0x70
 c00685e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &U1, &U1, &TB ) );
 c006862:	a90a      	add	r1, sp, #40	; 0x28
 c006864:	4608      	mov	r0, r1
 c006866:	aa10      	add	r2, sp, #64	; 0x40
 c006868:	f7ff f971 	bl	c005b4e <mbedtls_mpi_add_mpi>
 c00686c:	4604      	mov	r4, r0
 c00686e:	2800      	cmp	r0, #0
 c006870:	d1d8      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &TA ) );
 c006872:	a90d      	add	r1, sp, #52	; 0x34
 c006874:	4608      	mov	r0, r1
 c006876:	aa04      	add	r2, sp, #16
 c006878:	f7ff f98b 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c00687c:	4604      	mov	r4, r0
 c00687e:	2800      	cmp	r0, #0
 c006880:	d0c9      	beq.n	c006816 <mbedtls_mpi_inv_mod+0x186>
 c006882:	e7cf      	b.n	c006824 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
 c006884:	2101      	movs	r1, #1
 c006886:	a80d      	add	r0, sp, #52	; 0x34
 c006888:	f7fe ff9e 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c00688c:	e771      	b.n	c006772 <mbedtls_mpi_inv_mod+0xe2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TV, 1 ) );
 c00688e:	2101      	movs	r1, #1
 c006890:	a813      	add	r0, sp, #76	; 0x4c
 c006892:	f7fe ff99 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c006896:	4604      	mov	r4, r0
 c006898:	2800      	cmp	r0, #0
 c00689a:	d1c3      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
            if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
 c00689c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 c00689e:	681b      	ldr	r3, [r3, #0]
 c0068a0:	07d9      	lsls	r1, r3, #31
 c0068a2:	d413      	bmi.n	c0068cc <mbedtls_mpi_inv_mod+0x23c>
 c0068a4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 c0068a6:	681b      	ldr	r3, [r3, #0]
 c0068a8:	07da      	lsls	r2, r3, #31
 c0068aa:	d40f      	bmi.n	c0068cc <mbedtls_mpi_inv_mod+0x23c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V1, 1 ) );
 c0068ac:	2101      	movs	r1, #1
 c0068ae:	a816      	add	r0, sp, #88	; 0x58
 c0068b0:	f7fe ff8a 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c0068b4:	4604      	mov	r4, r0
 c0068b6:	2800      	cmp	r0, #0
 c0068b8:	d1b4      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V2, 1 ) );
 c0068ba:	2101      	movs	r1, #1
 c0068bc:	a819      	add	r0, sp, #100	; 0x64
 c0068be:	f7fe ff83 	bl	c0057c8 <mbedtls_mpi_shift_r>
 c0068c2:	4604      	mov	r4, r0
 c0068c4:	2800      	cmp	r0, #0
 c0068c6:	f43f af5b 	beq.w	c006780 <mbedtls_mpi_inv_mod+0xf0>
 c0068ca:	e7ab      	b.n	c006824 <mbedtls_mpi_inv_mod+0x194>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, &TB ) );
 c0068cc:	a916      	add	r1, sp, #88	; 0x58
 c0068ce:	4608      	mov	r0, r1
 c0068d0:	aa10      	add	r2, sp, #64	; 0x40
 c0068d2:	f7ff f93c 	bl	c005b4e <mbedtls_mpi_add_mpi>
 c0068d6:	4604      	mov	r4, r0
 c0068d8:	2800      	cmp	r0, #0
 c0068da:	d1a3      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &TA ) );
 c0068dc:	a919      	add	r1, sp, #100	; 0x64
 c0068de:	4608      	mov	r0, r1
 c0068e0:	aa04      	add	r2, sp, #16
 c0068e2:	f7ff f956 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c0068e6:	4604      	mov	r4, r0
 c0068e8:	2800      	cmp	r0, #0
 c0068ea:	d0df      	beq.n	c0068ac <mbedtls_mpi_inv_mod+0x21c>
 c0068ec:	e79a      	b.n	c006824 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TV, &TV, &TU ) );
 c0068ee:	a913      	add	r1, sp, #76	; 0x4c
 c0068f0:	4608      	mov	r0, r1
 c0068f2:	aa07      	add	r2, sp, #28
 c0068f4:	f7ff f94d 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c0068f8:	4604      	mov	r4, r0
 c0068fa:	2800      	cmp	r0, #0
 c0068fc:	d192      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, &U1 ) );
 c0068fe:	a916      	add	r1, sp, #88	; 0x58
 c006900:	4608      	mov	r0, r1
 c006902:	aa0a      	add	r2, sp, #40	; 0x28
 c006904:	f7ff f945 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c006908:	4604      	mov	r4, r0
 c00690a:	2800      	cmp	r0, #0
 c00690c:	d18a      	bne.n	c006824 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &U2 ) );
 c00690e:	aa0d      	add	r2, sp, #52	; 0x34
 c006910:	a919      	add	r1, sp, #100	; 0x64
 c006912:	e753      	b.n	c0067bc <mbedtls_mpi_inv_mod+0x12c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, N ) );
 c006914:	a916      	add	r1, sp, #88	; 0x58
 c006916:	462a      	mov	r2, r5
 c006918:	4608      	mov	r0, r1
 c00691a:	f7ff f918 	bl	c005b4e <mbedtls_mpi_add_mpi>
 c00691e:	4604      	mov	r4, r0
 c006920:	2800      	cmp	r0, #0
 c006922:	f43f af56 	beq.w	c0067d2 <mbedtls_mpi_inv_mod+0x142>
 c006926:	e77d      	b.n	c006824 <mbedtls_mpi_inv_mod+0x194>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, N ) );
 c006928:	a916      	add	r1, sp, #88	; 0x58
 c00692a:	462a      	mov	r2, r5
 c00692c:	4608      	mov	r0, r1
 c00692e:	f7ff f930 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c006932:	4604      	mov	r4, r0
 c006934:	2800      	cmp	r0, #0
 c006936:	f43f af53 	beq.w	c0067e0 <mbedtls_mpi_inv_mod+0x150>
 c00693a:	e773      	b.n	c006824 <mbedtls_mpi_inv_mod+0x194>
        ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
 c00693c:	f06f 040d 	mvn.w	r4, #13
 c006940:	e770      	b.n	c006824 <mbedtls_mpi_inv_mod+0x194>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c006942:	f06f 0403 	mvn.w	r4, #3
 c006946:	e788      	b.n	c00685a <mbedtls_mpi_inv_mod+0x1ca>

0c006948 <mbedtls_md_info_from_type>:
    return( NULL );
}

const mbedtls_md_info_t *mbedtls_md_info_from_type( mbedtls_md_type_t md_type )
{
    switch( md_type )
 c006948:	2805      	cmp	r0, #5
 c00694a:	d004      	beq.n	c006956 <mbedtls_md_info_from_type+0xe>
 c00694c:	2806      	cmp	r0, #6
 c00694e:	4803      	ldr	r0, [pc, #12]	; (c00695c <mbedtls_md_info_from_type+0x14>)
 c006950:	bf18      	it	ne
 c006952:	2000      	movne	r0, #0
 c006954:	4770      	bx	lr
        case MBEDTLS_MD_SHA1:
            return( &mbedtls_sha1_info );
#endif
#if defined(MBEDTLS_SHA256_C)
        case MBEDTLS_MD_SHA224:
            return( &mbedtls_sha224_info );
 c006956:	4802      	ldr	r0, [pc, #8]	; (c006960 <mbedtls_md_info_from_type+0x18>)
            return( &mbedtls_sha512_info );
#endif
        default:
            return( NULL );
    }
}
 c006958:	4770      	bx	lr
 c00695a:	bf00      	nop
 c00695c:	0c00a83c 	.word	0x0c00a83c
 c006960:	0c00a80c 	.word	0x0c00a80c

0c006964 <mbedtls_md_init>:

void mbedtls_md_init( mbedtls_md_context_t *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_md_context_t ) );
 c006964:	2300      	movs	r3, #0
 c006966:	6003      	str	r3, [r0, #0]
 c006968:	6043      	str	r3, [r0, #4]
 c00696a:	6083      	str	r3, [r0, #8]
}
 c00696c:	4770      	bx	lr

0c00696e <mbedtls_md_free>:

void mbedtls_md_free( mbedtls_md_context_t *ctx )
{
 c00696e:	b510      	push	{r4, lr}
    if( ctx == NULL || ctx->md_info == NULL )
 c006970:	4604      	mov	r4, r0
 c006972:	b1a8      	cbz	r0, c0069a0 <mbedtls_md_free+0x32>
 c006974:	6803      	ldr	r3, [r0, #0]
 c006976:	b19b      	cbz	r3, c0069a0 <mbedtls_md_free+0x32>
        return;

    if( ctx->md_ctx != NULL )
 c006978:	6840      	ldr	r0, [r0, #4]
 c00697a:	b108      	cbz	r0, c006980 <mbedtls_md_free+0x12>
        ctx->md_info->ctx_free_func( ctx->md_ctx );
 c00697c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 c00697e:	4798      	blx	r3

    if( ctx->hmac_ctx != NULL )
 c006980:	68a0      	ldr	r0, [r4, #8]
 c006982:	b138      	cbz	r0, c006994 <mbedtls_md_free+0x26>
    {
        mbedtls_platform_zeroize( ctx->hmac_ctx,
                                  2 * ctx->md_info->block_size );
 c006984:	6823      	ldr	r3, [r4, #0]
 c006986:	68d9      	ldr	r1, [r3, #12]
        mbedtls_platform_zeroize( ctx->hmac_ctx,
 c006988:	0049      	lsls	r1, r1, #1
 c00698a:	f000 fa23 	bl	c006dd4 <mbedtls_platform_zeroize>
        mbedtls_free( ctx->hmac_ctx );
 c00698e:	68a0      	ldr	r0, [r4, #8]
 c006990:	f000 fa10 	bl	c006db4 <mbedtls_free>
    }

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md_context_t ) );
 c006994:	4620      	mov	r0, r4
}
 c006996:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md_context_t ) );
 c00699a:	210c      	movs	r1, #12
 c00699c:	f000 ba1a 	b.w	c006dd4 <mbedtls_platform_zeroize>
}
 c0069a0:	bd10      	pop	{r4, pc}
	...

0c0069a4 <mbedtls_md_setup>:
    return mbedtls_md_setup( ctx, md_info, 1 );
}
#endif

int mbedtls_md_setup( mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info, int hmac )
{
 c0069a4:	b570      	push	{r4, r5, r6, lr}
 c0069a6:	4604      	mov	r4, r0
 c0069a8:	4616      	mov	r6, r2
    if( md_info == NULL || ctx == NULL )
 c0069aa:	460d      	mov	r5, r1
 c0069ac:	b199      	cbz	r1, c0069d6 <mbedtls_md_setup+0x32>
 c0069ae:	b190      	cbz	r0, c0069d6 <mbedtls_md_setup+0x32>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    if( ( ctx->md_ctx = md_info->ctx_alloc_func() ) == NULL )
 c0069b0:	6a0b      	ldr	r3, [r1, #32]
 c0069b2:	4798      	blx	r3
 c0069b4:	6060      	str	r0, [r4, #4]
 c0069b6:	b148      	cbz	r0, c0069cc <mbedtls_md_setup+0x28>
        return( MBEDTLS_ERR_MD_ALLOC_FAILED );

    if( hmac != 0 )
 c0069b8:	b156      	cbz	r6, c0069d0 <mbedtls_md_setup+0x2c>
    {
        ctx->hmac_ctx = mbedtls_calloc( 2, md_info->block_size );
 c0069ba:	2002      	movs	r0, #2
 c0069bc:	68e9      	ldr	r1, [r5, #12]
 c0069be:	f000 f9f3 	bl	c006da8 <mbedtls_calloc>
 c0069c2:	60a0      	str	r0, [r4, #8]
        if( ctx->hmac_ctx == NULL )
 c0069c4:	b920      	cbnz	r0, c0069d0 <mbedtls_md_setup+0x2c>
        {
            md_info->ctx_free_func( ctx->md_ctx );
 c0069c6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 c0069c8:	6860      	ldr	r0, [r4, #4]
 c0069ca:	4798      	blx	r3
        return( MBEDTLS_ERR_MD_ALLOC_FAILED );
 c0069cc:	4803      	ldr	r0, [pc, #12]	; (c0069dc <mbedtls_md_setup+0x38>)
 c0069ce:	e001      	b.n	c0069d4 <mbedtls_md_setup+0x30>
        }
    }

    ctx->md_info = md_info;

    return( 0 );
 c0069d0:	2000      	movs	r0, #0
    ctx->md_info = md_info;
 c0069d2:	6025      	str	r5, [r4, #0]
}
 c0069d4:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c0069d6:	4802      	ldr	r0, [pc, #8]	; (c0069e0 <mbedtls_md_setup+0x3c>)
 c0069d8:	e7fc      	b.n	c0069d4 <mbedtls_md_setup+0x30>
 c0069da:	bf00      	nop
 c0069dc:	ffffae80 	.word	0xffffae80
 c0069e0:	ffffaf00 	.word	0xffffaf00

0c0069e4 <mbedtls_md_starts>:

int mbedtls_md_starts( mbedtls_md_context_t *ctx )
{
    if( ctx == NULL || ctx->md_info == NULL )
 c0069e4:	b120      	cbz	r0, c0069f0 <mbedtls_md_starts+0xc>
 c0069e6:	6803      	ldr	r3, [r0, #0]
 c0069e8:	b113      	cbz	r3, c0069f0 <mbedtls_md_starts+0xc>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( ctx->md_info->starts_func( ctx->md_ctx ) );
 c0069ea:	691b      	ldr	r3, [r3, #16]
 c0069ec:	6840      	ldr	r0, [r0, #4]
 c0069ee:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c0069f0:	4800      	ldr	r0, [pc, #0]	; (c0069f4 <mbedtls_md_starts+0x10>)
}
 c0069f2:	4770      	bx	lr
 c0069f4:	ffffaf00 	.word	0xffffaf00

0c0069f8 <mbedtls_md_update>:

int mbedtls_md_update( mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen )
{
    if( ctx == NULL || ctx->md_info == NULL )
 c0069f8:	b120      	cbz	r0, c006a04 <mbedtls_md_update+0xc>
 c0069fa:	6803      	ldr	r3, [r0, #0]
 c0069fc:	b113      	cbz	r3, c006a04 <mbedtls_md_update+0xc>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( ctx->md_info->update_func( ctx->md_ctx, input, ilen ) );
 c0069fe:	695b      	ldr	r3, [r3, #20]
 c006a00:	6840      	ldr	r0, [r0, #4]
 c006a02:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c006a04:	4800      	ldr	r0, [pc, #0]	; (c006a08 <mbedtls_md_update+0x10>)
}
 c006a06:	4770      	bx	lr
 c006a08:	ffffaf00 	.word	0xffffaf00

0c006a0c <mbedtls_md_finish>:

int mbedtls_md_finish( mbedtls_md_context_t *ctx, unsigned char *output )
{
    if( ctx == NULL || ctx->md_info == NULL )
 c006a0c:	b120      	cbz	r0, c006a18 <mbedtls_md_finish+0xc>
 c006a0e:	6803      	ldr	r3, [r0, #0]
 c006a10:	b113      	cbz	r3, c006a18 <mbedtls_md_finish+0xc>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( ctx->md_info->finish_func( ctx->md_ctx, output ) );
 c006a12:	699b      	ldr	r3, [r3, #24]
 c006a14:	6840      	ldr	r0, [r0, #4]
 c006a16:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c006a18:	4800      	ldr	r0, [pc, #0]	; (c006a1c <mbedtls_md_finish+0x10>)
}
 c006a1a:	4770      	bx	lr
 c006a1c:	ffffaf00 	.word	0xffffaf00

0c006a20 <mbedtls_md>:

int mbedtls_md( const mbedtls_md_info_t *md_info, const unsigned char *input, size_t ilen,
            unsigned char *output )
{
 c006a20:	b410      	push	{r4}
 c006a22:	4604      	mov	r4, r0
 c006a24:	4608      	mov	r0, r1
 c006a26:	4611      	mov	r1, r2
 c006a28:	461a      	mov	r2, r3
    if( md_info == NULL )
 c006a2a:	b11c      	cbz	r4, c006a34 <mbedtls_md+0x14>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( md_info->digest_func( input, ilen, output ) );
 c006a2c:	69e3      	ldr	r3, [r4, #28]
}
 c006a2e:	f85d 4b04 	ldr.w	r4, [sp], #4
    return( md_info->digest_func( input, ilen, output ) );
 c006a32:	4718      	bx	r3
}
 c006a34:	4801      	ldr	r0, [pc, #4]	; (c006a3c <mbedtls_md+0x1c>)
 c006a36:	f85d 4b04 	ldr.w	r4, [sp], #4
 c006a3a:	4770      	bx	lr
 c006a3c:	ffffaf00 	.word	0xffffaf00

0c006a40 <mbedtls_md_get_size>:
    return( ctx->md_info->process_func( ctx->md_ctx, data ) );
}

unsigned char mbedtls_md_get_size( const mbedtls_md_info_t *md_info )
{
    if( md_info == NULL )
 c006a40:	b100      	cbz	r0, c006a44 <mbedtls_md_get_size+0x4>
        return( 0 );

    return md_info->size;
 c006a42:	7a00      	ldrb	r0, [r0, #8]
}
 c006a44:	4770      	bx	lr

0c006a46 <sha224_process_wrap>:
                    (const mbedtls_sha256_context *) src );
}

static int sha224_process_wrap( void *ctx, const unsigned char *data )
{
    return( mbedtls_internal_sha256_process( (mbedtls_sha256_context *) ctx,
 c006a46:	f7fb be59 	b.w	c0026fc <mbedtls_internal_sha256_process>

0c006a4a <sha224_clone_wrap>:
    mbedtls_sha256_clone( (mbedtls_sha256_context *) dst,
 c006a4a:	f7fb be3d 	b.w	c0026c8 <mbedtls_sha256_clone>

0c006a4e <sha224_ctx_free>:
{
 c006a4e:	b510      	push	{r4, lr}
 c006a50:	4604      	mov	r4, r0
    mbedtls_sha256_free( (mbedtls_sha256_context *) ctx );
 c006a52:	f7fb fe2f 	bl	c0026b4 <mbedtls_sha256_free>
    mbedtls_free( ctx );
 c006a56:	4620      	mov	r0, r4
}
 c006a58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 c006a5c:	f000 b9aa 	b.w	c006db4 <mbedtls_free>

0c006a60 <sha224_ctx_alloc>:
{
 c006a60:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_sha256_context ) );
 c006a62:	f44f 71b8 	mov.w	r1, #368	; 0x170
 c006a66:	2001      	movs	r0, #1
 c006a68:	f000 f99e 	bl	c006da8 <mbedtls_calloc>
    if( ctx != NULL )
 c006a6c:	4604      	mov	r4, r0
 c006a6e:	b108      	cbz	r0, c006a74 <sha224_ctx_alloc+0x14>
        mbedtls_sha256_init( (mbedtls_sha256_context *) ctx );
 c006a70:	f7fb fe08 	bl	c002684 <mbedtls_sha256_init>
}
 c006a74:	4620      	mov	r0, r4
 c006a76:	bd10      	pop	{r4, pc}

0c006a78 <sha224_wrap>:
    return( mbedtls_sha256_ret( input, ilen, output, 1 ) );
 c006a78:	2301      	movs	r3, #1
 c006a7a:	f000 bf99 	b.w	c0079b0 <mbedtls_sha256_ret>

0c006a7e <sha256_wrap>:
}

static int sha256_wrap( const unsigned char *input, size_t ilen,
                        unsigned char *output )
{
    return( mbedtls_sha256_ret( input, ilen, output, 0 ) );
 c006a7e:	2300      	movs	r3, #0
 c006a80:	f000 bf96 	b.w	c0079b0 <mbedtls_sha256_ret>

0c006a84 <sha224_finish_wrap>:
    return( mbedtls_sha256_finish_ret( (mbedtls_sha256_context *) ctx,
 c006a84:	f7fb be9a 	b.w	c0027bc <mbedtls_sha256_finish_ret>

0c006a88 <sha224_update_wrap>:
    return( mbedtls_sha256_update_ret( (mbedtls_sha256_context *) ctx,
 c006a88:	f7fb be48 	b.w	c00271c <mbedtls_sha256_update_ret>

0c006a8c <sha224_starts_wrap>:
    return( mbedtls_sha256_starts_ret( (mbedtls_sha256_context *) ctx, 1 ) );
 c006a8c:	2101      	movs	r1, #1
 c006a8e:	f7fb be21 	b.w	c0026d4 <mbedtls_sha256_starts_ret>

0c006a92 <sha256_starts_wrap>:
    return( mbedtls_sha256_starts_ret( (mbedtls_sha256_context *) ctx, 0 ) );
 c006a92:	2100      	movs	r1, #0
 c006a94:	f7fb be1e 	b.w	c0026d4 <mbedtls_sha256_starts_ret>

0c006a98 <verify_header>:
}
#endif /* MBEDTLS_MEMORY_DEBUG */

static int verify_header( memory_header *hdr )
{
    if( hdr->magic1 != MAGIC1 )
 c006a98:	6802      	ldr	r2, [r0, #0]
 c006a9a:	4b0e      	ldr	r3, [pc, #56]	; (c006ad4 <verify_header+0x3c>)
 c006a9c:	429a      	cmp	r2, r3
 c006a9e:	d115      	bne.n	c006acc <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->magic2 != MAGIC2 )
 c006aa0:	69c2      	ldr	r2, [r0, #28]
 c006aa2:	f1a3 2310 	sub.w	r3, r3, #268439552	; 0x10001000
 c006aa6:	f1a3 13ef 	sub.w	r3, r3, #15663343	; 0xef00ef
 c006aaa:	429a      	cmp	r2, r3
 c006aac:	d10e      	bne.n	c006acc <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->alloc > 1 )
 c006aae:	6883      	ldr	r3, [r0, #8]
 c006ab0:	2b01      	cmp	r3, #1
 c006ab2:	d80b      	bhi.n	c006acc <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: alloc has illegal value\n" );
#endif
        return( 1 );
    }

    if( hdr->prev != NULL && hdr->prev == hdr->next )
 c006ab4:	68c3      	ldr	r3, [r0, #12]
 c006ab6:	b113      	cbz	r3, c006abe <verify_header+0x26>
 c006ab8:	6902      	ldr	r2, [r0, #16]
 c006aba:	4293      	cmp	r3, r2
 c006abc:	d006      	beq.n	c006acc <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: prev == next\n" );
#endif
        return( 1 );
    }

    if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
 c006abe:	6943      	ldr	r3, [r0, #20]
 c006ac0:	b133      	cbz	r3, c006ad0 <verify_header+0x38>
 c006ac2:	6980      	ldr	r0, [r0, #24]
 c006ac4:	1ac3      	subs	r3, r0, r3
 c006ac6:	4258      	negs	r0, r3
 c006ac8:	4158      	adcs	r0, r3
 c006aca:	4770      	bx	lr
        return( 1 );
 c006acc:	2001      	movs	r0, #1
 c006ace:	4770      	bx	lr
        mbedtls_fprintf( stderr, "FATAL: prev_free == next_free\n" );
#endif
        return( 1 );
    }

    return( 0 );
 c006ad0:	4618      	mov	r0, r3
}
 c006ad2:	4770      	bx	lr
 c006ad4:	ff00aa55 	.word	0xff00aa55

0c006ad8 <verify_chain>:

static int verify_chain( void )
{
 c006ad8:	b538      	push	{r3, r4, r5, lr}
    memory_header *prv = heap.first, *cur;
 c006ada:	4b0d      	ldr	r3, [pc, #52]	; (c006b10 <verify_chain+0x38>)
 c006adc:	689d      	ldr	r5, [r3, #8]

    if( prv == NULL || verify_header( prv ) != 0 )
 c006ade:	b1a5      	cbz	r5, c006b0a <verify_chain+0x32>
 c006ae0:	4628      	mov	r0, r5
 c006ae2:	f7ff ffd9 	bl	c006a98 <verify_header>
 c006ae6:	4601      	mov	r1, r0
 c006ae8:	b978      	cbnz	r0, c006b0a <verify_chain+0x32>
                                  "failed\n" );
#endif
        return( 1 );
    }

    if( heap.first->prev != NULL )
 c006aea:	68eb      	ldr	r3, [r5, #12]
 c006aec:	b96b      	cbnz	r3, c006b0a <verify_chain+0x32>
                                  "first->prev != NULL\n" );
#endif
        return( 1 );
    }

    cur = heap.first->next;
 c006aee:	692c      	ldr	r4, [r5, #16]

    while( cur != NULL )
 c006af0:	b90c      	cbnz	r4, c006af6 <verify_chain+0x1e>
        prv = cur;
        cur = cur->next;
    }

    return( 0 );
}
 c006af2:	4608      	mov	r0, r1
 c006af4:	bd38      	pop	{r3, r4, r5, pc}
        if( verify_header( cur ) != 0 )
 c006af6:	4620      	mov	r0, r4
 c006af8:	f7ff ffce 	bl	c006a98 <verify_header>
 c006afc:	b928      	cbnz	r0, c006b0a <verify_chain+0x32>
        if( cur->prev != prv )
 c006afe:	68e3      	ldr	r3, [r4, #12]
 c006b00:	42ab      	cmp	r3, r5
 c006b02:	d102      	bne.n	c006b0a <verify_chain+0x32>
        cur = cur->next;
 c006b04:	4625      	mov	r5, r4
 c006b06:	6924      	ldr	r4, [r4, #16]
 c006b08:	e7f2      	b.n	c006af0 <verify_chain+0x18>
        return( 1 );
 c006b0a:	2101      	movs	r1, #1
 c006b0c:	e7f1      	b.n	c006af2 <verify_chain+0x1a>
 c006b0e:	bf00      	nop
 c006b10:	300324a0 	.word	0x300324a0

0c006b14 <buffer_alloc_calloc>:

static void *buffer_alloc_calloc( size_t n, size_t size )
{
 c006b14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if defined(MBEDTLS_MEMORY_BACKTRACE)
    void *trace_buffer[MAX_BT];
    size_t trace_cnt;
#endif

    if( heap.buf == NULL || heap.first == NULL )
 c006b18:	4d40      	ldr	r5, [pc, #256]	; (c006c1c <buffer_alloc_calloc+0x108>)
 c006b1a:	682c      	ldr	r4, [r5, #0]
 c006b1c:	b1d4      	cbz	r4, c006b54 <buffer_alloc_calloc+0x40>
 c006b1e:	68ac      	ldr	r4, [r5, #8]
 c006b20:	b1c4      	cbz	r4, c006b54 <buffer_alloc_calloc+0x40>
        return( NULL );

    original_len = len = n * size;

    if( n == 0 || size == 0 || len / n != size )
 c006b22:	2800      	cmp	r0, #0
 c006b24:	d04d      	beq.n	c006bc2 <buffer_alloc_calloc+0xae>
 c006b26:	2900      	cmp	r1, #0
 c006b28:	d04b      	beq.n	c006bc2 <buffer_alloc_calloc+0xae>
    original_len = len = n * size;
 c006b2a:	fb01 f600 	mul.w	r6, r1, r0
    if( n == 0 || size == 0 || len / n != size )
 c006b2e:	fbb6 f0f0 	udiv	r0, r6, r0
 c006b32:	4288      	cmp	r0, r1
 c006b34:	d145      	bne.n	c006bc2 <buffer_alloc_calloc+0xae>
        return( NULL );
    else if( len > (size_t)-MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c006b36:	1d30      	adds	r0, r6, #4
 c006b38:	d843      	bhi.n	c006bc2 <buffer_alloc_calloc+0xae>
        return( NULL );

    if( len % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c006b3a:	07b1      	lsls	r1, r6, #30
 c006b3c:	d00d      	beq.n	c006b5a <buffer_alloc_calloc+0x46>
    {
        len -= len % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c006b3e:	f026 0703 	bic.w	r7, r6, #3
        len += MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c006b42:	3704      	adds	r7, #4
    memory_header *new, *cur = heap.first_free;
 c006b44:	68ec      	ldr	r4, [r5, #12]
 c006b46:	e003      	b.n	c006b50 <buffer_alloc_calloc+0x3c>

    // Find block that fits
    //
    while( cur != NULL )
    {
        if( cur->size >= len )
 c006b48:	6863      	ldr	r3, [r4, #4]
 c006b4a:	42bb      	cmp	r3, r7
 c006b4c:	d23b      	bcs.n	c006bc6 <buffer_alloc_calloc+0xb2>
            break;

        cur = cur->next_free;
 c006b4e:	69a4      	ldr	r4, [r4, #24]
    while( cur != NULL )
 c006b50:	2c00      	cmp	r4, #0
 c006b52:	d1f9      	bne.n	c006b48 <buffer_alloc_calloc+0x34>

    ret = (unsigned char *) cur + sizeof( memory_header );
    memset( ret, 0, original_len );

    return( ret );
}
 c006b54:	4620      	mov	r0, r4
 c006b56:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c006b5a:	4637      	mov	r7, r6
 c006b5c:	e7f2      	b.n	c006b44 <buffer_alloc_calloc+0x30>
            heap.first_free = cur->next_free;
 c006b5e:	60e8      	str	r0, [r5, #12]
 c006b60:	e044      	b.n	c006bec <buffer_alloc_calloc+0xd8>
    p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
 c006b62:	f107 0c20 	add.w	ip, r7, #32
 c006b66:	eb04 030c 	add.w	r3, r4, ip
    new->size = cur->size - len - sizeof(memory_header);
 c006b6a:	3920      	subs	r1, #32
 c006b6c:	6059      	str	r1, [r3, #4]
    new->alloc = 0;
 c006b6e:	2100      	movs	r1, #0
    new->magic1 = MAGIC1;
 c006b70:	f8df e0b0 	ldr.w	lr, [pc, #176]	; c006c24 <buffer_alloc_calloc+0x110>
    new->prev = cur;
 c006b74:	e9c3 1402 	strd	r1, r4, [r3, #8]
    new->next = cur->next;
 c006b78:	6921      	ldr	r1, [r4, #16]
 c006b7a:	6119      	str	r1, [r3, #16]
    new->magic1 = MAGIC1;
 c006b7c:	f844 e00c 	str.w	lr, [r4, ip]
    new->magic2 = MAGIC2;
 c006b80:	f8df c0a4 	ldr.w	ip, [pc, #164]	; c006c28 <buffer_alloc_calloc+0x114>
 c006b84:	f8c3 c01c 	str.w	ip, [r3, #28]
    if( new->next != NULL )
 c006b88:	b101      	cbz	r1, c006b8c <buffer_alloc_calloc+0x78>
        new->next->prev = new;
 c006b8a:	60cb      	str	r3, [r1, #12]
    new->next_free = cur->next_free;
 c006b8c:	e9c3 2005 	strd	r2, r0, [r3, #20]
    if( new->prev_free != NULL )
 c006b90:	b1aa      	cbz	r2, c006bbe <buffer_alloc_calloc+0xaa>
        new->prev_free->next_free = new;
 c006b92:	6193      	str	r3, [r2, #24]
    if( new->next_free != NULL )
 c006b94:	699a      	ldr	r2, [r3, #24]
 c006b96:	b102      	cbz	r2, c006b9a <buffer_alloc_calloc+0x86>
        new->next_free->prev_free = new;
 c006b98:	6153      	str	r3, [r2, #20]
    cur->next = new;
 c006b9a:	6123      	str	r3, [r4, #16]
    cur->prev_free = NULL;
 c006b9c:	2300      	movs	r3, #0
    cur->alloc = 1;
 c006b9e:	f04f 0901 	mov.w	r9, #1
    cur->next_free = NULL;
 c006ba2:	e9c4 3305 	strd	r3, r3, [r4, #20]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
 c006ba6:	692b      	ldr	r3, [r5, #16]
    cur->size = len;
 c006ba8:	e9c4 7901 	strd	r7, r9, [r4, #4]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
 c006bac:	07db      	lsls	r3, r3, #31
 c006bae:	d52d      	bpl.n	c006c0c <buffer_alloc_calloc+0xf8>
 c006bb0:	f7ff ff92 	bl	c006ad8 <verify_chain>
 c006bb4:	b350      	cbz	r0, c006c0c <buffer_alloc_calloc+0xf8>
        mbedtls_exit( 1 );
 c006bb6:	4b1a      	ldr	r3, [pc, #104]	; (c006c20 <buffer_alloc_calloc+0x10c>)
 c006bb8:	4648      	mov	r0, r9
 c006bba:	681b      	ldr	r3, [r3, #0]
 c006bbc:	e025      	b.n	c006c0a <buffer_alloc_calloc+0xf6>
        heap.first_free = new;
 c006bbe:	60eb      	str	r3, [r5, #12]
 c006bc0:	e7e8      	b.n	c006b94 <buffer_alloc_calloc+0x80>
        return( NULL );
 c006bc2:	2400      	movs	r4, #0
 c006bc4:	e7c6      	b.n	c006b54 <buffer_alloc_calloc+0x40>
    if( cur->alloc != 0 )
 c006bc6:	68a3      	ldr	r3, [r4, #8]
 c006bc8:	b11b      	cbz	r3, c006bd2 <buffer_alloc_calloc+0xbe>
        mbedtls_exit( 1 );
 c006bca:	4b15      	ldr	r3, [pc, #84]	; (c006c20 <buffer_alloc_calloc+0x10c>)
 c006bcc:	2001      	movs	r0, #1
 c006bce:	681b      	ldr	r3, [r3, #0]
 c006bd0:	4798      	blx	r3
    if( cur->size - len < sizeof(memory_header) +
 c006bd2:	e9d4 2005 	ldrd	r2, r0, [r4, #20]
 c006bd6:	6861      	ldr	r1, [r4, #4]
 c006bd8:	f104 0820 	add.w	r8, r4, #32
 c006bdc:	1bc9      	subs	r1, r1, r7
 c006bde:	2923      	cmp	r1, #35	; 0x23
 c006be0:	d8bf      	bhi.n	c006b62 <buffer_alloc_calloc+0x4e>
        cur->alloc = 1;
 c006be2:	2301      	movs	r3, #1
 c006be4:	60a3      	str	r3, [r4, #8]
        if( cur->prev_free != NULL )
 c006be6:	2a00      	cmp	r2, #0
 c006be8:	d0b9      	beq.n	c006b5e <buffer_alloc_calloc+0x4a>
            cur->prev_free->next_free = cur->next_free;
 c006bea:	6190      	str	r0, [r2, #24]
        if( cur->next_free != NULL )
 c006bec:	69a3      	ldr	r3, [r4, #24]
 c006bee:	b103      	cbz	r3, c006bf2 <buffer_alloc_calloc+0xde>
            cur->next_free->prev_free = cur->prev_free;
 c006bf0:	615a      	str	r2, [r3, #20]
        cur->prev_free = NULL;
 c006bf2:	2300      	movs	r3, #0
        cur->next_free = NULL;
 c006bf4:	e9c4 3305 	strd	r3, r3, [r4, #20]
        if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
 c006bf8:	692b      	ldr	r3, [r5, #16]
 c006bfa:	07da      	lsls	r2, r3, #31
 c006bfc:	d506      	bpl.n	c006c0c <buffer_alloc_calloc+0xf8>
 c006bfe:	f7ff ff6b 	bl	c006ad8 <verify_chain>
 c006c02:	b118      	cbz	r0, c006c0c <buffer_alloc_calloc+0xf8>
            mbedtls_exit( 1 );
 c006c04:	2001      	movs	r0, #1
 c006c06:	4b06      	ldr	r3, [pc, #24]	; (c006c20 <buffer_alloc_calloc+0x10c>)
 c006c08:	681b      	ldr	r3, [r3, #0]
        mbedtls_exit( 1 );
 c006c0a:	4798      	blx	r3
    memset( ret, 0, original_len );
 c006c0c:	4632      	mov	r2, r6
 c006c0e:	2100      	movs	r1, #0
 c006c10:	4640      	mov	r0, r8
    ret = (unsigned char *) cur + sizeof( memory_header );
 c006c12:	4644      	mov	r4, r8
    memset( ret, 0, original_len );
 c006c14:	f001 ffc7 	bl	c008ba6 <memset>
    return( ret );
 c006c18:	e79c      	b.n	c006b54 <buffer_alloc_calloc+0x40>
 c006c1a:	bf00      	nop
 c006c1c:	300324a0 	.word	0x300324a0
 c006c20:	30030080 	.word	0x30030080
 c006c24:	ff00aa55 	.word	0xff00aa55
 c006c28:	ee119966 	.word	0xee119966

0c006c2c <buffer_alloc_free>:

static void buffer_alloc_free( void *ptr )
{
 c006c2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    memory_header *hdr, *old = NULL;
    unsigned char *p = (unsigned char *) ptr;

    if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
 c006c30:	4605      	mov	r5, r0
 c006c32:	2800      	cmp	r0, #0
 c006c34:	d07c      	beq.n	c006d30 <buffer_alloc_free+0x104>
 c006c36:	4e3f      	ldr	r6, [pc, #252]	; (c006d34 <buffer_alloc_free+0x108>)
 c006c38:	6833      	ldr	r3, [r6, #0]
 c006c3a:	2b00      	cmp	r3, #0
 c006c3c:	d078      	beq.n	c006d30 <buffer_alloc_free+0x104>
 c006c3e:	68b2      	ldr	r2, [r6, #8]
 c006c40:	2a00      	cmp	r2, #0
 c006c42:	d075      	beq.n	c006d30 <buffer_alloc_free+0x104>
        return;

    if( p < heap.buf || p >= heap.buf + heap.len )
 c006c44:	4283      	cmp	r3, r0
 c006c46:	d803      	bhi.n	c006c50 <buffer_alloc_free+0x24>
 c006c48:	6872      	ldr	r2, [r6, #4]
 c006c4a:	4413      	add	r3, r2
 c006c4c:	4298      	cmp	r0, r3
 c006c4e:	d303      	bcc.n	c006c58 <buffer_alloc_free+0x2c>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        mbedtls_fprintf( stderr, "FATAL: mbedtls_free() outside of managed "
                                  "space\n" );
#endif
        mbedtls_exit( 1 );
 c006c50:	4b39      	ldr	r3, [pc, #228]	; (c006d38 <buffer_alloc_free+0x10c>)
 c006c52:	2001      	movs	r0, #1
 c006c54:	681b      	ldr	r3, [r3, #0]
 c006c56:	4798      	blx	r3
    }

    p -= sizeof(memory_header);
 c006c58:	f1a5 0420 	sub.w	r4, r5, #32
    hdr = (memory_header *) p;

    if( verify_header( hdr ) != 0 )
 c006c5c:	4620      	mov	r0, r4
 c006c5e:	f7ff ff1b 	bl	c006a98 <verify_header>
 c006c62:	b118      	cbz	r0, c006c6c <buffer_alloc_free+0x40>
        mbedtls_exit( 1 );
 c006c64:	4b34      	ldr	r3, [pc, #208]	; (c006d38 <buffer_alloc_free+0x10c>)
 c006c66:	2001      	movs	r0, #1
 c006c68:	681b      	ldr	r3, [r3, #0]
 c006c6a:	4798      	blx	r3

    if( hdr->alloc != 1 )
 c006c6c:	f855 3c18 	ldr.w	r3, [r5, #-24]
 c006c70:	2b01      	cmp	r3, #1
 c006c72:	d003      	beq.n	c006c7c <buffer_alloc_free+0x50>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        mbedtls_fprintf( stderr, "FATAL: mbedtls_free() on unallocated "
                                  "data\n" );
#endif
        mbedtls_exit( 1 );
 c006c74:	4b30      	ldr	r3, [pc, #192]	; (c006d38 <buffer_alloc_free+0x10c>)
 c006c76:	2001      	movs	r0, #1
 c006c78:	681b      	ldr	r3, [r3, #0]
 c006c7a:	4798      	blx	r3
    }

    hdr->alloc = 0;
 c006c7c:	2300      	movs	r3, #0
    hdr->trace_count = 0;
#endif

    // Regroup with block before
    //
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
 c006c7e:	f855 7c14 	ldr.w	r7, [r5, #-20]
    hdr->alloc = 0;
 c006c82:	f845 3c18 	str.w	r3, [r5, #-24]
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
 c006c86:	b1af      	cbz	r7, c006cb4 <buffer_alloc_free+0x88>
 c006c88:	68ba      	ldr	r2, [r7, #8]
 c006c8a:	b992      	cbnz	r2, c006cb2 <buffer_alloc_free+0x86>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->prev->size += sizeof(memory_header) + hdr->size;
 c006c8c:	f855 3c1c 	ldr.w	r3, [r5, #-28]
 c006c90:	f103 0220 	add.w	r2, r3, #32
 c006c94:	687b      	ldr	r3, [r7, #4]
 c006c96:	4413      	add	r3, r2
 c006c98:	607b      	str	r3, [r7, #4]
        hdr->prev->next = hdr->next;
 c006c9a:	f855 3c10 	ldr.w	r3, [r5, #-16]
 c006c9e:	613b      	str	r3, [r7, #16]
        old = hdr;
        hdr = hdr->prev;

        if( hdr->next != NULL )
 c006ca0:	b103      	cbz	r3, c006ca4 <buffer_alloc_free+0x78>
            hdr->next->prev = hdr;
 c006ca2:	60df      	str	r7, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
 c006ca4:	4620      	mov	r0, r4
 c006ca6:	2220      	movs	r2, #32
 c006ca8:	2100      	movs	r1, #0
 c006caa:	f001 ff7c 	bl	c008ba6 <memset>
 c006cae:	463c      	mov	r4, r7
 c006cb0:	4603      	mov	r3, r0
    memory_header *hdr, *old = NULL;
 c006cb2:	461f      	mov	r7, r3
    }

    // Regroup with block after
    //
    if( hdr->next != NULL && hdr->next->alloc == 0 )
 c006cb4:	6920      	ldr	r0, [r4, #16]
 c006cb6:	2800      	cmp	r0, #0
 c006cb8:	d032      	beq.n	c006d20 <buffer_alloc_free+0xf4>
 c006cba:	6883      	ldr	r3, [r0, #8]
 c006cbc:	2b00      	cmp	r3, #0
 c006cbe:	d12f      	bne.n	c006d20 <buffer_alloc_free+0xf4>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->size += sizeof(memory_header) + hdr->next->size;
 c006cc0:	6863      	ldr	r3, [r4, #4]
 c006cc2:	6842      	ldr	r2, [r0, #4]
 c006cc4:	3320      	adds	r3, #32
 c006cc6:	4413      	add	r3, r2
 c006cc8:	6063      	str	r3, [r4, #4]
        old = hdr->next;
        hdr->next = hdr->next->next;
 c006cca:	6903      	ldr	r3, [r0, #16]
 c006ccc:	e9d4 2105 	ldrd	r2, r1, [r4, #20]
 c006cd0:	6123      	str	r3, [r4, #16]

        if( hdr->prev_free != NULL || hdr->next_free != NULL )
 c006cd2:	b9da      	cbnz	r2, c006d0c <buffer_alloc_free+0xe0>
 c006cd4:	bb01      	cbnz	r1, c006d18 <buffer_alloc_free+0xec>

            if( hdr->next_free != NULL )
                hdr->next_free->prev_free = hdr->prev_free;
        }

        hdr->prev_free = old->prev_free;
 c006cd6:	6942      	ldr	r2, [r0, #20]
        hdr->next_free = old->next_free;
 c006cd8:	6981      	ldr	r1, [r0, #24]
        hdr->prev_free = old->prev_free;
 c006cda:	6162      	str	r2, [r4, #20]
        hdr->next_free = old->next_free;
 c006cdc:	61a1      	str	r1, [r4, #24]

        if( hdr->prev_free != NULL )
 c006cde:	b1ea      	cbz	r2, c006d1c <buffer_alloc_free+0xf0>
            hdr->prev_free->next_free = hdr;
 c006ce0:	6194      	str	r4, [r2, #24]
        else
            heap.first_free = hdr;

        if( hdr->next_free != NULL )
 c006ce2:	69a2      	ldr	r2, [r4, #24]
 c006ce4:	b102      	cbz	r2, c006ce8 <buffer_alloc_free+0xbc>
            hdr->next_free->prev_free = hdr;
 c006ce6:	6154      	str	r4, [r2, #20]

        if( hdr->next != NULL )
 c006ce8:	b103      	cbz	r3, c006cec <buffer_alloc_free+0xc0>
            hdr->next->prev = hdr;
 c006cea:	60dc      	str	r4, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
 c006cec:	2220      	movs	r2, #32
 c006cee:	2100      	movs	r1, #0
 c006cf0:	f001 ff59 	bl	c008ba6 <memset>
        if( heap.first_free != NULL )
            heap.first_free->prev_free = hdr;
        heap.first_free = hdr;
    }

    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
 c006cf4:	6933      	ldr	r3, [r6, #16]
 c006cf6:	079b      	lsls	r3, r3, #30
 c006cf8:	d51a      	bpl.n	c006d30 <buffer_alloc_free+0x104>
 c006cfa:	f7ff feed 	bl	c006ad8 <verify_chain>
 c006cfe:	b1b8      	cbz	r0, c006d30 <buffer_alloc_free+0x104>
        mbedtls_exit( 1 );
}
 c006d00:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        mbedtls_exit( 1 );
 c006d04:	4b0c      	ldr	r3, [pc, #48]	; (c006d38 <buffer_alloc_free+0x10c>)
 c006d06:	2001      	movs	r0, #1
 c006d08:	681b      	ldr	r3, [r3, #0]
 c006d0a:	4718      	bx	r3
                hdr->prev_free->next_free = hdr->next_free;
 c006d0c:	6191      	str	r1, [r2, #24]
            if( hdr->next_free != NULL )
 c006d0e:	69a1      	ldr	r1, [r4, #24]
 c006d10:	2900      	cmp	r1, #0
 c006d12:	d0e0      	beq.n	c006cd6 <buffer_alloc_free+0xaa>
                hdr->next_free->prev_free = hdr->prev_free;
 c006d14:	614a      	str	r2, [r1, #20]
 c006d16:	e7de      	b.n	c006cd6 <buffer_alloc_free+0xaa>
                heap.first_free = hdr->next_free;
 c006d18:	60f1      	str	r1, [r6, #12]
 c006d1a:	e7f8      	b.n	c006d0e <buffer_alloc_free+0xe2>
            heap.first_free = hdr;
 c006d1c:	60f4      	str	r4, [r6, #12]
 c006d1e:	e7e0      	b.n	c006ce2 <buffer_alloc_free+0xb6>
    if( old == NULL )
 c006d20:	2f00      	cmp	r7, #0
 c006d22:	d1e7      	bne.n	c006cf4 <buffer_alloc_free+0xc8>
        hdr->next_free = heap.first_free;
 c006d24:	68f3      	ldr	r3, [r6, #12]
 c006d26:	61a3      	str	r3, [r4, #24]
        if( heap.first_free != NULL )
 c006d28:	b103      	cbz	r3, c006d2c <buffer_alloc_free+0x100>
            heap.first_free->prev_free = hdr;
 c006d2a:	615c      	str	r4, [r3, #20]
        heap.first_free = hdr;
 c006d2c:	60f4      	str	r4, [r6, #12]
 c006d2e:	e7e1      	b.n	c006cf4 <buffer_alloc_free+0xc8>
}
 c006d30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c006d34:	300324a0 	.word	0x300324a0
 c006d38:	30030080 	.word	0x30030080

0c006d3c <mbedtls_memory_buffer_alloc_init>:
    (void) mbedtls_mutex_unlock( &heap.mutex );
}
#endif /* MBEDTLS_THREADING_C */

void mbedtls_memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
 c006d3c:	b538      	push	{r3, r4, r5, lr}
 c006d3e:	460d      	mov	r5, r1
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
 c006d40:	2214      	movs	r2, #20
 c006d42:	2100      	movs	r1, #0
{
 c006d44:	4604      	mov	r4, r0
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
 c006d46:	4812      	ldr	r0, [pc, #72]	; (c006d90 <mbedtls_memory_buffer_alloc_init+0x54>)
 c006d48:	f001 ff2d 	bl	c008ba6 <memset>
#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( &heap.mutex );
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc, buffer_alloc_free );
 c006d4c:	4911      	ldr	r1, [pc, #68]	; (c006d94 <mbedtls_memory_buffer_alloc_init+0x58>)
 c006d4e:	4812      	ldr	r0, [pc, #72]	; (c006d98 <mbedtls_memory_buffer_alloc_init+0x5c>)
 c006d50:	f000 f836 	bl	c006dc0 <mbedtls_platform_set_calloc_free>
#endif

    if( len < sizeof( memory_header ) + MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c006d54:	2d23      	cmp	r5, #35	; 0x23
 c006d56:	d91a      	bls.n	c006d8e <mbedtls_memory_buffer_alloc_init+0x52>
        return;
    else if( (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c006d58:	f014 0303 	ands.w	r3, r4, #3
    {
        /* Adjust len first since buf is used in the computation */
        len -= MBEDTLS_MEMORY_ALIGN_MULTIPLE
 c006d5c:	bf1f      	itttt	ne
 c006d5e:	3d04      	subne	r5, #4
 c006d60:	18ed      	addne	r5, r5, r3
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c006d62:	f1c3 0304 	rsbne	r3, r3, #4
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
 c006d66:	18e4      	addne	r4, r4, r3
    }

    memset( buf, 0, len );
 c006d68:	462a      	mov	r2, r5
 c006d6a:	2100      	movs	r1, #0
 c006d6c:	4620      	mov	r0, r4
 c006d6e:	f001 ff1a 	bl	c008ba6 <memset>

    heap.buf = buf;
 c006d72:	4b07      	ldr	r3, [pc, #28]	; (c006d90 <mbedtls_memory_buffer_alloc_init+0x54>)
    heap.len = len;

    heap.first = (memory_header *)buf;
    heap.first->size = len - sizeof( memory_header );
    heap.first->magic1 = MAGIC1;
 c006d74:	4a09      	ldr	r2, [pc, #36]	; (c006d9c <mbedtls_memory_buffer_alloc_init+0x60>)
    heap.len = len;
 c006d76:	e9c3 4500 	strd	r4, r5, [r3]
    heap.first = (memory_header *)buf;
 c006d7a:	609c      	str	r4, [r3, #8]
    heap.first->magic1 = MAGIC1;
 c006d7c:	6022      	str	r2, [r4, #0]
    heap.first->magic2 = MAGIC2;
 c006d7e:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
    heap.first->size = len - sizeof( memory_header );
 c006d82:	3d20      	subs	r5, #32
    heap.first->magic2 = MAGIC2;
 c006d84:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
    heap.first->size = len - sizeof( memory_header );
 c006d88:	6065      	str	r5, [r4, #4]
    heap.first->magic2 = MAGIC2;
 c006d8a:	61e2      	str	r2, [r4, #28]
    heap.first_free = heap.first;
 c006d8c:	60dc      	str	r4, [r3, #12]
}
 c006d8e:	bd38      	pop	{r3, r4, r5, pc}
 c006d90:	300324a0 	.word	0x300324a0
 c006d94:	0c006c2d 	.word	0x0c006c2d
 c006d98:	0c006b15 	.word	0x0c006b15
 c006d9c:	ff00aa55 	.word	0xff00aa55

0c006da0 <platform_calloc_uninit>:
static void *platform_calloc_uninit( size_t n, size_t size )
{
    ((void) n);
    ((void) size);
    return( NULL );
}
 c006da0:	2000      	movs	r0, #0
 c006da2:	4770      	bx	lr

0c006da4 <platform_exit_uninit>:
 * Make dummy function to prevent NULL pointer dereferences
 */
static void platform_exit_uninit( int status )
{
    ((void) status);
}
 c006da4:	4770      	bx	lr

0c006da6 <platform_free_uninit>:
 c006da6:	4770      	bx	lr

0c006da8 <mbedtls_calloc>:
    return (*mbedtls_calloc_func)( nmemb, size );
 c006da8:	4b01      	ldr	r3, [pc, #4]	; (c006db0 <mbedtls_calloc+0x8>)
 c006daa:	681b      	ldr	r3, [r3, #0]
 c006dac:	4718      	bx	r3
 c006dae:	bf00      	nop
 c006db0:	3003007c 	.word	0x3003007c

0c006db4 <mbedtls_free>:
    (*mbedtls_free_func)( ptr );
 c006db4:	4b01      	ldr	r3, [pc, #4]	; (c006dbc <mbedtls_free+0x8>)
 c006db6:	681b      	ldr	r3, [r3, #0]
 c006db8:	4718      	bx	r3
 c006dba:	bf00      	nop
 c006dbc:	30030084 	.word	0x30030084

0c006dc0 <mbedtls_platform_set_calloc_free>:
    mbedtls_calloc_func = calloc_func;
 c006dc0:	4b02      	ldr	r3, [pc, #8]	; (c006dcc <mbedtls_platform_set_calloc_free+0xc>)
 c006dc2:	6018      	str	r0, [r3, #0]
    mbedtls_free_func = free_func;
 c006dc4:	4b02      	ldr	r3, [pc, #8]	; (c006dd0 <mbedtls_platform_set_calloc_free+0x10>)
}
 c006dc6:	2000      	movs	r0, #0
    mbedtls_free_func = free_func;
 c006dc8:	6019      	str	r1, [r3, #0]
}
 c006dca:	4770      	bx	lr
 c006dcc:	3003007c 	.word	0x3003007c
 c006dd0:	30030084 	.word	0x30030084

0c006dd4 <mbedtls_platform_zeroize>:
 */
static void * (* const volatile memset_func)( void *, int, size_t ) = memset;

void mbedtls_platform_zeroize( void *buf, size_t len )
{
    memset_func( buf, 0, len );
 c006dd4:	4b02      	ldr	r3, [pc, #8]	; (c006de0 <mbedtls_platform_zeroize+0xc>)
{
 c006dd6:	460a      	mov	r2, r1
    memset_func( buf, 0, len );
 c006dd8:	681b      	ldr	r3, [r3, #0]
 c006dda:	2100      	movs	r1, #0
 c006ddc:	4718      	bx	r3
 c006dde:	bf00      	nop
 c006de0:	30030088 	.word	0x30030088

0c006de4 <mgf_mask>:
 * \param slen      length of the source buffer
 * \param md_ctx    message digest context to use
 */
static int mgf_mask( unsigned char *dst, size_t dlen, unsigned char *src,
                      size_t slen, mbedtls_md_context_t *md_ctx )
{
 c006de4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c006de8:	b08b      	sub	sp, #44	; 0x2c
 c006dea:	4606      	mov	r6, r0
 c006dec:	460d      	mov	r5, r1
 c006dee:	4690      	mov	r8, r2
    unsigned char *p;
    unsigned int hlen;
    size_t i, use_len;
    int ret = 0;

    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
 c006df0:	2100      	movs	r1, #0
 c006df2:	2220      	movs	r2, #32
 c006df4:	a802      	add	r0, sp, #8
{
 c006df6:	4699      	mov	r9, r3
 c006df8:	9f14      	ldr	r7, [sp, #80]	; 0x50
    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
 c006dfa:	f001 fed4 	bl	c008ba6 <memset>
    memset( counter, 0, 4 );
 c006dfe:	2300      	movs	r3, #0

    hlen = mbedtls_md_get_size( md_ctx->md_info );
 c006e00:	6838      	ldr	r0, [r7, #0]
    memset( counter, 0, 4 );
 c006e02:	9301      	str	r3, [sp, #4]
    hlen = mbedtls_md_get_size( md_ctx->md_info );
 c006e04:	f7ff fe1c 	bl	c006a40 <mbedtls_md_get_size>
 c006e08:	4682      	mov	sl, r0

    /* Generate and apply dbMask */
    p = dst;

    while( dlen > 0 )
 c006e0a:	b945      	cbnz	r5, c006e1e <mgf_mask+0x3a>
        counter[3]++;

        dlen -= use_len;
    }

exit:
 c006e0c:	462c      	mov	r4, r5
    mbedtls_platform_zeroize( mask, sizeof( mask ) );
 c006e0e:	a802      	add	r0, sp, #8
 c006e10:	2120      	movs	r1, #32
 c006e12:	f7ff ffdf 	bl	c006dd4 <mbedtls_platform_zeroize>

    return( ret );
}
 c006e16:	4620      	mov	r0, r4
 c006e18:	b00b      	add	sp, #44	; 0x2c
 c006e1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( dlen < hlen )
 c006e1e:	4555      	cmp	r5, sl
        if( ( ret = mbedtls_md_starts( md_ctx ) ) != 0 )
 c006e20:	4638      	mov	r0, r7
 c006e22:	46ab      	mov	fp, r5
 c006e24:	bf28      	it	cs
 c006e26:	46d3      	movcs	fp, sl
 c006e28:	f7ff fddc 	bl	c0069e4 <mbedtls_md_starts>
 c006e2c:	4604      	mov	r4, r0
 c006e2e:	2800      	cmp	r0, #0
 c006e30:	d1ed      	bne.n	c006e0e <mgf_mask+0x2a>
        if( ( ret = mbedtls_md_update( md_ctx, src, slen ) ) != 0 )
 c006e32:	464a      	mov	r2, r9
 c006e34:	4641      	mov	r1, r8
 c006e36:	4638      	mov	r0, r7
 c006e38:	f7ff fdde 	bl	c0069f8 <mbedtls_md_update>
 c006e3c:	4604      	mov	r4, r0
 c006e3e:	2800      	cmp	r0, #0
 c006e40:	d1e5      	bne.n	c006e0e <mgf_mask+0x2a>
        if( ( ret = mbedtls_md_update( md_ctx, counter, 4 ) ) != 0 )
 c006e42:	2204      	movs	r2, #4
 c006e44:	4638      	mov	r0, r7
 c006e46:	eb0d 0102 	add.w	r1, sp, r2
 c006e4a:	f7ff fdd5 	bl	c0069f8 <mbedtls_md_update>
 c006e4e:	4604      	mov	r4, r0
 c006e50:	2800      	cmp	r0, #0
 c006e52:	d1dc      	bne.n	c006e0e <mgf_mask+0x2a>
        if( ( ret = mbedtls_md_finish( md_ctx, mask ) ) != 0 )
 c006e54:	4638      	mov	r0, r7
 c006e56:	a902      	add	r1, sp, #8
 c006e58:	f7ff fdd8 	bl	c006a0c <mbedtls_md_finish>
 c006e5c:	4604      	mov	r4, r0
 c006e5e:	2800      	cmp	r0, #0
 c006e60:	d1d5      	bne.n	c006e0e <mgf_mask+0x2a>
 c006e62:	aa02      	add	r2, sp, #8
 c006e64:	eb06 010b 	add.w	r1, r6, fp
        for( i = 0; i < use_len; ++i )
 c006e68:	428e      	cmp	r6, r1
 c006e6a:	d107      	bne.n	c006e7c <mgf_mask+0x98>
        counter[3]++;
 c006e6c:	f89d 3007 	ldrb.w	r3, [sp, #7]
        dlen -= use_len;
 c006e70:	eba5 050b 	sub.w	r5, r5, fp
        counter[3]++;
 c006e74:	3301      	adds	r3, #1
 c006e76:	f88d 3007 	strb.w	r3, [sp, #7]
        dlen -= use_len;
 c006e7a:	e7c6      	b.n	c006e0a <mgf_mask+0x26>
            *p++ ^= mask[i];
 c006e7c:	f816 0b01 	ldrb.w	r0, [r6], #1
 c006e80:	f812 3b01 	ldrb.w	r3, [r2], #1
 c006e84:	4043      	eors	r3, r0
 c006e86:	f806 3c01 	strb.w	r3, [r6, #-1]
        for( i = 0; i < use_len; ++i )
 c006e8a:	e7ed      	b.n	c006e68 <mgf_mask+0x84>

0c006e8c <rsa_check_context.isra.0>:
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c006e8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c006e8e:	f100 0608 	add.w	r6, r0, #8
 c006e92:	6847      	ldr	r7, [r0, #4]
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c006e94:	4604      	mov	r4, r0
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c006e96:	4630      	mov	r0, r6
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c006e98:	460d      	mov	r5, r1
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c006e9a:	f7fe fbd2 	bl	c005642 <mbedtls_mpi_size>
 c006e9e:	4287      	cmp	r7, r0
 c006ea0:	d116      	bne.n	c006ed0 <rsa_check_context.isra.0+0x44>
 c006ea2:	6863      	ldr	r3, [r4, #4]
 c006ea4:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
 c006ea8:	d812      	bhi.n	c006ed0 <rsa_check_context.isra.0+0x44>
    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
 c006eaa:	2100      	movs	r1, #0
 c006eac:	4630      	mov	r0, r6
 c006eae:	f7fe fda2 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c006eb2:	2800      	cmp	r0, #0
 c006eb4:	dd0c      	ble.n	c006ed0 <rsa_check_context.isra.0+0x44>
        mbedtls_mpi_get_bit( &ctx->N, 0 ) == 0  )
 c006eb6:	2100      	movs	r1, #0
 c006eb8:	4630      	mov	r0, r6
 c006eba:	f7fe fb7a 	bl	c0055b2 <mbedtls_mpi_get_bit>
    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
 c006ebe:	b138      	cbz	r0, c006ed0 <rsa_check_context.isra.0+0x44>
    if( is_priv &&
 c006ec0:	b945      	cbnz	r5, c006ed4 <rsa_check_context.isra.0+0x48>
    if( mbedtls_mpi_cmp_int( &ctx->E, 0 ) <= 0 )
 c006ec2:	2100      	movs	r1, #0
 c006ec4:	f104 0014 	add.w	r0, r4, #20
 c006ec8:	f7fe fd95 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c006ecc:	2800      	cmp	r0, #0
 c006ece:	dc1e      	bgt.n	c006f0e <rsa_check_context.isra.0+0x82>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c006ed0:	481b      	ldr	r0, [pc, #108]	; (c006f40 <rsa_check_context.isra.0+0xb4>)
 c006ed2:	e01e      	b.n	c006f12 <rsa_check_context.isra.0+0x86>
        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
 c006ed4:	f104 062c 	add.w	r6, r4, #44	; 0x2c
 c006ed8:	2100      	movs	r1, #0
 c006eda:	4630      	mov	r0, r6
 c006edc:	f7fe fd8b 	bl	c0059f6 <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c006ee0:	2800      	cmp	r0, #0
 c006ee2:	ddf5      	ble.n	c006ed0 <rsa_check_context.isra.0+0x44>
          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
 c006ee4:	2100      	movs	r1, #0
 c006ee6:	4630      	mov	r0, r6
 c006ee8:	f7fe fb63 	bl	c0055b2 <mbedtls_mpi_get_bit>
        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
 c006eec:	2800      	cmp	r0, #0
 c006eee:	d0ef      	beq.n	c006ed0 <rsa_check_context.isra.0+0x44>
          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
 c006ef0:	f104 0638 	add.w	r6, r4, #56	; 0x38
 c006ef4:	2100      	movs	r1, #0
 c006ef6:	4630      	mov	r0, r6
 c006ef8:	f7fe fd7d 	bl	c0059f6 <mbedtls_mpi_cmp_int>
          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
 c006efc:	2800      	cmp	r0, #0
 c006efe:	dde7      	ble.n	c006ed0 <rsa_check_context.isra.0+0x44>
          mbedtls_mpi_get_bit( &ctx->Q, 0 ) == 0  ) )
 c006f00:	2100      	movs	r1, #0
 c006f02:	4630      	mov	r0, r6
 c006f04:	f7fe fb55 	bl	c0055b2 <mbedtls_mpi_get_bit>
          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
 c006f08:	2800      	cmp	r0, #0
 c006f0a:	d1da      	bne.n	c006ec2 <rsa_check_context.isra.0+0x36>
 c006f0c:	e7e0      	b.n	c006ed0 <rsa_check_context.isra.0+0x44>
    if( is_priv &&
 c006f0e:	b90d      	cbnz	r5, c006f14 <rsa_check_context.isra.0+0x88>
    return( 0 );
 c006f10:	2000      	movs	r0, #0
}
 c006f12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
 c006f14:	2100      	movs	r1, #0
 c006f16:	f104 0044 	add.w	r0, r4, #68	; 0x44
 c006f1a:	f7fe fd6c 	bl	c0059f6 <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c006f1e:	2800      	cmp	r0, #0
 c006f20:	ddd6      	ble.n	c006ed0 <rsa_check_context.isra.0+0x44>
          mbedtls_mpi_cmp_int( &ctx->DQ, 0 ) <= 0  ) )
 c006f22:	2100      	movs	r1, #0
 c006f24:	f104 0050 	add.w	r0, r4, #80	; 0x50
 c006f28:	f7fe fd65 	bl	c0059f6 <mbedtls_mpi_cmp_int>
        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
 c006f2c:	2800      	cmp	r0, #0
 c006f2e:	ddcf      	ble.n	c006ed0 <rsa_check_context.isra.0+0x44>
        mbedtls_mpi_cmp_int( &ctx->QP, 0 ) <= 0 )
 c006f30:	2100      	movs	r1, #0
 c006f32:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 c006f36:	f7fe fd5e 	bl	c0059f6 <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c006f3a:	2800      	cmp	r0, #0
 c006f3c:	dce8      	bgt.n	c006f10 <rsa_check_context.isra.0+0x84>
 c006f3e:	e7c7      	b.n	c006ed0 <rsa_check_context.isra.0+0x44>
 c006f40:	ffffbf80 	.word	0xffffbf80

0c006f44 <mbedtls_rsa_import>:
{
 c006f44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c006f48:	4605      	mov	r5, r0
 c006f4a:	e9dd 7608 	ldrd	r7, r6, [sp, #32]
 c006f4e:	4691      	mov	r9, r2
 c006f50:	4698      	mov	r8, r3
    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
 c006f52:	460c      	mov	r4, r1
 c006f54:	b979      	cbnz	r1, c006f76 <mbedtls_rsa_import+0x32>
 c006f56:	f1b9 0f00 	cmp.w	r9, #0
 c006f5a:	d115      	bne.n	c006f88 <mbedtls_rsa_import+0x44>
        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
 c006f5c:	f1b8 0f00 	cmp.w	r8, #0
 c006f60:	d11a      	bne.n	c006f98 <mbedtls_rsa_import+0x54>
        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
 c006f62:	bb0f      	cbnz	r7, c006fa8 <mbedtls_rsa_import+0x64>
        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
 c006f64:	bb46      	cbnz	r6, c006fb8 <mbedtls_rsa_import+0x74>
    if( N != NULL )
 c006f66:	b37c      	cbz	r4, c006fc8 <mbedtls_rsa_import+0x84>
        ctx->len = mbedtls_mpi_size( &ctx->N );
 c006f68:	f105 0008 	add.w	r0, r5, #8
 c006f6c:	f7fe fb69 	bl	c005642 <mbedtls_mpi_size>
 c006f70:	6068      	str	r0, [r5, #4]
    return( 0 );
 c006f72:	2000      	movs	r0, #0
 c006f74:	e006      	b.n	c006f84 <mbedtls_rsa_import+0x40>
    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
 c006f76:	3008      	adds	r0, #8
 c006f78:	f7fe fad3 	bl	c005522 <mbedtls_mpi_copy>
 c006f7c:	2800      	cmp	r0, #0
 c006f7e:	d0ea      	beq.n	c006f56 <mbedtls_rsa_import+0x12>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
 c006f80:	f5a0 4081 	sub.w	r0, r0, #16512	; 0x4080
}
 c006f84:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
 c006f88:	4649      	mov	r1, r9
 c006f8a:	f105 002c 	add.w	r0, r5, #44	; 0x2c
 c006f8e:	f7fe fac8 	bl	c005522 <mbedtls_mpi_copy>
 c006f92:	2800      	cmp	r0, #0
 c006f94:	d0e2      	beq.n	c006f5c <mbedtls_rsa_import+0x18>
 c006f96:	e7f3      	b.n	c006f80 <mbedtls_rsa_import+0x3c>
        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
 c006f98:	4641      	mov	r1, r8
 c006f9a:	f105 0038 	add.w	r0, r5, #56	; 0x38
 c006f9e:	f7fe fac0 	bl	c005522 <mbedtls_mpi_copy>
 c006fa2:	2800      	cmp	r0, #0
 c006fa4:	d0dd      	beq.n	c006f62 <mbedtls_rsa_import+0x1e>
 c006fa6:	e7eb      	b.n	c006f80 <mbedtls_rsa_import+0x3c>
        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
 c006fa8:	4639      	mov	r1, r7
 c006faa:	f105 0020 	add.w	r0, r5, #32
 c006fae:	f7fe fab8 	bl	c005522 <mbedtls_mpi_copy>
 c006fb2:	2800      	cmp	r0, #0
 c006fb4:	d0d6      	beq.n	c006f64 <mbedtls_rsa_import+0x20>
 c006fb6:	e7e3      	b.n	c006f80 <mbedtls_rsa_import+0x3c>
        ( E != NULL && ( ret = mbedtls_mpi_copy( &ctx->E, E ) ) != 0 ) )
 c006fb8:	4631      	mov	r1, r6
 c006fba:	f105 0014 	add.w	r0, r5, #20
 c006fbe:	f7fe fab0 	bl	c005522 <mbedtls_mpi_copy>
 c006fc2:	2800      	cmp	r0, #0
 c006fc4:	d0cf      	beq.n	c006f66 <mbedtls_rsa_import+0x22>
 c006fc6:	e7db      	b.n	c006f80 <mbedtls_rsa_import+0x3c>
    return( 0 );
 c006fc8:	4620      	mov	r0, r4
 c006fca:	e7db      	b.n	c006f84 <mbedtls_rsa_import+0x40>

0c006fcc <mbedtls_rsa_init>:
{
 c006fcc:	b570      	push	{r4, r5, r6, lr}
 c006fce:	4604      	mov	r4, r0
 c006fd0:	460e      	mov	r6, r1
 c006fd2:	4615      	mov	r5, r2
    memset( ctx, 0, sizeof( mbedtls_rsa_context ) );
 c006fd4:	2100      	movs	r1, #0
 c006fd6:	22ac      	movs	r2, #172	; 0xac
 c006fd8:	f001 fde5 	bl	c008ba6 <memset>
    ctx->hash_id = hash_id;
 c006fdc:	e9c4 6529 	strd	r6, r5, [r4, #164]	; 0xa4
}
 c006fe0:	bd70      	pop	{r4, r5, r6, pc}
	...

0c006fe4 <mbedtls_rsa_check_pubkey>:
{
 c006fe4:	b570      	push	{r4, r5, r6, lr}
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
 c006fe6:	2100      	movs	r1, #0
{
 c006fe8:	4604      	mov	r4, r0
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
 c006fea:	f7ff ff4f 	bl	c006e8c <rsa_check_context.isra.0>
 c006fee:	4605      	mov	r5, r0
 c006ff0:	b9b8      	cbnz	r0, c007022 <mbedtls_rsa_check_pubkey+0x3e>
    if( mbedtls_mpi_bitlen( &ctx->N ) < 128 )
 c006ff2:	f104 0608 	add.w	r6, r4, #8
 c006ff6:	4630      	mov	r0, r6
 c006ff8:	f7fe fb07 	bl	c00560a <mbedtls_mpi_bitlen>
 c006ffc:	287f      	cmp	r0, #127	; 0x7f
 c006ffe:	d910      	bls.n	c007022 <mbedtls_rsa_check_pubkey+0x3e>
    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
 c007000:	3414      	adds	r4, #20
 c007002:	4629      	mov	r1, r5
 c007004:	4620      	mov	r0, r4
 c007006:	f7fe fad4 	bl	c0055b2 <mbedtls_mpi_get_bit>
 c00700a:	b150      	cbz	r0, c007022 <mbedtls_rsa_check_pubkey+0x3e>
        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
 c00700c:	4620      	mov	r0, r4
 c00700e:	f7fe fafc 	bl	c00560a <mbedtls_mpi_bitlen>
    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
 c007012:	2801      	cmp	r0, #1
 c007014:	d905      	bls.n	c007022 <mbedtls_rsa_check_pubkey+0x3e>
        mbedtls_mpi_cmp_mpi( &ctx->E, &ctx->N ) >= 0 )
 c007016:	4631      	mov	r1, r6
 c007018:	4620      	mov	r0, r4
 c00701a:	f7fe fca9 	bl	c005970 <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
 c00701e:	2800      	cmp	r0, #0
 c007020:	db00      	blt.n	c007024 <mbedtls_rsa_check_pubkey+0x40>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 c007022:	4d01      	ldr	r5, [pc, #4]	; (c007028 <mbedtls_rsa_check_pubkey+0x44>)
}
 c007024:	4628      	mov	r0, r5
 c007026:	bd70      	pop	{r4, r5, r6, pc}
 c007028:	ffffbe00 	.word	0xffffbe00

0c00702c <mbedtls_rsa_check_privkey>:
{
 c00702c:	b5f0      	push	{r4, r5, r6, r7, lr}
 c00702e:	b085      	sub	sp, #20
 c007030:	4604      	mov	r4, r0
    if( mbedtls_rsa_check_pubkey( ctx ) != 0 ||
 c007032:	f7ff ffd7 	bl	c006fe4 <mbedtls_rsa_check_pubkey>
 c007036:	bb28      	cbnz	r0, c007084 <mbedtls_rsa_check_privkey+0x58>
        rsa_check_context( ctx, 1 /* private */, 1 /* blinding */ ) != 0 )
 c007038:	2101      	movs	r1, #1
 c00703a:	4620      	mov	r0, r4
 c00703c:	f7ff ff26 	bl	c006e8c <rsa_check_context.isra.0>
    if( mbedtls_rsa_check_pubkey( ctx ) != 0 ||
 c007040:	bb00      	cbnz	r0, c007084 <mbedtls_rsa_check_privkey+0x58>
    if( mbedtls_rsa_validate_params( &ctx->N, &ctx->P, &ctx->Q,
 c007042:	f104 0314 	add.w	r3, r4, #20
 c007046:	f104 052c 	add.w	r5, r4, #44	; 0x2c
 c00704a:	f104 0638 	add.w	r6, r4, #56	; 0x38
 c00704e:	f104 0720 	add.w	r7, r4, #32
 c007052:	e9cd 0001 	strd	r0, r0, [sp, #4]
 c007056:	9300      	str	r3, [sp, #0]
 c007058:	4632      	mov	r2, r6
 c00705a:	463b      	mov	r3, r7
 c00705c:	4629      	mov	r1, r5
 c00705e:	f104 0008 	add.w	r0, r4, #8
 c007062:	f000 fb9b 	bl	c00779c <mbedtls_rsa_validate_params>
 c007066:	b968      	cbnz	r0, c007084 <mbedtls_rsa_check_privkey+0x58>
    else if( mbedtls_rsa_validate_crt( &ctx->P, &ctx->Q, &ctx->D,
 c007068:	f104 035c 	add.w	r3, r4, #92	; 0x5c
 c00706c:	9301      	str	r3, [sp, #4]
 c00706e:	f104 0350 	add.w	r3, r4, #80	; 0x50
 c007072:	9300      	str	r3, [sp, #0]
 c007074:	463a      	mov	r2, r7
 c007076:	4631      	mov	r1, r6
 c007078:	4628      	mov	r0, r5
 c00707a:	f104 0344 	add.w	r3, r4, #68	; 0x44
 c00707e:	f000 fb05 	bl	c00768c <mbedtls_rsa_validate_crt>
 c007082:	b100      	cbz	r0, c007086 <mbedtls_rsa_check_privkey+0x5a>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 c007084:	4801      	ldr	r0, [pc, #4]	; (c00708c <mbedtls_rsa_check_privkey+0x60>)
}
 c007086:	b005      	add	sp, #20
 c007088:	bdf0      	pop	{r4, r5, r6, r7, pc}
 c00708a:	bf00      	nop
 c00708c:	ffffbe00 	.word	0xffffbe00

0c007090 <mbedtls_rsa_public>:
{
 c007090:	b5f0      	push	{r4, r5, r6, r7, lr}
 c007092:	460c      	mov	r4, r1
 c007094:	b089      	sub	sp, #36	; 0x24
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
 c007096:	2100      	movs	r1, #0
{
 c007098:	4605      	mov	r5, r0
 c00709a:	4616      	mov	r6, r2
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
 c00709c:	f7ff fef6 	bl	c006e8c <rsa_check_context.isra.0>
 c0070a0:	bb88      	cbnz	r0, c007106 <mbedtls_rsa_public+0x76>
    mbedtls_mpi_init( &T );
 c0070a2:	a805      	add	r0, sp, #20
 c0070a4:	f7fe f9ff 	bl	c0054a6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
 c0070a8:	4621      	mov	r1, r4
 c0070aa:	686a      	ldr	r2, [r5, #4]
 c0070ac:	a805      	add	r0, sp, #20
 c0070ae:	f7fe face 	bl	c00564e <mbedtls_mpi_read_binary>
 c0070b2:	4604      	mov	r4, r0
 c0070b4:	b9d8      	cbnz	r0, c0070ee <mbedtls_rsa_public+0x5e>
    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
 c0070b6:	f105 0308 	add.w	r3, r5, #8
 c0070ba:	4619      	mov	r1, r3
 c0070bc:	a805      	add	r0, sp, #20
 c0070be:	9303      	str	r3, [sp, #12]
 c0070c0:	f7fe fc56 	bl	c005970 <mbedtls_mpi_cmp_mpi>
 c0070c4:	2800      	cmp	r0, #0
 c0070c6:	9b03      	ldr	r3, [sp, #12]
 c0070c8:	da1a      	bge.n	c007100 <mbedtls_rsa_public+0x70>
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T, &T, &ctx->E, &ctx->N, &ctx->RN ) );
 c0070ca:	f105 0268 	add.w	r2, r5, #104	; 0x68
 c0070ce:	a905      	add	r1, sp, #20
 c0070d0:	9200      	str	r2, [sp, #0]
 c0070d2:	4608      	mov	r0, r1
 c0070d4:	f105 0214 	add.w	r2, r5, #20
    olen = ctx->len;
 c0070d8:	686f      	ldr	r7, [r5, #4]
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T, &T, &ctx->E, &ctx->N, &ctx->RN ) );
 c0070da:	f7fe fff2 	bl	c0060c2 <mbedtls_mpi_exp_mod>
 c0070de:	4604      	mov	r4, r0
 c0070e0:	b928      	cbnz	r0, c0070ee <mbedtls_rsa_public+0x5e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &T, output, olen ) );
 c0070e2:	463a      	mov	r2, r7
 c0070e4:	4631      	mov	r1, r6
 c0070e6:	a805      	add	r0, sp, #20
 c0070e8:	f7fe fae9 	bl	c0056be <mbedtls_mpi_write_binary>
 c0070ec:	4604      	mov	r4, r0
    mbedtls_mpi_free( &T );
 c0070ee:	a805      	add	r0, sp, #20
 c0070f0:	f7fe f9df 	bl	c0054b2 <mbedtls_mpi_free>
    if( ret != 0 )
 c0070f4:	b10c      	cbz	r4, c0070fa <mbedtls_rsa_public+0x6a>
        return( MBEDTLS_ERR_RSA_PUBLIC_FAILED + ret );
 c0070f6:	f5a4 4485 	sub.w	r4, r4, #17024	; 0x4280
}
 c0070fa:	4620      	mov	r0, r4
 c0070fc:	b009      	add	sp, #36	; 0x24
 c0070fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 c007100:	f06f 0403 	mvn.w	r4, #3
 c007104:	e7f3      	b.n	c0070ee <mbedtls_rsa_public+0x5e>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c007106:	4c01      	ldr	r4, [pc, #4]	; (c00710c <mbedtls_rsa_public+0x7c>)
 c007108:	e7f7      	b.n	c0070fa <mbedtls_rsa_public+0x6a>
 c00710a:	bf00      	nop
 c00710c:	ffffbf80 	.word	0xffffbf80

0c007110 <mbedtls_rsa_private>:
{
 c007110:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c007114:	460d      	mov	r5, r1
 c007116:	b0a3      	sub	sp, #140	; 0x8c
    if( rsa_check_context( ctx, 1             /* private key checks */,
 c007118:	2101      	movs	r1, #1
{
 c00711a:	4604      	mov	r4, r0
 c00711c:	4617      	mov	r7, r2
 c00711e:	461e      	mov	r6, r3
    if( rsa_check_context( ctx, 1             /* private key checks */,
 c007120:	f7ff feb4 	bl	c006e8c <rsa_check_context.isra.0>
 c007124:	2800      	cmp	r0, #0
 c007126:	f040 81a7 	bne.w	c007478 <mbedtls_rsa_private+0x368>
    mbedtls_mpi_init( &T );
 c00712a:	a804      	add	r0, sp, #16
 c00712c:	f7fe f9bb 	bl	c0054a6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &P1 );
 c007130:	a807      	add	r0, sp, #28
 c007132:	f7fe f9b8 	bl	c0054a6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &Q1 );
 c007136:	a80a      	add	r0, sp, #40	; 0x28
 c007138:	f7fe f9b5 	bl	c0054a6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &R );
 c00713c:	a80d      	add	r0, sp, #52	; 0x34
 c00713e:	f7fe f9b2 	bl	c0054a6 <mbedtls_mpi_init>
    if( f_rng != NULL )
 c007142:	b12d      	cbz	r5, c007150 <mbedtls_rsa_private+0x40>
        mbedtls_mpi_init( &DP_blind );
 c007144:	a816      	add	r0, sp, #88	; 0x58
 c007146:	f7fe f9ae 	bl	c0054a6 <mbedtls_mpi_init>
        mbedtls_mpi_init( &DQ_blind );
 c00714a:	a819      	add	r0, sp, #100	; 0x64
 c00714c:	f7fe f9ab 	bl	c0054a6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &TP ); mbedtls_mpi_init( &TQ );
 c007150:	a810      	add	r0, sp, #64	; 0x40
 c007152:	f7fe f9a8 	bl	c0054a6 <mbedtls_mpi_init>
 c007156:	a813      	add	r0, sp, #76	; 0x4c
 c007158:	f7fe f9a5 	bl	c0054a6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &I );
 c00715c:	a81c      	add	r0, sp, #112	; 0x70
 c00715e:	f7fe f9a2 	bl	c0054a6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &C );
 c007162:	a81f      	add	r0, sp, #124	; 0x7c
 c007164:	f7fe f99f 	bl	c0054a6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
 c007168:	4631      	mov	r1, r6
 c00716a:	6862      	ldr	r2, [r4, #4]
 c00716c:	a804      	add	r0, sp, #16
 c00716e:	f7fe fa6e 	bl	c00564e <mbedtls_mpi_read_binary>
 c007172:	4603      	mov	r3, r0
 c007174:	2800      	cmp	r0, #0
 c007176:	f040 814d 	bne.w	c007414 <mbedtls_rsa_private+0x304>
    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
 c00717a:	f104 0608 	add.w	r6, r4, #8
 c00717e:	4631      	mov	r1, r6
 c007180:	a804      	add	r0, sp, #16
 c007182:	f7fe fbf5 	bl	c005970 <mbedtls_mpi_cmp_mpi>
 c007186:	2800      	cmp	r0, #0
 c007188:	f280 816f 	bge.w	c00746a <mbedtls_rsa_private+0x35a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &I, &T ) );
 c00718c:	a904      	add	r1, sp, #16
 c00718e:	a81c      	add	r0, sp, #112	; 0x70
 c007190:	f7fe f9c7 	bl	c005522 <mbedtls_mpi_copy>
 c007194:	4603      	mov	r3, r0
 c007196:	2800      	cmp	r0, #0
 c007198:	f040 813c 	bne.w	c007414 <mbedtls_rsa_private+0x304>
    mbedtls_mpi *DP = &ctx->DP;
 c00719c:	f104 0a44 	add.w	sl, r4, #68	; 0x44
    mbedtls_mpi *DQ = &ctx->DQ;
 c0071a0:	f104 0950 	add.w	r9, r4, #80	; 0x50
    if( f_rng != NULL )
 c0071a4:	2d00      	cmp	r5, #0
 c0071a6:	f000 8090 	beq.w	c0072ca <mbedtls_rsa_private+0x1ba>
    if( ctx->Vf.p != NULL )
 c0071aa:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 c0071ae:	2b00      	cmp	r3, #0
 c0071b0:	f000 80ee 	beq.w	c007390 <mbedtls_rsa_private+0x280>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ctx->Vi, &ctx->Vi, &ctx->Vi ) );
 c0071b4:	f104 018c 	add.w	r1, r4, #140	; 0x8c
 c0071b8:	460a      	mov	r2, r1
 c0071ba:	4608      	mov	r0, r1
 c0071bc:	9103      	str	r1, [sp, #12]
 c0071be:	f7fe fd21 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c0071c2:	4603      	mov	r3, r0
 c0071c4:	2800      	cmp	r0, #0
 c0071c6:	f040 8125 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &ctx->Vi, &ctx->Vi, &ctx->N ) );
 c0071ca:	9903      	ldr	r1, [sp, #12]
 c0071cc:	4632      	mov	r2, r6
 c0071ce:	4608      	mov	r0, r1
 c0071d0:	f7fe ff45 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c0071d4:	4603      	mov	r3, r0
 c0071d6:	2800      	cmp	r0, #0
 c0071d8:	f040 811c 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ctx->Vf, &ctx->Vf, &ctx->Vf ) );
 c0071dc:	f104 0198 	add.w	r1, r4, #152	; 0x98
 c0071e0:	460a      	mov	r2, r1
 c0071e2:	4608      	mov	r0, r1
 c0071e4:	9103      	str	r1, [sp, #12]
 c0071e6:	f7fe fd0d 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c0071ea:	4603      	mov	r3, r0
 c0071ec:	2800      	cmp	r0, #0
 c0071ee:	f040 8111 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &ctx->Vf, &ctx->Vf, &ctx->N ) );
 c0071f2:	9903      	ldr	r1, [sp, #12]
 c0071f4:	4632      	mov	r2, r6
 c0071f6:	4608      	mov	r0, r1
 c0071f8:	f7fe ff31 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c0071fc:	4603      	mov	r3, r0
 c0071fe:	2800      	cmp	r0, #0
 c007200:	f040 8108 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &T, &ctx->Vi ) );
 c007204:	a904      	add	r1, sp, #16
 c007206:	4608      	mov	r0, r1
 c007208:	f104 028c 	add.w	r2, r4, #140	; 0x8c
 c00720c:	f7fe fcfa 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c007210:	4603      	mov	r3, r0
 c007212:	2800      	cmp	r0, #0
 c007214:	f040 80fe 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &T, &T, &ctx->N ) );
 c007218:	a904      	add	r1, sp, #16
 c00721a:	4632      	mov	r2, r6
 c00721c:	4608      	mov	r0, r1
 c00721e:	f7fe ff1e 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c007222:	4603      	mov	r3, r0
 c007224:	2800      	cmp	r0, #0
 c007226:	f040 80f5 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &P1, &ctx->P, 1 ) );
 c00722a:	2201      	movs	r2, #1
 c00722c:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 c007230:	a807      	add	r0, sp, #28
 c007232:	f7fe fcd1 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c007236:	4603      	mov	r3, r0
 c007238:	2800      	cmp	r0, #0
 c00723a:	f040 80eb 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &Q1, &ctx->Q, 1 ) );
 c00723e:	2201      	movs	r2, #1
 c007240:	f104 0138 	add.w	r1, r4, #56	; 0x38
 c007244:	a80a      	add	r0, sp, #40	; 0x28
 c007246:	f7fe fcc7 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c00724a:	4603      	mov	r3, r0
 c00724c:	2800      	cmp	r0, #0
 c00724e:	f040 80e1 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &R, RSA_EXPONENT_BLINDING,
 c007252:	463b      	mov	r3, r7
 c007254:	462a      	mov	r2, r5
 c007256:	211c      	movs	r1, #28
 c007258:	a80d      	add	r0, sp, #52	; 0x34
 c00725a:	f7ff f9e4 	bl	c006626 <mbedtls_mpi_fill_random>
 c00725e:	4603      	mov	r3, r0
 c007260:	2800      	cmp	r0, #0
 c007262:	f040 80d7 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DP_blind, &P1, &R ) );
 c007266:	aa0d      	add	r2, sp, #52	; 0x34
 c007268:	a907      	add	r1, sp, #28
 c00726a:	a816      	add	r0, sp, #88	; 0x58
 c00726c:	f7fe fcca 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c007270:	4603      	mov	r3, r0
 c007272:	2800      	cmp	r0, #0
 c007274:	f040 80ce 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &DP_blind, &DP_blind,
 c007278:	a916      	add	r1, sp, #88	; 0x58
 c00727a:	4652      	mov	r2, sl
 c00727c:	4608      	mov	r0, r1
 c00727e:	f7fe fc66 	bl	c005b4e <mbedtls_mpi_add_mpi>
 c007282:	4603      	mov	r3, r0
 c007284:	2800      	cmp	r0, #0
 c007286:	f040 80c5 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &R, RSA_EXPONENT_BLINDING,
 c00728a:	463b      	mov	r3, r7
 c00728c:	462a      	mov	r2, r5
 c00728e:	211c      	movs	r1, #28
 c007290:	a80d      	add	r0, sp, #52	; 0x34
 c007292:	f7ff f9c8 	bl	c006626 <mbedtls_mpi_fill_random>
 c007296:	4603      	mov	r3, r0
 c007298:	2800      	cmp	r0, #0
 c00729a:	f040 80bb 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DQ_blind, &Q1, &R ) );
 c00729e:	aa0d      	add	r2, sp, #52	; 0x34
 c0072a0:	a90a      	add	r1, sp, #40	; 0x28
 c0072a2:	a819      	add	r0, sp, #100	; 0x64
 c0072a4:	f7fe fcae 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c0072a8:	4603      	mov	r3, r0
 c0072aa:	2800      	cmp	r0, #0
 c0072ac:	f040 80b2 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &DQ_blind, &DQ_blind,
 c0072b0:	a919      	add	r1, sp, #100	; 0x64
 c0072b2:	464a      	mov	r2, r9
 c0072b4:	4608      	mov	r0, r1
 c0072b6:	f7fe fc4a 	bl	c005b4e <mbedtls_mpi_add_mpi>
 c0072ba:	4603      	mov	r3, r0
 c0072bc:	2800      	cmp	r0, #0
 c0072be:	f040 80a9 	bne.w	c007414 <mbedtls_rsa_private+0x304>
        DQ = &DQ_blind;
 c0072c2:	f10d 0964 	add.w	r9, sp, #100	; 0x64
        DP = &DP_blind;
 c0072c6:	f10d 0a58 	add.w	sl, sp, #88	; 0x58
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &TP, &T, DP, &ctx->P, &ctx->RP ) );
 c0072ca:	f104 0374 	add.w	r3, r4, #116	; 0x74
 c0072ce:	f104 082c 	add.w	r8, r4, #44	; 0x2c
 c0072d2:	9300      	str	r3, [sp, #0]
 c0072d4:	4652      	mov	r2, sl
 c0072d6:	4643      	mov	r3, r8
 c0072d8:	a904      	add	r1, sp, #16
 c0072da:	a810      	add	r0, sp, #64	; 0x40
 c0072dc:	f7fe fef1 	bl	c0060c2 <mbedtls_mpi_exp_mod>
 c0072e0:	4603      	mov	r3, r0
 c0072e2:	2800      	cmp	r0, #0
 c0072e4:	f040 8096 	bne.w	c007414 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &TQ, &T, DQ, &ctx->Q, &ctx->RQ ) );
 c0072e8:	f104 0380 	add.w	r3, r4, #128	; 0x80
 c0072ec:	f104 0738 	add.w	r7, r4, #56	; 0x38
 c0072f0:	9300      	str	r3, [sp, #0]
 c0072f2:	464a      	mov	r2, r9
 c0072f4:	463b      	mov	r3, r7
 c0072f6:	a904      	add	r1, sp, #16
 c0072f8:	a813      	add	r0, sp, #76	; 0x4c
 c0072fa:	f7fe fee2 	bl	c0060c2 <mbedtls_mpi_exp_mod>
 c0072fe:	4603      	mov	r3, r0
 c007300:	2800      	cmp	r0, #0
 c007302:	f040 8087 	bne.w	c007414 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T, &TP, &TQ ) );
 c007306:	aa13      	add	r2, sp, #76	; 0x4c
 c007308:	a910      	add	r1, sp, #64	; 0x40
 c00730a:	a804      	add	r0, sp, #16
 c00730c:	f7fe fc41 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c007310:	4603      	mov	r3, r0
 c007312:	2800      	cmp	r0, #0
 c007314:	d17e      	bne.n	c007414 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &TP, &T, &ctx->QP ) );
 c007316:	f104 025c 	add.w	r2, r4, #92	; 0x5c
 c00731a:	a904      	add	r1, sp, #16
 c00731c:	a810      	add	r0, sp, #64	; 0x40
 c00731e:	f7fe fc71 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c007322:	4603      	mov	r3, r0
 c007324:	2800      	cmp	r0, #0
 c007326:	d175      	bne.n	c007414 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &T, &TP, &ctx->P ) );
 c007328:	4642      	mov	r2, r8
 c00732a:	a910      	add	r1, sp, #64	; 0x40
 c00732c:	a804      	add	r0, sp, #16
 c00732e:	f7fe fe96 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c007332:	4603      	mov	r3, r0
 c007334:	2800      	cmp	r0, #0
 c007336:	d16d      	bne.n	c007414 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &TP, &T, &ctx->Q ) );
 c007338:	463a      	mov	r2, r7
 c00733a:	a904      	add	r1, sp, #16
 c00733c:	a810      	add	r0, sp, #64	; 0x40
 c00733e:	f7fe fc61 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c007342:	4603      	mov	r3, r0
 c007344:	2800      	cmp	r0, #0
 c007346:	d165      	bne.n	c007414 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T, &TQ, &TP ) );
 c007348:	aa10      	add	r2, sp, #64	; 0x40
 c00734a:	a913      	add	r1, sp, #76	; 0x4c
 c00734c:	a804      	add	r0, sp, #16
 c00734e:	f7fe fbfe 	bl	c005b4e <mbedtls_mpi_add_mpi>
 c007352:	4603      	mov	r3, r0
 c007354:	2800      	cmp	r0, #0
 c007356:	d15d      	bne.n	c007414 <mbedtls_rsa_private+0x304>
    if( f_rng != NULL )
 c007358:	2d00      	cmp	r5, #0
 c00735a:	d14b      	bne.n	c0073f4 <mbedtls_rsa_private+0x2e4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &C, &T, &ctx->E,
 c00735c:	f104 0368 	add.w	r3, r4, #104	; 0x68
 c007360:	9300      	str	r3, [sp, #0]
 c007362:	f104 0214 	add.w	r2, r4, #20
 c007366:	4633      	mov	r3, r6
 c007368:	a904      	add	r1, sp, #16
 c00736a:	a81f      	add	r0, sp, #124	; 0x7c
 c00736c:	f7fe fea9 	bl	c0060c2 <mbedtls_mpi_exp_mod>
 c007370:	4603      	mov	r3, r0
 c007372:	2800      	cmp	r0, #0
 c007374:	d14e      	bne.n	c007414 <mbedtls_rsa_private+0x304>
    if( mbedtls_mpi_cmp_mpi( &C, &I ) != 0 )
 c007376:	a91c      	add	r1, sp, #112	; 0x70
 c007378:	a81f      	add	r0, sp, #124	; 0x7c
 c00737a:	f7fe faf9 	bl	c005970 <mbedtls_mpi_cmp_mpi>
 c00737e:	2800      	cmp	r0, #0
 c007380:	d178      	bne.n	c007474 <mbedtls_rsa_private+0x364>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &T, output, olen ) );
 c007382:	6862      	ldr	r2, [r4, #4]
 c007384:	992c      	ldr	r1, [sp, #176]	; 0xb0
 c007386:	a804      	add	r0, sp, #16
 c007388:	f7fe f999 	bl	c0056be <mbedtls_mpi_write_binary>
 c00738c:	4603      	mov	r3, r0
cleanup:
 c00738e:	e041      	b.n	c007414 <mbedtls_rsa_private+0x304>
 c007390:	230c      	movs	r3, #12
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &ctx->Vf, ctx->len - 1, f_rng, p_rng ) );
 c007392:	f104 0b98 	add.w	fp, r4, #152	; 0x98
 c007396:	9303      	str	r3, [sp, #12]
        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &ctx->Vi, &ctx->Vf, &ctx->N ) );
 c007398:	f104 088c 	add.w	r8, r4, #140	; 0x8c
        if( count++ > 10 )
 c00739c:	9b03      	ldr	r3, [sp, #12]
 c00739e:	3b01      	subs	r3, #1
 c0073a0:	9303      	str	r3, [sp, #12]
 c0073a2:	d065      	beq.n	c007470 <mbedtls_rsa_private+0x360>
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &ctx->Vf, ctx->len - 1, f_rng, p_rng ) );
 c0073a4:	6861      	ldr	r1, [r4, #4]
 c0073a6:	463b      	mov	r3, r7
 c0073a8:	462a      	mov	r2, r5
 c0073aa:	4658      	mov	r0, fp
 c0073ac:	3901      	subs	r1, #1
 c0073ae:	f7ff f93a 	bl	c006626 <mbedtls_mpi_fill_random>
 c0073b2:	4603      	mov	r3, r0
 c0073b4:	bb70      	cbnz	r0, c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &ctx->Vi, &ctx->Vf, &ctx->N ) );
 c0073b6:	4632      	mov	r2, r6
 c0073b8:	4659      	mov	r1, fp
 c0073ba:	4640      	mov	r0, r8
 c0073bc:	f7ff f8af 	bl	c00651e <mbedtls_mpi_gcd>
 c0073c0:	4603      	mov	r3, r0
 c0073c2:	bb38      	cbnz	r0, c007414 <mbedtls_rsa_private+0x304>
    } while( mbedtls_mpi_cmp_int( &ctx->Vi, 1 ) != 0 );
 c0073c4:	2101      	movs	r1, #1
 c0073c6:	4640      	mov	r0, r8
 c0073c8:	f7fe fb15 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c0073cc:	2800      	cmp	r0, #0
 c0073ce:	d1e5      	bne.n	c00739c <mbedtls_rsa_private+0x28c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &ctx->Vi, &ctx->Vf, &ctx->N ) );
 c0073d0:	4632      	mov	r2, r6
 c0073d2:	4659      	mov	r1, fp
 c0073d4:	4640      	mov	r0, r8
 c0073d6:	f7ff f95b 	bl	c006690 <mbedtls_mpi_inv_mod>
 c0073da:	4603      	mov	r3, r0
 c0073dc:	b9d0      	cbnz	r0, c007414 <mbedtls_rsa_private+0x304>
    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &ctx->Vi, &ctx->Vi, &ctx->E, &ctx->N, &ctx->RN ) );
 c0073de:	f104 0368 	add.w	r3, r4, #104	; 0x68
 c0073e2:	9300      	str	r3, [sp, #0]
 c0073e4:	4641      	mov	r1, r8
 c0073e6:	4633      	mov	r3, r6
 c0073e8:	4640      	mov	r0, r8
 c0073ea:	f104 0214 	add.w	r2, r4, #20
 c0073ee:	f7fe fe68 	bl	c0060c2 <mbedtls_mpi_exp_mod>
 c0073f2:	e703      	b.n	c0071fc <mbedtls_rsa_private+0xec>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &T, &ctx->Vf ) );
 c0073f4:	a904      	add	r1, sp, #16
 c0073f6:	4608      	mov	r0, r1
 c0073f8:	f104 0298 	add.w	r2, r4, #152	; 0x98
 c0073fc:	f7fe fc02 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c007400:	4603      	mov	r3, r0
 c007402:	b938      	cbnz	r0, c007414 <mbedtls_rsa_private+0x304>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &T, &T, &ctx->N ) );
 c007404:	a904      	add	r1, sp, #16
 c007406:	4632      	mov	r2, r6
 c007408:	4608      	mov	r0, r1
 c00740a:	f7fe fe28 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c00740e:	4603      	mov	r3, r0
 c007410:	2800      	cmp	r0, #0
 c007412:	d0a3      	beq.n	c00735c <mbedtls_rsa_private+0x24c>
    mbedtls_mpi_free( &P1 );
 c007414:	a807      	add	r0, sp, #28
 c007416:	9303      	str	r3, [sp, #12]
 c007418:	f7fe f84b 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &Q1 );
 c00741c:	a80a      	add	r0, sp, #40	; 0x28
 c00741e:	f7fe f848 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &R );
 c007422:	a80d      	add	r0, sp, #52	; 0x34
 c007424:	f7fe f845 	bl	c0054b2 <mbedtls_mpi_free>
    if( f_rng != NULL )
 c007428:	9b03      	ldr	r3, [sp, #12]
 c00742a:	b135      	cbz	r5, c00743a <mbedtls_rsa_private+0x32a>
        mbedtls_mpi_free( &DP_blind );
 c00742c:	a816      	add	r0, sp, #88	; 0x58
 c00742e:	f7fe f840 	bl	c0054b2 <mbedtls_mpi_free>
        mbedtls_mpi_free( &DQ_blind );
 c007432:	a819      	add	r0, sp, #100	; 0x64
 c007434:	f7fe f83d 	bl	c0054b2 <mbedtls_mpi_free>
 c007438:	9b03      	ldr	r3, [sp, #12]
    mbedtls_mpi_free( &T );
 c00743a:	a804      	add	r0, sp, #16
 c00743c:	9303      	str	r3, [sp, #12]
 c00743e:	f7fe f838 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &TP ); mbedtls_mpi_free( &TQ );
 c007442:	a810      	add	r0, sp, #64	; 0x40
 c007444:	f7fe f835 	bl	c0054b2 <mbedtls_mpi_free>
 c007448:	a813      	add	r0, sp, #76	; 0x4c
 c00744a:	f7fe f832 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &C );
 c00744e:	a81f      	add	r0, sp, #124	; 0x7c
 c007450:	f7fe f82f 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &I );
 c007454:	a81c      	add	r0, sp, #112	; 0x70
 c007456:	f7fe f82c 	bl	c0054b2 <mbedtls_mpi_free>
    if( ret != 0 )
 c00745a:	9b03      	ldr	r3, [sp, #12]
 c00745c:	b10b      	cbz	r3, c007462 <mbedtls_rsa_private+0x352>
        return( MBEDTLS_ERR_RSA_PRIVATE_FAILED + ret );
 c00745e:	f5a3 4386 	sub.w	r3, r3, #17152	; 0x4300
}
 c007462:	4618      	mov	r0, r3
 c007464:	b023      	add	sp, #140	; 0x8c
 c007466:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 c00746a:	f06f 0303 	mvn.w	r3, #3
 c00746e:	e7d1      	b.n	c007414 <mbedtls_rsa_private+0x304>
            return( MBEDTLS_ERR_RSA_RNG_FAILED );
 c007470:	4b02      	ldr	r3, [pc, #8]	; (c00747c <mbedtls_rsa_private+0x36c>)
 c007472:	e7cf      	b.n	c007414 <mbedtls_rsa_private+0x304>
        ret = MBEDTLS_ERR_RSA_VERIFY_FAILED;
 c007474:	4b02      	ldr	r3, [pc, #8]	; (c007480 <mbedtls_rsa_private+0x370>)
 c007476:	e7cd      	b.n	c007414 <mbedtls_rsa_private+0x304>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c007478:	4b02      	ldr	r3, [pc, #8]	; (c007484 <mbedtls_rsa_private+0x374>)
 c00747a:	e7f2      	b.n	c007462 <mbedtls_rsa_private+0x352>
 c00747c:	ffffbb80 	.word	0xffffbb80
 c007480:	ffffbc80 	.word	0xffffbc80
 c007484:	ffffbf80 	.word	0xffffbf80

0c007488 <mbedtls_rsa_rsaes_oaep_decrypt>:
                            const unsigned char *label, size_t label_len,
                            size_t *olen,
                            const unsigned char *input,
                            unsigned char *output,
                            size_t output_max_len )
{
 c007488:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    RSA_VALIDATE_RET( olen != NULL );

    /*
     * Parameters sanity checks
     */
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c00748c:	2b01      	cmp	r3, #1
{
 c00748e:	4606      	mov	r6, r0
 c007490:	468b      	mov	fp, r1
 c007492:	469a      	mov	sl, r3
 c007494:	b0f1      	sub	sp, #452	; 0x1c4
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c007496:	d108      	bne.n	c0074aa <mbedtls_rsa_rsaes_oaep_decrypt+0x22>
 c007498:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 c00749c:	2b01      	cmp	r3, #1
 c00749e:	d004      	beq.n	c0074aa <mbedtls_rsa_rsaes_oaep_decrypt+0x22>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c0074a0:	4e5a      	ldr	r6, [pc, #360]	; (c00760c <mbedtls_rsa_rsaes_oaep_decrypt+0x184>)
cleanup:
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
    mbedtls_platform_zeroize( lhash, sizeof( lhash ) );

    return( ret );
}
 c0074a2:	4630      	mov	r0, r6
 c0074a4:	b071      	add	sp, #452	; 0x1c4
 c0074a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ilen = ctx->len;
 c0074aa:	6874      	ldr	r4, [r6, #4]
 c0074ac:	9203      	str	r2, [sp, #12]
    if( ilen < 16 || ilen > sizeof( buf ) )
 c0074ae:	f1a4 0310 	sub.w	r3, r4, #16
 c0074b2:	f5b3 7fb8 	cmp.w	r3, #368	; 0x170
 c0074b6:	d8f3      	bhi.n	c0074a0 <mbedtls_rsa_rsaes_oaep_decrypt+0x18>
    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
 c0074b8:	f896 00a8 	ldrb.w	r0, [r6, #168]	; 0xa8
 c0074bc:	f7ff fa44 	bl	c006948 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 c0074c0:	4680      	mov	r8, r0
 c0074c2:	2800      	cmp	r0, #0
 c0074c4:	d0ec      	beq.n	c0074a0 <mbedtls_rsa_rsaes_oaep_decrypt+0x18>
    hlen = mbedtls_md_get_size( md_info );
 c0074c6:	f7ff fabb 	bl	c006a40 <mbedtls_md_get_size>
    if( 2 * hlen + 2 > ilen )
 c0074ca:	1c47      	adds	r7, r0, #1
 c0074cc:	007b      	lsls	r3, r7, #1
 c0074ce:	ebb4 0f47 	cmp.w	r4, r7, lsl #1
    hlen = mbedtls_md_get_size( md_info );
 c0074d2:	4605      	mov	r5, r0
    if( 2 * hlen + 2 > ilen )
 c0074d4:	9302      	str	r3, [sp, #8]
 c0074d6:	d3e3      	bcc.n	c0074a0 <mbedtls_rsa_rsaes_oaep_decrypt+0x18>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c0074d8:	9a03      	ldr	r2, [sp, #12]
 c0074da:	f10d 0940 	add.w	r9, sp, #64	; 0x40
 c0074de:	f1ba 0f00 	cmp.w	sl, #0
 c0074e2:	d11e      	bne.n	c007522 <mbedtls_rsa_rsaes_oaep_decrypt+0x9a>
          ? mbedtls_rsa_public(  ctx, input, buf )
 c0074e4:	464a      	mov	r2, r9
 c0074e6:	4630      	mov	r0, r6
 c0074e8:	997d      	ldr	r1, [sp, #500]	; 0x1f4
 c0074ea:	f7ff fdd1 	bl	c007090 <mbedtls_rsa_public>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c0074ee:	4606      	mov	r6, r0
    if( ret != 0 )
 c0074f0:	b960      	cbnz	r0, c00750c <mbedtls_rsa_rsaes_oaep_decrypt+0x84>
    mbedtls_md_init( &md_ctx );
 c0074f2:	a805      	add	r0, sp, #20
 c0074f4:	f7ff fa36 	bl	c006964 <mbedtls_md_init>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 c0074f8:	4632      	mov	r2, r6
 c0074fa:	4641      	mov	r1, r8
 c0074fc:	a805      	add	r0, sp, #20
 c0074fe:	f7ff fa51 	bl	c0069a4 <mbedtls_md_setup>
 c007502:	4606      	mov	r6, r0
 c007504:	b1a8      	cbz	r0, c007532 <mbedtls_rsa_rsaes_oaep_decrypt+0xaa>
        mbedtls_md_free( &md_ctx );
 c007506:	a805      	add	r0, sp, #20
 c007508:	f7ff fa31 	bl	c00696e <mbedtls_md_free>
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 c00750c:	a810      	add	r0, sp, #64	; 0x40
 c00750e:	f44f 71c0 	mov.w	r1, #384	; 0x180
 c007512:	f7ff fc5f 	bl	c006dd4 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( lhash, sizeof( lhash ) );
 c007516:	2120      	movs	r1, #32
 c007518:	eb0d 0001 	add.w	r0, sp, r1
 c00751c:	f7ff fc5a 	bl	c006dd4 <mbedtls_platform_zeroize>
    return( ret );
 c007520:	e7bf      	b.n	c0074a2 <mbedtls_rsa_rsaes_oaep_decrypt+0x1a>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c007522:	4659      	mov	r1, fp
 c007524:	4630      	mov	r0, r6
 c007526:	9b7d      	ldr	r3, [sp, #500]	; 0x1f4
 c007528:	f8cd 9000 	str.w	r9, [sp]
 c00752c:	f7ff fdf0 	bl	c007110 <mbedtls_rsa_private>
 c007530:	e7dd      	b.n	c0074ee <mbedtls_rsa_rsaes_oaep_decrypt+0x66>
    if( ( ret = mgf_mask( buf + 1, hlen, buf + hlen + 1, ilen - hlen - 1,
 c007532:	f104 3aff 	add.w	sl, r4, #4294967295
 c007536:	ab05      	add	r3, sp, #20
 c007538:	444f      	add	r7, r9
 c00753a:	ebaa 0a05 	sub.w	sl, sl, r5
 c00753e:	9300      	str	r3, [sp, #0]
 c007540:	463a      	mov	r2, r7
 c007542:	4653      	mov	r3, sl
 c007544:	4629      	mov	r1, r5
 c007546:	f10d 0041 	add.w	r0, sp, #65	; 0x41
 c00754a:	f7ff fc4b 	bl	c006de4 <mgf_mask>
 c00754e:	4606      	mov	r6, r0
 c007550:	2800      	cmp	r0, #0
 c007552:	d1d8      	bne.n	c007506 <mbedtls_rsa_rsaes_oaep_decrypt+0x7e>
        ( ret = mgf_mask( buf + hlen + 1, ilen - hlen - 1, buf + 1, hlen,
 c007554:	ab05      	add	r3, sp, #20
 c007556:	9300      	str	r3, [sp, #0]
 c007558:	4651      	mov	r1, sl
 c00755a:	462b      	mov	r3, r5
 c00755c:	4638      	mov	r0, r7
 c00755e:	f10d 0241 	add.w	r2, sp, #65	; 0x41
 c007562:	f7ff fc3f 	bl	c006de4 <mgf_mask>
                          &md_ctx ) ) != 0 ||
 c007566:	4606      	mov	r6, r0
 c007568:	2800      	cmp	r0, #0
 c00756a:	d1cc      	bne.n	c007506 <mbedtls_rsa_rsaes_oaep_decrypt+0x7e>
    mbedtls_md_free( &md_ctx );
 c00756c:	a805      	add	r0, sp, #20
    if( ( ret = mbedtls_md( md_info, label, label_len, lhash ) ) != 0 )
 c00756e:	af08      	add	r7, sp, #32
    mbedtls_md_free( &md_ctx );
 c007570:	f7ff f9fd 	bl	c00696e <mbedtls_md_free>
    if( ( ret = mbedtls_md( md_info, label, label_len, lhash ) ) != 0 )
 c007574:	e9dd 127a 	ldrd	r1, r2, [sp, #488]	; 0x1e8
 c007578:	463b      	mov	r3, r7
 c00757a:	4640      	mov	r0, r8
 c00757c:	f7ff fa50 	bl	c006a20 <mbedtls_md>
 c007580:	4606      	mov	r6, r0
 c007582:	2800      	cmp	r0, #0
 c007584:	d1c2      	bne.n	c00750c <mbedtls_rsa_rsaes_oaep_decrypt+0x84>
    p += hlen; /* Skip seed */
 c007586:	f10d 0341 	add.w	r3, sp, #65	; 0x41
 c00758a:	1959      	adds	r1, r3, r5
    for( i = 0; i < hlen; i++ )
 c00758c:	4603      	mov	r3, r0
    bad |= *p++; /* First byte must be 0 */
 c00758e:	f899 2000 	ldrb.w	r2, [r9]
    for( i = 0; i < hlen; i++ )
 c007592:	42ab      	cmp	r3, r5
 c007594:	fa4f fc82 	sxtb.w	ip, r2
 c007598:	d320      	bcc.n	c0075dc <mbedtls_rsa_rsaes_oaep_decrypt+0x154>
    pad_done = 0;
 c00759a:	2000      	movs	r0, #0
 c00759c:	440d      	add	r5, r1
 c00759e:	462f      	mov	r7, r5
    pad_len = 0;
 c0075a0:	4601      	mov	r1, r0
    for( i = 0; i < ilen - 2 * hlen - 2; i++ )
 c0075a2:	9b02      	ldr	r3, [sp, #8]
 c0075a4:	1ae2      	subs	r2, r4, r3
 c0075a6:	442a      	add	r2, r5
 c0075a8:	42ba      	cmp	r2, r7
 c0075aa:	d11f      	bne.n	c0075ec <mbedtls_rsa_rsaes_oaep_decrypt+0x164>
    bad |= *p++ ^ 0x01;
 c0075ac:	5c6a      	ldrb	r2, [r5, r1]
 c0075ae:	f082 0201 	eor.w	r2, r2, #1
 c0075b2:	ea4c 0202 	orr.w	r2, ip, r2
    if( bad != 0 )
 c0075b6:	f012 0fff 	tst.w	r2, #255	; 0xff
 c0075ba:	d122      	bne.n	c007602 <mbedtls_rsa_rsaes_oaep_decrypt+0x17a>
    bad |= *p++ ^ 0x01;
 c0075bc:	3101      	adds	r1, #1
 c0075be:	4429      	add	r1, r5
    if( ilen - ( p - buf ) > output_max_len )
 c0075c0:	aa10      	add	r2, sp, #64	; 0x40
 c0075c2:	9b7f      	ldr	r3, [sp, #508]	; 0x1fc
 c0075c4:	1a8a      	subs	r2, r1, r2
 c0075c6:	1aa2      	subs	r2, r4, r2
 c0075c8:	429a      	cmp	r2, r3
 c0075ca:	d81c      	bhi.n	c007606 <mbedtls_rsa_rsaes_oaep_decrypt+0x17e>
    *olen = ilen - (p - buf);
 c0075cc:	9b7c      	ldr	r3, [sp, #496]	; 0x1f0
 c0075ce:	601a      	str	r2, [r3, #0]
    if( *olen != 0 )
 c0075d0:	2a00      	cmp	r2, #0
 c0075d2:	d09b      	beq.n	c00750c <mbedtls_rsa_rsaes_oaep_decrypt+0x84>
        memcpy( output, p, *olen );
 c0075d4:	987e      	ldr	r0, [sp, #504]	; 0x1f8
 c0075d6:	f001 fad9 	bl	c008b8c <memcpy>
 c0075da:	e797      	b.n	c00750c <mbedtls_rsa_rsaes_oaep_decrypt+0x84>
        bad |= lhash[i] ^ *p++;
 c0075dc:	5cfa      	ldrb	r2, [r7, r3]
 c0075de:	5cc8      	ldrb	r0, [r1, r3]
    for( i = 0; i < hlen; i++ )
 c0075e0:	3301      	adds	r3, #1
        bad |= lhash[i] ^ *p++;
 c0075e2:	4042      	eors	r2, r0
 c0075e4:	ea4c 0202 	orr.w	r2, ip, r2
 c0075e8:	b2d2      	uxtb	r2, r2
    for( i = 0; i < hlen; i++ )
 c0075ea:	e7d2      	b.n	c007592 <mbedtls_rsa_rsaes_oaep_decrypt+0x10a>
        pad_done |= p[i];
 c0075ec:	f817 3b01 	ldrb.w	r3, [r7], #1
 c0075f0:	4318      	orrs	r0, r3
        pad_len += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
 c0075f2:	4243      	negs	r3, r0
 c0075f4:	4303      	orrs	r3, r0
 c0075f6:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 c0075fa:	f083 0301 	eor.w	r3, r3, #1
 c0075fe:	4419      	add	r1, r3
    for( i = 0; i < ilen - 2 * hlen - 2; i++ )
 c007600:	e7d2      	b.n	c0075a8 <mbedtls_rsa_rsaes_oaep_decrypt+0x120>
        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
 c007602:	4e03      	ldr	r6, [pc, #12]	; (c007610 <mbedtls_rsa_rsaes_oaep_decrypt+0x188>)
 c007604:	e782      	b.n	c00750c <mbedtls_rsa_rsaes_oaep_decrypt+0x84>
        ret = MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
 c007606:	4e03      	ldr	r6, [pc, #12]	; (c007614 <mbedtls_rsa_rsaes_oaep_decrypt+0x18c>)
 c007608:	e780      	b.n	c00750c <mbedtls_rsa_rsaes_oaep_decrypt+0x84>
 c00760a:	bf00      	nop
 c00760c:	ffffbf80 	.word	0xffffbf80
 c007610:	ffffbf00 	.word	0xffffbf00
 c007614:	ffffbc00 	.word	0xffffbc00

0c007618 <mbedtls_rsa_free>:

/*
 * Free the components of an RSA key
 */
void mbedtls_rsa_free( mbedtls_rsa_context *ctx )
{
 c007618:	b510      	push	{r4, lr}
    if( ctx == NULL )
 c00761a:	4604      	mov	r4, r0
 c00761c:	b3a0      	cbz	r0, c007688 <mbedtls_rsa_free+0x70>
        return;

    mbedtls_mpi_free( &ctx->Vi );
 c00761e:	308c      	adds	r0, #140	; 0x8c
 c007620:	f7fd ff47 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->Vf );
 c007624:	f104 0098 	add.w	r0, r4, #152	; 0x98
 c007628:	f7fd ff43 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->RN );
 c00762c:	f104 0068 	add.w	r0, r4, #104	; 0x68
 c007630:	f7fd ff3f 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->D  );
 c007634:	f104 0020 	add.w	r0, r4, #32
 c007638:	f7fd ff3b 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->Q  );
 c00763c:	f104 0038 	add.w	r0, r4, #56	; 0x38
 c007640:	f7fd ff37 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->P  );
 c007644:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 c007648:	f7fd ff33 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->E  );
 c00764c:	f104 0014 	add.w	r0, r4, #20
 c007650:	f7fd ff2f 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->N  );
 c007654:	f104 0008 	add.w	r0, r4, #8
 c007658:	f7fd ff2b 	bl	c0054b2 <mbedtls_mpi_free>

#if !defined(MBEDTLS_RSA_NO_CRT)
    mbedtls_mpi_free( &ctx->RQ );
 c00765c:	f104 0080 	add.w	r0, r4, #128	; 0x80
 c007660:	f7fd ff27 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->RP );
 c007664:	f104 0074 	add.w	r0, r4, #116	; 0x74
 c007668:	f7fd ff23 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->QP );
 c00766c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 c007670:	f7fd ff1f 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->DQ );
 c007674:	f104 0050 	add.w	r0, r4, #80	; 0x50
 c007678:	f7fd ff1b 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->DP );
 c00767c:	f104 0044 	add.w	r0, r4, #68	; 0x44
#endif /* MBEDTLS_RSA_NO_CRT */

#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_free( &ctx->mutex );
#endif
}
 c007680:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_mpi_free( &ctx->DP );
 c007684:	f7fd bf15 	b.w	c0054b2 <mbedtls_mpi_free>
}
 c007688:	bd10      	pop	{r4, pc}
	...

0c00768c <mbedtls_rsa_validate_crt>:
 * Check that RSA CRT parameters are in accordance with core parameters.
 */
int mbedtls_rsa_validate_crt( const mbedtls_mpi *P,  const mbedtls_mpi *Q,
                              const mbedtls_mpi *D,  const mbedtls_mpi *DP,
                              const mbedtls_mpi *DQ, const mbedtls_mpi *QP )
{
 c00768c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c007690:	4699      	mov	r9, r3
 c007692:	b087      	sub	sp, #28
 c007694:	4604      	mov	r4, r0
 c007696:	e9dd 860e 	ldrd	r8, r6, [sp, #56]	; 0x38
    int ret = 0;

    mbedtls_mpi K, L;
    mbedtls_mpi_init( &K );
 c00769a:	4668      	mov	r0, sp
{
 c00769c:	460d      	mov	r5, r1
 c00769e:	4617      	mov	r7, r2
    mbedtls_mpi_init( &K );
 c0076a0:	f7fd ff01 	bl	c0054a6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 c0076a4:	a803      	add	r0, sp, #12
 c0076a6:	f7fd fefe 	bl	c0054a6 <mbedtls_mpi_init>

    /* Check that DP - D == 0 mod P - 1 */
    if( DP != NULL )
 c0076aa:	f1b9 0f00 	cmp.w	r9, #0
 c0076ae:	d106      	bne.n	c0076be <mbedtls_rsa_validate_crt+0x32>
            goto cleanup;
        }
    }

    /* Check that DQ - D == 0 mod Q - 1 */
    if( DQ != NULL )
 c0076b0:	f1b8 0f00 	cmp.w	r8, #0
 c0076b4:	d12c      	bne.n	c007710 <mbedtls_rsa_validate_crt+0x84>
            goto cleanup;
        }
    }

    /* Check that QP * Q - 1 == 0 mod P */
    if( QP != NULL )
 c0076b6:	2e00      	cmp	r6, #0
 c0076b8:	d145      	bne.n	c007746 <mbedtls_rsa_validate_crt+0xba>
            goto cleanup;
        }

        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, QP, Q ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, P ) );
 c0076ba:	2400      	movs	r4, #0
 c0076bc:	e001      	b.n	c0076c2 <mbedtls_rsa_validate_crt+0x36>
        if( P == NULL )
 c0076be:	b954      	cbnz	r4, c0076d6 <mbedtls_rsa_validate_crt+0x4a>
            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c0076c0:	4c34      	ldr	r4, [pc, #208]	; (c007794 <mbedtls_rsa_validate_crt+0x108>)
        ret != MBEDTLS_ERR_RSA_BAD_INPUT_DATA )
    {
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
    }

    mbedtls_mpi_free( &K );
 c0076c2:	4668      	mov	r0, sp
 c0076c4:	f7fd fef5 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 c0076c8:	a803      	add	r0, sp, #12
 c0076ca:	f7fd fef2 	bl	c0054b2 <mbedtls_mpi_free>

    return( ret );
}
 c0076ce:	4620      	mov	r0, r4
 c0076d0:	b007      	add	sp, #28
 c0076d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1 ) );
 c0076d6:	2201      	movs	r2, #1
 c0076d8:	4621      	mov	r1, r4
 c0076da:	4668      	mov	r0, sp
 c0076dc:	f7fe fa7c 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c0076e0:	2800      	cmp	r0, #0
 c0076e2:	d14d      	bne.n	c007780 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &L, DP, D ) );
 c0076e4:	463a      	mov	r2, r7
 c0076e6:	4649      	mov	r1, r9
 c0076e8:	a803      	add	r0, sp, #12
 c0076ea:	f7fe fa52 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c0076ee:	2800      	cmp	r0, #0
 c0076f0:	d146      	bne.n	c007780 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &L, &L, &K ) );
 c0076f2:	a903      	add	r1, sp, #12
 c0076f4:	466a      	mov	r2, sp
 c0076f6:	4608      	mov	r0, r1
 c0076f8:	f7fe fcb1 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c0076fc:	2800      	cmp	r0, #0
 c0076fe:	d13f      	bne.n	c007780 <mbedtls_rsa_validate_crt+0xf4>
        if( mbedtls_mpi_cmp_int( &L, 0 ) != 0 )
 c007700:	4601      	mov	r1, r0
 c007702:	a803      	add	r0, sp, #12
 c007704:	f7fe f977 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c007708:	2800      	cmp	r0, #0
 c00770a:	d0d1      	beq.n	c0076b0 <mbedtls_rsa_validate_crt+0x24>
            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c00770c:	4c22      	ldr	r4, [pc, #136]	; (c007798 <mbedtls_rsa_validate_crt+0x10c>)
 c00770e:	e7d8      	b.n	c0076c2 <mbedtls_rsa_validate_crt+0x36>
        if( Q == NULL )
 c007710:	2d00      	cmp	r5, #0
 c007712:	d0d5      	beq.n	c0076c0 <mbedtls_rsa_validate_crt+0x34>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1 ) );
 c007714:	2201      	movs	r2, #1
 c007716:	4629      	mov	r1, r5
 c007718:	4668      	mov	r0, sp
 c00771a:	f7fe fa5d 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c00771e:	bb78      	cbnz	r0, c007780 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &L, DQ, D ) );
 c007720:	463a      	mov	r2, r7
 c007722:	4641      	mov	r1, r8
 c007724:	a803      	add	r0, sp, #12
 c007726:	f7fe fa34 	bl	c005b92 <mbedtls_mpi_sub_mpi>
 c00772a:	bb48      	cbnz	r0, c007780 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &L, &L, &K ) );
 c00772c:	a903      	add	r1, sp, #12
 c00772e:	466a      	mov	r2, sp
 c007730:	4608      	mov	r0, r1
 c007732:	f7fe fc94 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c007736:	bb18      	cbnz	r0, c007780 <mbedtls_rsa_validate_crt+0xf4>
        if( mbedtls_mpi_cmp_int( &L, 0 ) != 0 )
 c007738:	4601      	mov	r1, r0
 c00773a:	a803      	add	r0, sp, #12
 c00773c:	f7fe f95b 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c007740:	2800      	cmp	r0, #0
 c007742:	d0b8      	beq.n	c0076b6 <mbedtls_rsa_validate_crt+0x2a>
 c007744:	e7e2      	b.n	c00770c <mbedtls_rsa_validate_crt+0x80>
        if( P == NULL || Q == NULL )
 c007746:	2c00      	cmp	r4, #0
 c007748:	d0ba      	beq.n	c0076c0 <mbedtls_rsa_validate_crt+0x34>
 c00774a:	2d00      	cmp	r5, #0
 c00774c:	d0b8      	beq.n	c0076c0 <mbedtls_rsa_validate_crt+0x34>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, QP, Q ) );
 c00774e:	462a      	mov	r2, r5
 c007750:	4631      	mov	r1, r6
 c007752:	4668      	mov	r0, sp
 c007754:	f7fe fa56 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c007758:	b990      	cbnz	r0, c007780 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 c00775a:	2201      	movs	r2, #1
 c00775c:	4669      	mov	r1, sp
 c00775e:	4668      	mov	r0, sp
 c007760:	f7fe fa3a 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c007764:	b960      	cbnz	r0, c007780 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, P ) );
 c007766:	4622      	mov	r2, r4
 c007768:	4669      	mov	r1, sp
 c00776a:	4668      	mov	r0, sp
 c00776c:	f7fe fc77 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c007770:	b930      	cbnz	r0, c007780 <mbedtls_rsa_validate_crt+0xf4>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 c007772:	4601      	mov	r1, r0
 c007774:	4668      	mov	r0, sp
 c007776:	f7fe f93e 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c00777a:	2800      	cmp	r0, #0
 c00777c:	d09d      	beq.n	c0076ba <mbedtls_rsa_validate_crt+0x2e>
 c00777e:	e7c5      	b.n	c00770c <mbedtls_rsa_validate_crt+0x80>
    if( ret != 0 &&
 c007780:	f510 4f84 	cmn.w	r0, #16896	; 0x4200
 c007784:	d0c2      	beq.n	c00770c <mbedtls_rsa_validate_crt+0x80>
        ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED &&
 c007786:	f510 4f81 	cmn.w	r0, #16512	; 0x4080
 c00778a:	d099      	beq.n	c0076c0 <mbedtls_rsa_validate_crt+0x34>
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c00778c:	f5a0 4484 	sub.w	r4, r0, #16896	; 0x4200
 c007790:	e797      	b.n	c0076c2 <mbedtls_rsa_validate_crt+0x36>
 c007792:	bf00      	nop
 c007794:	ffffbf80 	.word	0xffffbf80
 c007798:	ffffbe00 	.word	0xffffbe00

0c00779c <mbedtls_rsa_validate_params>:
int mbedtls_rsa_validate_params( const mbedtls_mpi *N, const mbedtls_mpi *P,
                                 const mbedtls_mpi *Q, const mbedtls_mpi *D,
                                 const mbedtls_mpi *E,
                                 int (*f_rng)(void *, unsigned char *, size_t),
                                 void *p_rng )
{
 c00779c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c0077a0:	4688      	mov	r8, r1
 c0077a2:	b087      	sub	sp, #28
 c0077a4:	4681      	mov	r9, r0
    int ret = 0;
    mbedtls_mpi K, L;

    mbedtls_mpi_init( &K );
 c0077a6:	4668      	mov	r0, sp
{
 c0077a8:	4615      	mov	r5, r2
 c0077aa:	461e      	mov	r6, r3
 c0077ac:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    mbedtls_mpi_init( &K );
 c0077ae:	f7fd fe7a 	bl	c0054a6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 c0077b2:	a803      	add	r0, sp, #12
 c0077b4:	f7fd fe77 	bl	c0054a6 <mbedtls_mpi_init>

    /*
     * Step 2: Check that 1 < N = P * Q
     */

    if( P != NULL && Q != NULL && N != NULL )
 c0077b8:	f1b8 0f00 	cmp.w	r8, #0
 c0077bc:	d077      	beq.n	c0078ae <mbedtls_rsa_validate_params+0x112>
 c0077be:	2d00      	cmp	r5, #0
 c0077c0:	f000 80a9 	beq.w	c007916 <mbedtls_rsa_validate_params+0x17a>
 c0077c4:	f1b9 0f00 	cmp.w	r9, #0
 c0077c8:	d15d      	bne.n	c007886 <mbedtls_rsa_validate_params+0xea>

    /*
     * Step 4: Check that D, E are inverse modulo P-1 and Q-1
     */

    if( P != NULL && Q != NULL && D != NULL && E != NULL )
 c0077ca:	2e00      	cmp	r6, #0
 c0077cc:	f000 8092 	beq.w	c0078f4 <mbedtls_rsa_validate_params+0x158>
 c0077d0:	2f00      	cmp	r7, #0
 c0077d2:	f000 808f 	beq.w	c0078f4 <mbedtls_rsa_validate_params+0x158>
    {
        if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 c0077d6:	2101      	movs	r1, #1
 c0077d8:	4640      	mov	r0, r8
 c0077da:	f7fe f90c 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c0077de:	2800      	cmp	r0, #0
 c0077e0:	dd63      	ble.n	c0078aa <mbedtls_rsa_validate_params+0x10e>
            mbedtls_mpi_cmp_int( Q, 1 ) <= 0 )
 c0077e2:	2101      	movs	r1, #1
 c0077e4:	4628      	mov	r0, r5
 c0077e6:	f7fe f906 	bl	c0059f6 <mbedtls_mpi_cmp_int>
        if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 c0077ea:	2800      	cmp	r0, #0
 c0077ec:	dd5d      	ble.n	c0078aa <mbedtls_rsa_validate_params+0x10e>
            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
            goto cleanup;
        }

        /* Compute DE-1 mod P-1 */
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, D, E ) );
 c0077ee:	463a      	mov	r2, r7
 c0077f0:	4631      	mov	r1, r6
 c0077f2:	4668      	mov	r0, sp
 c0077f4:	f7fe fa06 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c0077f8:	4604      	mov	r4, r0
 c0077fa:	2800      	cmp	r0, #0
 c0077fc:	d17b      	bne.n	c0078f6 <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 c0077fe:	2201      	movs	r2, #1
 c007800:	4669      	mov	r1, sp
 c007802:	4668      	mov	r0, sp
 c007804:	f7fe f9e8 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c007808:	4604      	mov	r4, r0
 c00780a:	2800      	cmp	r0, #0
 c00780c:	d173      	bne.n	c0078f6 <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, P, 1 ) );
 c00780e:	2201      	movs	r2, #1
 c007810:	4641      	mov	r1, r8
 c007812:	a803      	add	r0, sp, #12
 c007814:	f7fe f9e0 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c007818:	4604      	mov	r4, r0
 c00781a:	2800      	cmp	r0, #0
 c00781c:	d16b      	bne.n	c0078f6 <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
 c00781e:	4669      	mov	r1, sp
 c007820:	4668      	mov	r0, sp
 c007822:	aa03      	add	r2, sp, #12
 c007824:	f7fe fc1b 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c007828:	4604      	mov	r4, r0
 c00782a:	2800      	cmp	r0, #0
 c00782c:	d163      	bne.n	c0078f6 <mbedtls_rsa_validate_params+0x15a>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 c00782e:	4601      	mov	r1, r0
 c007830:	4668      	mov	r0, sp
 c007832:	f7fe f8e0 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c007836:	2800      	cmp	r0, #0
 c007838:	d137      	bne.n	c0078aa <mbedtls_rsa_validate_params+0x10e>
            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
            goto cleanup;
        }

        /* Compute DE-1 mod Q-1 */
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, D, E ) );
 c00783a:	463a      	mov	r2, r7
 c00783c:	4631      	mov	r1, r6
 c00783e:	4668      	mov	r0, sp
 c007840:	f7fe f9e0 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c007844:	4604      	mov	r4, r0
 c007846:	2800      	cmp	r0, #0
 c007848:	d155      	bne.n	c0078f6 <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 c00784a:	2201      	movs	r2, #1
 c00784c:	4669      	mov	r1, sp
 c00784e:	4668      	mov	r0, sp
 c007850:	f7fe f9c2 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c007854:	4604      	mov	r4, r0
 c007856:	2800      	cmp	r0, #0
 c007858:	d14d      	bne.n	c0078f6 <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, Q, 1 ) );
 c00785a:	2201      	movs	r2, #1
 c00785c:	4629      	mov	r1, r5
 c00785e:	a803      	add	r0, sp, #12
 c007860:	f7fe f9ba 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c007864:	4604      	mov	r4, r0
 c007866:	2800      	cmp	r0, #0
 c007868:	d145      	bne.n	c0078f6 <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
 c00786a:	4669      	mov	r1, sp
 c00786c:	4668      	mov	r0, sp
 c00786e:	aa03      	add	r2, sp, #12
 c007870:	f7fe fbf5 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c007874:	4604      	mov	r4, r0
 c007876:	2800      	cmp	r0, #0
 c007878:	d13d      	bne.n	c0078f6 <mbedtls_rsa_validate_params+0x15a>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 c00787a:	4601      	mov	r1, r0
 c00787c:	4668      	mov	r0, sp
 c00787e:	f7fe f8ba 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c007882:	b3b8      	cbz	r0, c0078f4 <mbedtls_rsa_validate_params+0x158>
 c007884:	e011      	b.n	c0078aa <mbedtls_rsa_validate_params+0x10e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, P, Q ) );
 c007886:	462a      	mov	r2, r5
 c007888:	4641      	mov	r1, r8
 c00788a:	4668      	mov	r0, sp
 c00788c:	f7fe f9ba 	bl	c005c04 <mbedtls_mpi_mul_mpi>
 c007890:	4604      	mov	r4, r0
 c007892:	bb80      	cbnz	r0, c0078f6 <mbedtls_rsa_validate_params+0x15a>
        if( mbedtls_mpi_cmp_int( N, 1 )  <= 0 ||
 c007894:	2101      	movs	r1, #1
 c007896:	4648      	mov	r0, r9
 c007898:	f7fe f8ad 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c00789c:	2800      	cmp	r0, #0
 c00789e:	dd04      	ble.n	c0078aa <mbedtls_rsa_validate_params+0x10e>
            mbedtls_mpi_cmp_mpi( &K, N ) != 0 )
 c0078a0:	4649      	mov	r1, r9
 c0078a2:	4668      	mov	r0, sp
 c0078a4:	f7fe f864 	bl	c005970 <mbedtls_mpi_cmp_mpi>
        if( mbedtls_mpi_cmp_int( N, 1 )  <= 0 ||
 c0078a8:	b3c0      	cbz	r0, c00791c <mbedtls_rsa_validate_params+0x180>
        {
            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c0078aa:	4c1e      	ldr	r4, [pc, #120]	; (c007924 <mbedtls_rsa_validate_params+0x188>)
            goto cleanup;
 c0078ac:	e023      	b.n	c0078f6 <mbedtls_rsa_validate_params+0x15a>
    if( N != NULL && D != NULL && E != NULL )
 c0078ae:	f1b9 0f00 	cmp.w	r9, #0
 c0078b2:	d01f      	beq.n	c0078f4 <mbedtls_rsa_validate_params+0x158>
 c0078b4:	b1f6      	cbz	r6, c0078f4 <mbedtls_rsa_validate_params+0x158>
 c0078b6:	b1bf      	cbz	r7, c0078e8 <mbedtls_rsa_validate_params+0x14c>
        if ( mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 c0078b8:	2101      	movs	r1, #1
 c0078ba:	4630      	mov	r0, r6
 c0078bc:	f7fe f89b 	bl	c0059f6 <mbedtls_mpi_cmp_int>
 c0078c0:	2800      	cmp	r0, #0
 c0078c2:	ddf2      	ble.n	c0078aa <mbedtls_rsa_validate_params+0x10e>
             mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 c0078c4:	2101      	movs	r1, #1
 c0078c6:	4638      	mov	r0, r7
 c0078c8:	f7fe f895 	bl	c0059f6 <mbedtls_mpi_cmp_int>
        if ( mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 c0078cc:	2800      	cmp	r0, #0
 c0078ce:	ddec      	ble.n	c0078aa <mbedtls_rsa_validate_params+0x10e>
             mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 c0078d0:	4649      	mov	r1, r9
 c0078d2:	4630      	mov	r0, r6
 c0078d4:	f7fe f84c 	bl	c005970 <mbedtls_mpi_cmp_mpi>
             mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 c0078d8:	2800      	cmp	r0, #0
 c0078da:	dae6      	bge.n	c0078aa <mbedtls_rsa_validate_params+0x10e>
             mbedtls_mpi_cmp_mpi( E, N ) >= 0 )
 c0078dc:	4649      	mov	r1, r9
 c0078de:	4638      	mov	r0, r7
 c0078e0:	f7fe f846 	bl	c005970 <mbedtls_mpi_cmp_mpi>
             mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 c0078e4:	2800      	cmp	r0, #0
 c0078e6:	dae0      	bge.n	c0078aa <mbedtls_rsa_validate_params+0x10e>
    if( P != NULL && Q != NULL && D != NULL && E != NULL )
 c0078e8:	f1b8 0f00 	cmp.w	r8, #0
 c0078ec:	d002      	beq.n	c0078f4 <mbedtls_rsa_validate_params+0x158>
 c0078ee:	2d00      	cmp	r5, #0
 c0078f0:	f47f af6b 	bne.w	c0077ca <mbedtls_rsa_validate_params+0x2e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
 c0078f4:	2400      	movs	r4, #0
        }
    }

cleanup:

    mbedtls_mpi_free( &K );
 c0078f6:	4668      	mov	r0, sp
 c0078f8:	f7fd fddb 	bl	c0054b2 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 c0078fc:	a803      	add	r0, sp, #12
 c0078fe:	f7fd fdd8 	bl	c0054b2 <mbedtls_mpi_free>

    /* Wrap MPI error codes by RSA check failure error code */
    if( ret != 0 && ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED )
 c007902:	b124      	cbz	r4, c00790e <mbedtls_rsa_validate_params+0x172>
 c007904:	f514 4f84 	cmn.w	r4, #16896	; 0x4200
 c007908:	d001      	beq.n	c00790e <mbedtls_rsa_validate_params+0x172>
    {
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c00790a:	f5a4 4484 	sub.w	r4, r4, #16896	; 0x4200
    }

    return( ret );
}
 c00790e:	4620      	mov	r0, r4
 c007910:	b007      	add	sp, #28
 c007912:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( N != NULL && D != NULL && E != NULL )
 c007916:	f1b9 0f00 	cmp.w	r9, #0
 c00791a:	d0eb      	beq.n	c0078f4 <mbedtls_rsa_validate_params+0x158>
 c00791c:	2e00      	cmp	r6, #0
 c00791e:	d1ca      	bne.n	c0078b6 <mbedtls_rsa_validate_params+0x11a>
 c007920:	e7e5      	b.n	c0078ee <mbedtls_rsa_validate_params+0x152>
 c007922:	bf00      	nop
 c007924:	ffffbe00 	.word	0xffffbe00

0c007928 <mbedtls_rsa_deduce_crt>:

int mbedtls_rsa_deduce_crt( const mbedtls_mpi *P, const mbedtls_mpi *Q,
                            const mbedtls_mpi *D, mbedtls_mpi *DP,
                            mbedtls_mpi *DQ, mbedtls_mpi *QP )
{
 c007928:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 c00792c:	469a      	mov	sl, r3
 c00792e:	e9dd 980c 	ldrd	r9, r8, [sp, #48]	; 0x30
 c007932:	4606      	mov	r6, r0
    int ret = 0;
    mbedtls_mpi K;
    mbedtls_mpi_init( &K );
 c007934:	a801      	add	r0, sp, #4
{
 c007936:	460d      	mov	r5, r1
 c007938:	4617      	mov	r7, r2
    mbedtls_mpi_init( &K );
 c00793a:	f7fd fdb4 	bl	c0054a6 <mbedtls_mpi_init>

    /* DP = D mod P-1 */
    if( DP != NULL )
 c00793e:	f1ba 0f00 	cmp.w	sl, #0
 c007942:	d107      	bne.n	c007954 <mbedtls_rsa_deduce_crt+0x2c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1  ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DP, D, &K ) );
    }

    /* DQ = D mod Q-1 */
    if( DQ != NULL )
 c007944:	f1b9 0f00 	cmp.w	r9, #0
 c007948:	d11a      	bne.n	c007980 <mbedtls_rsa_deduce_crt+0x58>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1  ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DQ, D, &K ) );
    }

    /* QP = Q^{-1} mod P */
    if( QP != NULL )
 c00794a:	f1b8 0f00 	cmp.w	r8, #0
 c00794e:	d128      	bne.n	c0079a2 <mbedtls_rsa_deduce_crt+0x7a>
    {
        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( QP, Q, P ) );
    }

cleanup:
 c007950:	4644      	mov	r4, r8
 c007952:	e00e      	b.n	c007972 <mbedtls_rsa_deduce_crt+0x4a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1  ) );
 c007954:	2201      	movs	r2, #1
 c007956:	4631      	mov	r1, r6
 c007958:	a801      	add	r0, sp, #4
 c00795a:	f7fe f93d 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c00795e:	4604      	mov	r4, r0
 c007960:	b938      	cbnz	r0, c007972 <mbedtls_rsa_deduce_crt+0x4a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DP, D, &K ) );
 c007962:	4639      	mov	r1, r7
 c007964:	4650      	mov	r0, sl
 c007966:	aa01      	add	r2, sp, #4
 c007968:	f7fe fb79 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c00796c:	4604      	mov	r4, r0
 c00796e:	2800      	cmp	r0, #0
 c007970:	d0e8      	beq.n	c007944 <mbedtls_rsa_deduce_crt+0x1c>
    mbedtls_mpi_free( &K );
 c007972:	a801      	add	r0, sp, #4
 c007974:	f7fd fd9d 	bl	c0054b2 <mbedtls_mpi_free>

    return( ret );
}
 c007978:	4620      	mov	r0, r4
 c00797a:	b004      	add	sp, #16
 c00797c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1  ) );
 c007980:	2201      	movs	r2, #1
 c007982:	4629      	mov	r1, r5
 c007984:	a801      	add	r0, sp, #4
 c007986:	f7fe f927 	bl	c005bd8 <mbedtls_mpi_sub_int>
 c00798a:	4604      	mov	r4, r0
 c00798c:	2800      	cmp	r0, #0
 c00798e:	d1f0      	bne.n	c007972 <mbedtls_rsa_deduce_crt+0x4a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DQ, D, &K ) );
 c007990:	4639      	mov	r1, r7
 c007992:	4648      	mov	r0, r9
 c007994:	aa01      	add	r2, sp, #4
 c007996:	f7fe fb62 	bl	c00605e <mbedtls_mpi_mod_mpi>
 c00799a:	4604      	mov	r4, r0
 c00799c:	2800      	cmp	r0, #0
 c00799e:	d0d4      	beq.n	c00794a <mbedtls_rsa_deduce_crt+0x22>
 c0079a0:	e7e7      	b.n	c007972 <mbedtls_rsa_deduce_crt+0x4a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( QP, Q, P ) );
 c0079a2:	4632      	mov	r2, r6
 c0079a4:	4629      	mov	r1, r5
 c0079a6:	4640      	mov	r0, r8
 c0079a8:	f7fe fe72 	bl	c006690 <mbedtls_mpi_inv_mod>
 c0079ac:	4604      	mov	r4, r0
cleanup:
 c0079ae:	e7e0      	b.n	c007972 <mbedtls_rsa_deduce_crt+0x4a>

0c0079b0 <mbedtls_sha256_ret>:
 */
int mbedtls_sha256_ret( const unsigned char *input,
                        size_t ilen,
                        unsigned char output[32],
                        int is224 )
{
 c0079b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 c0079b2:	b0df      	sub	sp, #380	; 0x17c
 c0079b4:	4606      	mov	r6, r0

    SHA256_VALIDATE_RET( is224 == 0 || is224 == 1 );
    SHA256_VALIDATE_RET( ilen == 0 || input != NULL );
    SHA256_VALIDATE_RET( (unsigned char *)output != NULL );

    mbedtls_sha256_init( &ctx );
 c0079b6:	a802      	add	r0, sp, #8
{
 c0079b8:	460f      	mov	r7, r1
 c0079ba:	4615      	mov	r5, r2
 c0079bc:	9301      	str	r3, [sp, #4]
    mbedtls_sha256_init( &ctx );
 c0079be:	f7fa fe61 	bl	c002684 <mbedtls_sha256_init>

    if( ( ret = mbedtls_sha256_starts_ret( &ctx, is224 ) ) != 0 )
 c0079c2:	9901      	ldr	r1, [sp, #4]
 c0079c4:	a802      	add	r0, sp, #8
 c0079c6:	f7fa fe85 	bl	c0026d4 <mbedtls_sha256_starts_ret>
 c0079ca:	4604      	mov	r4, r0
 c0079cc:	b958      	cbnz	r0, c0079e6 <mbedtls_sha256_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha256_update_ret( &ctx, input, ilen ) ) != 0 )
 c0079ce:	463a      	mov	r2, r7
 c0079d0:	4631      	mov	r1, r6
 c0079d2:	a802      	add	r0, sp, #8
 c0079d4:	f7fa fea2 	bl	c00271c <mbedtls_sha256_update_ret>
 c0079d8:	4604      	mov	r4, r0
 c0079da:	b920      	cbnz	r0, c0079e6 <mbedtls_sha256_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha256_finish_ret( &ctx, output ) ) != 0 )
 c0079dc:	4629      	mov	r1, r5
 c0079de:	a802      	add	r0, sp, #8
 c0079e0:	f7fa feec 	bl	c0027bc <mbedtls_sha256_finish_ret>
 c0079e4:	4604      	mov	r4, r0
        goto exit;

exit:
    mbedtls_sha256_free( &ctx );
 c0079e6:	a802      	add	r0, sp, #8
 c0079e8:	f7fa fe64 	bl	c0026b4 <mbedtls_sha256_free>

    return( ret );
}
 c0079ec:	4620      	mov	r0, r4
 c0079ee:	b05f      	add	sp, #380	; 0x17c
 c0079f0:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c0079f2 <boot_secure_memequal>:
 *              so should not be considered a drop-in replacement.
 *
 * @return      0 if memory regions are equal.
 */
uint32_t boot_secure_memequal(const void *s1, const void *s2, size_t n)
{
 c0079f2:	b570      	push	{r4, r5, r6, lr}
 c0079f4:	4604      	mov	r4, r0
    size_t i;
    uint8_t *s1_p = (uint8_t*) s1;
    uint8_t *s2_p = (uint8_t*) s2;
    uint32_t ret = 0;
 c0079f6:	2000      	movs	r0, #0

    for (i = 0; i < n; i++) {
 c0079f8:	4603      	mov	r3, r0
 c0079fa:	4293      	cmp	r3, r2
 c0079fc:	d100      	bne.n	c007a00 <boot_secure_memequal+0xe>
        ret |= (s1_p[i] ^ s2_p[i]);
    }

    return ret;
}
 c0079fe:	bd70      	pop	{r4, r5, r6, pc}
        ret |= (s1_p[i] ^ s2_p[i]);
 c007a00:	5ce5      	ldrb	r5, [r4, r3]
 c007a02:	5cce      	ldrb	r6, [r1, r3]
    for (i = 0; i < n; i++) {
 c007a04:	3301      	adds	r3, #1
        ret |= (s1_p[i] ^ s2_p[i]);
 c007a06:	4075      	eors	r5, r6
 c007a08:	4328      	orrs	r0, r5
    for (i = 0; i < n; i++) {
 c007a0a:	e7f6      	b.n	c0079fa <boot_secure_memequal+0x8>

0c007a0c <boot_enc_set_key>:
#endif

int
boot_enc_set_key(struct enc_key_data *enc_state, uint8_t slot,
        const struct boot_status *bs)
{
 c007a0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int rc;

#if defined(MCUBOOT_USE_MBED_TLS)
    mbedtls_aes_init(&enc_state[slot].aes);
 c007a10:	f44f 768e 	mov.w	r6, #284	; 0x11c
{
 c007a14:	4615      	mov	r5, r2
 c007a16:	4688      	mov	r8, r1
    mbedtls_aes_init(&enc_state[slot].aes);
 c007a18:	434e      	muls	r6, r1
 c007a1a:	1984      	adds	r4, r0, r6
 c007a1c:	3404      	adds	r4, #4
{
 c007a1e:	4607      	mov	r7, r0
    mbedtls_aes_init(&enc_state[slot].aes);
 c007a20:	4620      	mov	r0, r4
 c007a22:	f7fc ffe7 	bl	c0049f4 <mbedtls_aes_init>
    rc = mbedtls_aes_setkey_enc(&enc_state[slot].aes, bs->enckey[slot],
 c007a26:	eb05 1108 	add.w	r1, r5, r8, lsl #4
 c007a2a:	2280      	movs	r2, #128	; 0x80
 c007a2c:	4620      	mov	r0, r4
 c007a2e:	310c      	adds	r1, #12
 c007a30:	f7fc ffec 	bl	c004a0c <mbedtls_aes_setkey_enc>
            BOOT_ENC_KEY_SIZE_BITS);
    if (rc) {
 c007a34:	b130      	cbz	r0, c007a44 <boot_enc_set_key+0x38>
        mbedtls_aes_free(&enc_state[slot].aes);
 c007a36:	4620      	mov	r0, r4
 c007a38:	f7fc ffe1 	bl	c0049fe <mbedtls_aes_free>
        return -1;
 c007a3c:	f04f 30ff 	mov.w	r0, #4294967295
#endif

    enc_state[slot].valid = 1;

    return 0;
}
 c007a40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    enc_state[slot].valid = 1;
 c007a44:	2301      	movs	r3, #1
 c007a46:	55bb      	strb	r3, [r7, r6]
    return 0;
 c007a48:	e7fa      	b.n	c007a40 <boot_enc_set_key+0x34>
	...

0c007a4c <boot_enc_decrypt>:
 * @param buf An encryption TLV read from flash (build time fixed length)
 * @param enckey An AES-128 key sized buffer to store to plain key.
 */
int
boot_enc_decrypt(const uint8_t *buf, uint8_t *enckey)
{
 c007a4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 c007a4e:	b0b5      	sub	sp, #212	; 0xd4
#endif
    int rc = -1;

#if defined(MCUBOOT_ENCRYPT_RSA)

    mbedtls_rsa_init(&rsa, MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256);
 c007a50:	2206      	movs	r2, #6
{
 c007a52:	4606      	mov	r6, r0
 c007a54:	460d      	mov	r5, r1
    mbedtls_rsa_init(&rsa, MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256);
 c007a56:	a809      	add	r0, sp, #36	; 0x24
 c007a58:	2101      	movs	r1, #1
 c007a5a:	f7ff fab7 	bl	c006fcc <mbedtls_rsa_init>

    cp = (uint8_t *)bootutil_enc_key.key;
 c007a5e:	4b5d      	ldr	r3, [pc, #372]	; (c007bd4 <boot_enc_decrypt+0x188>)
    if (mbedtls_asn1_get_tag(p, end, &len,
 c007a60:	af08      	add	r7, sp, #32
    cp = (uint8_t *)bootutil_enc_key.key;
 c007a62:	681c      	ldr	r4, [r3, #0]
    cpend = cp + *bootutil_enc_key.len;
 c007a64:	685b      	ldr	r3, [r3, #4]
    cp = (uint8_t *)bootutil_enc_key.key;
 c007a66:	9407      	str	r4, [sp, #28]
    cpend = cp + *bootutil_enc_key.len;
 c007a68:	6819      	ldr	r1, [r3, #0]
    if (mbedtls_asn1_get_tag(p, end, &len,
 c007a6a:	463a      	mov	r2, r7
    cpend = cp + *bootutil_enc_key.len;
 c007a6c:	440c      	add	r4, r1
    if (mbedtls_asn1_get_tag(p, end, &len,
 c007a6e:	2330      	movs	r3, #48	; 0x30
 c007a70:	4621      	mov	r1, r4
 c007a72:	a807      	add	r0, sp, #28
 c007a74:	f7fd fbc0 	bl	c0051f8 <mbedtls_asn1_get_tag>
 c007a78:	b138      	cbz	r0, c007a8a <boot_enc_decrypt+0x3e>
        return -1;
 c007a7a:	f04f 34ff 	mov.w	r4, #4294967295

    rc = parse_rsa_enckey(&rsa, &cp, cpend);
    if (rc) {
        mbedtls_rsa_free(&rsa);
 c007a7e:	a809      	add	r0, sp, #36	; 0x24
 c007a80:	f7ff fdca 	bl	c007618 <mbedtls_rsa_free>
    rc = 0;
#endif
#endif

    return rc;
}
 c007a84:	4620      	mov	r0, r4
 c007a86:	b035      	add	sp, #212	; 0xd4
 c007a88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (*p + len != end) {
 c007a8a:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
 c007a8e:	4413      	add	r3, r2
 c007a90:	429c      	cmp	r4, r3
 c007a92:	f040 809c 	bne.w	c007bce <boot_enc_decrypt+0x182>
        mbedtls_asn1_get_int(p, end, &ctx->ver) != 0 ||
 c007a96:	4621      	mov	r1, r4
 c007a98:	aa09      	add	r2, sp, #36	; 0x24
 c007a9a:	a807      	add	r0, sp, #28
 c007a9c:	f7fd fbc0 	bl	c005220 <mbedtls_asn1_get_int>
    if ( /* version */
 c007aa0:	b110      	cbz	r0, c007aa8 <boot_enc_decrypt+0x5c>
        return -3;
 c007aa2:	f06f 0402 	mvn.w	r4, #2
 c007aa6:	e7ea      	b.n	c007a7e <boot_enc_decrypt+0x32>
        mbedtls_asn1_get_mpi(p, end, &ctx->N) != 0 ||
 c007aa8:	4621      	mov	r1, r4
 c007aaa:	aa0b      	add	r2, sp, #44	; 0x2c
 c007aac:	a807      	add	r0, sp, #28
 c007aae:	f7fd fbdb 	bl	c005268 <mbedtls_asn1_get_mpi>
        mbedtls_asn1_get_int(p, end, &ctx->ver) != 0 ||
 c007ab2:	2800      	cmp	r0, #0
 c007ab4:	d1f5      	bne.n	c007aa2 <boot_enc_decrypt+0x56>
        mbedtls_asn1_get_mpi(p, end, &ctx->E) != 0 ||
 c007ab6:	4621      	mov	r1, r4
 c007ab8:	aa0e      	add	r2, sp, #56	; 0x38
 c007aba:	a807      	add	r0, sp, #28
 c007abc:	f7fd fbd4 	bl	c005268 <mbedtls_asn1_get_mpi>
        mbedtls_asn1_get_mpi(p, end, &ctx->N) != 0 ||
 c007ac0:	2800      	cmp	r0, #0
 c007ac2:	d1ee      	bne.n	c007aa2 <boot_enc_decrypt+0x56>
        mbedtls_asn1_get_mpi(p, end, &ctx->D) != 0 ||
 c007ac4:	4621      	mov	r1, r4
 c007ac6:	aa11      	add	r2, sp, #68	; 0x44
 c007ac8:	a807      	add	r0, sp, #28
 c007aca:	f7fd fbcd 	bl	c005268 <mbedtls_asn1_get_mpi>
        mbedtls_asn1_get_mpi(p, end, &ctx->E) != 0 ||
 c007ace:	2800      	cmp	r0, #0
 c007ad0:	d1e7      	bne.n	c007aa2 <boot_enc_decrypt+0x56>
        mbedtls_asn1_get_mpi(p, end, &ctx->P) != 0 ||
 c007ad2:	4621      	mov	r1, r4
 c007ad4:	aa14      	add	r2, sp, #80	; 0x50
 c007ad6:	a807      	add	r0, sp, #28
 c007ad8:	f7fd fbc6 	bl	c005268 <mbedtls_asn1_get_mpi>
        mbedtls_asn1_get_mpi(p, end, &ctx->D) != 0 ||
 c007adc:	2800      	cmp	r0, #0
 c007ade:	d1e0      	bne.n	c007aa2 <boot_enc_decrypt+0x56>
        mbedtls_asn1_get_mpi(p, end, &ctx->Q) != 0) {
 c007ae0:	4621      	mov	r1, r4
 c007ae2:	aa17      	add	r2, sp, #92	; 0x5c
 c007ae4:	a807      	add	r0, sp, #28
 c007ae6:	f7fd fbbf 	bl	c005268 <mbedtls_asn1_get_mpi>
        mbedtls_asn1_get_mpi(p, end, &ctx->P) != 0 ||
 c007aea:	2800      	cmp	r0, #0
 c007aec:	d1d9      	bne.n	c007aa2 <boot_enc_decrypt+0x56>
    if (*p < end) {
 c007aee:	9b07      	ldr	r3, [sp, #28]
 c007af0:	429c      	cmp	r4, r3
 c007af2:	d922      	bls.n	c007b3a <boot_enc_decrypt+0xee>
            mbedtls_asn1_get_mpi(p, end, &ctx->DP) != 0 ||
 c007af4:	4621      	mov	r1, r4
 c007af6:	aa1a      	add	r2, sp, #104	; 0x68
 c007af8:	a807      	add	r0, sp, #28
 c007afa:	f7fd fbb5 	bl	c005268 <mbedtls_asn1_get_mpi>
        if ( /* d mod (p-1) and d mod (q-1) */
 c007afe:	b110      	cbz	r0, c007b06 <boot_enc_decrypt+0xba>
            return -4;
 c007b00:	f06f 0403 	mvn.w	r4, #3
 c007b04:	e7bb      	b.n	c007a7e <boot_enc_decrypt+0x32>
            mbedtls_asn1_get_mpi(p, end, &ctx->DQ) != 0 ||
 c007b06:	4621      	mov	r1, r4
 c007b08:	aa1d      	add	r2, sp, #116	; 0x74
 c007b0a:	a807      	add	r0, sp, #28
 c007b0c:	f7fd fbac 	bl	c005268 <mbedtls_asn1_get_mpi>
            mbedtls_asn1_get_mpi(p, end, &ctx->DP) != 0 ||
 c007b10:	2800      	cmp	r0, #0
 c007b12:	d1f5      	bne.n	c007b00 <boot_enc_decrypt+0xb4>
            mbedtls_asn1_get_mpi(p, end, &ctx->QP) != 0) {
 c007b14:	4621      	mov	r1, r4
 c007b16:	aa20      	add	r2, sp, #128	; 0x80
 c007b18:	a807      	add	r0, sp, #28
 c007b1a:	f7fd fba5 	bl	c005268 <mbedtls_asn1_get_mpi>
            mbedtls_asn1_get_mpi(p, end, &ctx->DQ) != 0 ||
 c007b1e:	2800      	cmp	r0, #0
 c007b20:	d1ee      	bne.n	c007b00 <boot_enc_decrypt+0xb4>
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c007b22:	a80b      	add	r0, sp, #44	; 0x2c
 c007b24:	f7fd fd8d 	bl	c005642 <mbedtls_mpi_size>
 c007b28:	900a      	str	r0, [sp, #40]	; 0x28
    if (mbedtls_rsa_check_privkey(ctx) != 0) {
 c007b2a:	a809      	add	r0, sp, #36	; 0x24
 c007b2c:	f7ff fa7e 	bl	c00702c <mbedtls_rsa_check_privkey>
 c007b30:	4602      	mov	r2, r0
 c007b32:	b188      	cbz	r0, c007b58 <boot_enc_decrypt+0x10c>
        return -6;
 c007b34:	f06f 0405 	mvn.w	r4, #5
 c007b38:	e7a1      	b.n	c007a7e <boot_enc_decrypt+0x32>
        if (mbedtls_rsa_deduce_crt(&ctx->P, &ctx->Q, &ctx->D,
 c007b3a:	ab20      	add	r3, sp, #128	; 0x80
 c007b3c:	9301      	str	r3, [sp, #4]
 c007b3e:	ab1d      	add	r3, sp, #116	; 0x74
 c007b40:	9300      	str	r3, [sp, #0]
 c007b42:	aa11      	add	r2, sp, #68	; 0x44
 c007b44:	ab1a      	add	r3, sp, #104	; 0x68
 c007b46:	a917      	add	r1, sp, #92	; 0x5c
 c007b48:	a814      	add	r0, sp, #80	; 0x50
 c007b4a:	f7ff feed 	bl	c007928 <mbedtls_rsa_deduce_crt>
 c007b4e:	2800      	cmp	r0, #0
 c007b50:	d0e7      	beq.n	c007b22 <boot_enc_decrypt+0xd6>
            return -5;
 c007b52:	f06f 0404 	mvn.w	r4, #4
 c007b56:	e792      	b.n	c007a7e <boot_enc_decrypt+0x32>
    rc = mbedtls_rsa_rsaes_oaep_decrypt(&rsa, NULL, NULL, MBEDTLS_RSA_PRIVATE,
 c007b58:	2310      	movs	r3, #16
 c007b5a:	4601      	mov	r1, r0
 c007b5c:	e9cd 5304 	strd	r5, r3, [sp, #16]
 c007b60:	e9cd 7602 	strd	r7, r6, [sp, #8]
 c007b64:	2301      	movs	r3, #1
 c007b66:	e9cd 0000 	strd	r0, r0, [sp]
 c007b6a:	a809      	add	r0, sp, #36	; 0x24
 c007b6c:	f7ff fc8c 	bl	c007488 <mbedtls_rsa_rsaes_oaep_decrypt>
 c007b70:	4604      	mov	r4, r0
    mbedtls_rsa_free(&rsa);
 c007b72:	a809      	add	r0, sp, #36	; 0x24
 c007b74:	f7ff fd50 	bl	c007618 <mbedtls_rsa_free>
	{ BOOT_LOG_INF("%x, %x, %x, %x, %x, %x , %x ,%x,",
 c007b78:	4e17      	ldr	r6, [pc, #92]	; (c007bd8 <boot_enc_decrypt+0x18c>)
	while(olen!=0)
 c007b7a:	9b08      	ldr	r3, [sp, #32]
 c007b7c:	2b00      	cmp	r3, #0
 c007b7e:	d081      	beq.n	c007a84 <boot_enc_decrypt+0x38>
	{ BOOT_LOG_INF("%x, %x, %x, %x, %x, %x , %x ,%x,",
 c007b80:	f1c3 0717 	rsb	r7, r3, #23
 c007b84:	5def      	ldrb	r7, [r5, r7]
 c007b86:	f1c3 0012 	rsb	r0, r3, #18
 c007b8a:	9704      	str	r7, [sp, #16]
 c007b8c:	f1c3 0716 	rsb	r7, r3, #22
 c007b90:	5def      	ldrb	r7, [r5, r7]
 c007b92:	f1c3 0211 	rsb	r2, r3, #17
 c007b96:	9703      	str	r7, [sp, #12]
 c007b98:	f1c3 0715 	rsb	r7, r3, #21
 c007b9c:	5def      	ldrb	r7, [r5, r7]
 c007b9e:	f1c3 0110 	rsb	r1, r3, #16
 c007ba2:	9702      	str	r7, [sp, #8]
 c007ba4:	f1c3 0714 	rsb	r7, r3, #20
 c007ba8:	f1c3 0313 	rsb	r3, r3, #19
 c007bac:	5ceb      	ldrb	r3, [r5, r3]
 c007bae:	5def      	ldrb	r7, [r5, r7]
 c007bb0:	9300      	str	r3, [sp, #0]
 c007bb2:	5caa      	ldrb	r2, [r5, r2]
 c007bb4:	5c2b      	ldrb	r3, [r5, r0]
 c007bb6:	5c69      	ldrb	r1, [r5, r1]
 c007bb8:	4630      	mov	r0, r6
 c007bba:	9701      	str	r7, [sp, #4]
 c007bbc:	f001 f8a6 	bl	c008d0c <iprintf>
	if (olen > 8)
 c007bc0:	9b08      	ldr	r3, [sp, #32]
 c007bc2:	2b08      	cmp	r3, #8
	olen = 0;
 c007bc4:	bf94      	ite	ls
 c007bc6:	2300      	movls	r3, #0
	olen = olen -8;
 c007bc8:	3b08      	subhi	r3, #8
 c007bca:	9308      	str	r3, [sp, #32]
 c007bcc:	e7d5      	b.n	c007b7a <boot_enc_decrypt+0x12e>
        return -2;
 c007bce:	f06f 0401 	mvn.w	r4, #1
 c007bd2:	e754      	b.n	c007a7e <boot_enc_decrypt+0x32>
 c007bd4:	0c001000 	.word	0x0c001000
 c007bd8:	0c00a86c 	.word	0x0c00a86c

0c007bdc <boot_enc_load>:
 */
int
boot_enc_load(struct enc_key_data *enc_state, int image_index,
        const struct image_header *hdr, const struct flash_area *fap,
        struct boot_status *bs)
{
 c007bdc:	b5f0      	push	{r4, r5, r6, r7, lr}
 c007bde:	4607      	mov	r7, r0
 c007be0:	b0cb      	sub	sp, #300	; 0x12c
 c007be2:	4608      	mov	r0, r1
    uint8_t buf[EXPECTED_ENC_LEN];
#endif
    uint8_t slot;
    int rc;

    rc = flash_area_id_to_multi_image_slot(image_index, fap->fa_id);
 c007be4:	7819      	ldrb	r1, [r3, #0]
{
 c007be6:	4615      	mov	r5, r2
 c007be8:	461c      	mov	r4, r3
    rc = flash_area_id_to_multi_image_slot(image_index, fap->fa_id);
 c007bea:	f000 fedd 	bl	c0089a8 <flash_area_id_to_multi_image_slot>
    if (rc < 0) {
 c007bee:	2800      	cmp	r0, #0
 c007bf0:	db10      	blt.n	c007c14 <boot_enc_load+0x38>
        return rc;
    }
    slot = rc;

    /* Already loaded... */
    if (enc_state[slot].valid) {
 c007bf2:	f44f 738e 	mov.w	r3, #284	; 0x11c
 c007bf6:	b2c6      	uxtb	r6, r0
 c007bf8:	4373      	muls	r3, r6
 c007bfa:	5cfb      	ldrb	r3, [r7, r3]
 c007bfc:	bb43      	cbnz	r3, c007c50 <boot_enc_load+0x74>
        return 1;
    }

    rc = bootutil_tlv_iter_begin(&it, hdr, fap, EXPECTED_ENC_TLV, false);
 c007bfe:	9300      	str	r3, [sp, #0]
 c007c00:	4622      	mov	r2, r4
 c007c02:	2330      	movs	r3, #48	; 0x30
 c007c04:	4629      	mov	r1, r5
 c007c06:	a804      	add	r0, sp, #16
 c007c08:	f000 fd59 	bl	c0086be <bootutil_tlv_iter_begin>
    if (rc) {
 c007c0c:	4603      	mov	r3, r0
 c007c0e:	b118      	cbz	r0, c007c18 <boot_enc_load+0x3c>
        return -1;
 c007c10:	f04f 30ff 	mov.w	r0, #4294967295
    if (rc) {
        return -1;
    }

    return boot_enc_decrypt(buf, bs->enckey[slot]);
}
 c007c14:	b04b      	add	sp, #300	; 0x12c
 c007c16:	bdf0      	pop	{r4, r5, r6, r7, pc}
    rc = bootutil_tlv_iter_next(&it, &off, &len, NULL);
 c007c18:	f10d 020a 	add.w	r2, sp, #10
 c007c1c:	a903      	add	r1, sp, #12
 c007c1e:	a804      	add	r0, sp, #16
 c007c20:	f000 fd99 	bl	c008756 <bootutil_tlv_iter_next>
    if (rc != 0) {
 c007c24:	2800      	cmp	r0, #0
 c007c26:	d1f5      	bne.n	c007c14 <boot_enc_load+0x38>
    if (len != EXPECTED_ENC_LEN) {
 c007c28:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 c007c2c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 c007c30:	d1ee      	bne.n	c007c10 <boot_enc_load+0x34>
    rc = flash_area_read(fap, off, buf, EXPECTED_ENC_LEN);
 c007c32:	4620      	mov	r0, r4
 c007c34:	9903      	ldr	r1, [sp, #12]
 c007c36:	aa0a      	add	r2, sp, #40	; 0x28
 c007c38:	f000 fe50 	bl	c0088dc <flash_area_read>
    if (rc) {
 c007c3c:	2800      	cmp	r0, #0
 c007c3e:	d1e7      	bne.n	c007c10 <boot_enc_load+0x34>
    return boot_enc_decrypt(buf, bs->enckey[slot]);
 c007c40:	9950      	ldr	r1, [sp, #320]	; 0x140
 c007c42:	a80a      	add	r0, sp, #40	; 0x28
 c007c44:	eb01 1106 	add.w	r1, r1, r6, lsl #4
 c007c48:	310c      	adds	r1, #12
 c007c4a:	f7ff feff 	bl	c007a4c <boot_enc_decrypt>
 c007c4e:	e7e1      	b.n	c007c14 <boot_enc_load+0x38>
        return 1;
 c007c50:	2001      	movs	r0, #1
 c007c52:	e7df      	b.n	c007c14 <boot_enc_load+0x38>

0c007c54 <boot_encrypt>:

void
boot_encrypt(struct enc_key_data *enc_state, int image_index,
        const struct flash_area *fap, uint32_t off, uint32_t sz,
        uint32_t blk_off, uint8_t *buf)
{
 c007c54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c007c58:	4606      	mov	r6, r0
 c007c5a:	4608      	mov	r0, r1
    uint8_t u8;
    uint8_t nonce[16];
    uint8_t blk[16];
    int rc;

    memset(nonce, 0, 12);
 c007c5c:	2100      	movs	r1, #0
{
 c007c5e:	b088      	sub	sp, #32
    memset(nonce, 0, 12);
 c007c60:	e9cd 1100 	strd	r1, r1, [sp]
{
 c007c64:	e9dd 450f 	ldrd	r4, r5, [sp, #60]	; 0x3c
    memset(nonce, 0, 12);
 c007c68:	9102      	str	r1, [sp, #8]
    off >>= 4;
    nonce[12] = (uint8_t)(off >> 24);
 c007c6a:	0f19      	lsrs	r1, r3, #28
 c007c6c:	f88d 100c 	strb.w	r1, [sp, #12]
    nonce[13] = (uint8_t)(off >> 16);
 c007c70:	0d19      	lsrs	r1, r3, #20
 c007c72:	f88d 100d 	strb.w	r1, [sp, #13]
    nonce[14] = (uint8_t)(off >> 8);
 c007c76:	0b19      	lsrs	r1, r3, #12
 c007c78:	f88d 100e 	strb.w	r1, [sp, #14]
    off >>= 4;
 c007c7c:	091b      	lsrs	r3, r3, #4
    nonce[15] = (uint8_t)off;

    rc = flash_area_id_to_multi_image_slot(image_index, fap->fa_id);
 c007c7e:	7811      	ldrb	r1, [r2, #0]
    nonce[15] = (uint8_t)off;
 c007c80:	f88d 300f 	strb.w	r3, [sp, #15]
    rc = flash_area_id_to_multi_image_slot(image_index, fap->fa_id);
 c007c84:	f000 fe90 	bl	c0089a8 <flash_area_id_to_multi_image_slot>
    if (rc < 0) {
 c007c88:	1e03      	subs	r3, r0, #0
 c007c8a:	db0a      	blt.n	c007ca2 <boot_encrypt+0x4e>
        assert(0);
        return;
    }

    enc = &enc_state[rc];
 c007c8c:	f44f 708e 	mov.w	r0, #284	; 0x11c
    assert(enc->valid == 1);
    for (i = 0; i < sz; i++) {
 c007c90:	462f      	mov	r7, r5
    enc = &enc_state[rc];
 c007c92:	fb00 6003 	mla	r0, r0, r3, r6
    for (i = 0; i < sz; i++) {
 c007c96:	9b0e      	ldr	r3, [sp, #56]	; 0x38
        if (i == 0 || blk_off == 0) {
#if defined(MCUBOOT_USE_MBED_TLS)
            mbedtls_aes_crypt_ecb(&enc->aes, MBEDTLS_AES_ENCRYPT, nonce, blk);
 c007c98:	1d06      	adds	r6, r0, #4
 c007c9a:	eb05 0803 	add.w	r8, r5, r3
    for (i = 0; i < sz; i++) {
 c007c9e:	4547      	cmp	r7, r8
 c007ca0:	d102      	bne.n	c007ca8 <boot_encrypt+0x54>

        u8 = *buf;
        *buf++ = u8 ^ blk[blk_off];
        blk_off = (blk_off + 1) & 0x0f;
    }
}
 c007ca2:	b008      	add	sp, #32
 c007ca4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (i == 0 || blk_off == 0) {
 c007ca8:	42af      	cmp	r7, r5
 c007caa:	d000      	beq.n	c007cae <boot_encrypt+0x5a>
 c007cac:	b984      	cbnz	r4, c007cd0 <boot_encrypt+0x7c>
            mbedtls_aes_crypt_ecb(&enc->aes, MBEDTLS_AES_ENCRYPT, nonce, blk);
 c007cae:	466a      	mov	r2, sp
 c007cb0:	2101      	movs	r1, #1
 c007cb2:	4630      	mov	r0, r6
 c007cb4:	ab04      	add	r3, sp, #16
 c007cb6:	f7fd fa49 	bl	c00514c <mbedtls_aes_crypt_ecb>
 c007cba:	2210      	movs	r2, #16
 c007cbc:	f10d 010f 	add.w	r1, sp, #15
                if (++nonce[j - 1] != 0) {
 c007cc0:	780b      	ldrb	r3, [r1, #0]
 c007cc2:	3301      	adds	r3, #1
 c007cc4:	b2db      	uxtb	r3, r3
 c007cc6:	f801 3901 	strb.w	r3, [r1], #-1
 c007cca:	b90b      	cbnz	r3, c007cd0 <boot_encrypt+0x7c>
            for (j = 16; j > 0; --j) {
 c007ccc:	3a01      	subs	r2, #1
 c007cce:	d1f7      	bne.n	c007cc0 <boot_encrypt+0x6c>
        *buf++ = u8 ^ blk[blk_off];
 c007cd0:	aa08      	add	r2, sp, #32
 c007cd2:	4422      	add	r2, r4
        u8 = *buf;
 c007cd4:	783b      	ldrb	r3, [r7, #0]
        *buf++ = u8 ^ blk[blk_off];
 c007cd6:	f812 2c10 	ldrb.w	r2, [r2, #-16]
        blk_off = (blk_off + 1) & 0x0f;
 c007cda:	3401      	adds	r4, #1
        *buf++ = u8 ^ blk[blk_off];
 c007cdc:	4053      	eors	r3, r2
 c007cde:	f807 3b01 	strb.w	r3, [r7], #1
        blk_off = (blk_off + 1) & 0x0f;
 c007ce2:	f004 040f 	and.w	r4, r4, #15
    for (i = 0; i < sz; i++) {
 c007ce6:	e7da      	b.n	c007c9e <boot_encrypt+0x4a>

0c007ce8 <bootutil_verify_sig>:
}

int
bootutil_verify_sig(uint8_t *hash, uint32_t hlen, uint8_t *sig, size_t slen,
  uint8_t key_id)
{
 c007ce8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c007cec:	4690      	mov	r8, r2
    mbedtls_rsa_context ctx;
    int rc;
    uint8_t *cp;
    uint8_t *end;

    mbedtls_rsa_init(&ctx, 0, 0);
 c007cee:	2200      	movs	r2, #0
{
 c007cf0:	f5ad 6d96 	sub.w	sp, sp, #1200	; 0x4b0
 c007cf4:	4607      	mov	r7, r0
 c007cf6:	4689      	mov	r9, r1
    mbedtls_rsa_init(&ctx, 0, 0);
 c007cf8:	a80d      	add	r0, sp, #52	; 0x34
 c007cfa:	4611      	mov	r1, r2
{
 c007cfc:	f89d 54d0 	ldrb.w	r5, [sp, #1232]	; 0x4d0
 c007d00:	461e      	mov	r6, r3
    mbedtls_rsa_init(&ctx, 0, 0);
 c007d02:	f7ff f963 	bl	c006fcc <mbedtls_rsa_init>

    cp = (uint8_t *)bootutil_keys[key_id].key;
 c007d06:	4b7f      	ldr	r3, [pc, #508]	; (c007f04 <bootutil_verify_sig+0x21c>)
    if ((rc = mbedtls_asn1_get_tag(p, end, &len,
 c007d08:	aacc      	add	r2, sp, #816	; 0x330
    cp = (uint8_t *)bootutil_keys[key_id].key;
 c007d0a:	f853 4035 	ldr.w	r4, [r3, r5, lsl #3]
    end = cp + *bootutil_keys[key_id].len;
 c007d0e:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 c007d12:	685b      	ldr	r3, [r3, #4]
    cp = (uint8_t *)bootutil_keys[key_id].key;
 c007d14:	9403      	str	r4, [sp, #12]
    end = cp + *bootutil_keys[key_id].len;
 c007d16:	6819      	ldr	r1, [r3, #0]
    if ((rc = mbedtls_asn1_get_tag(p, end, &len,
 c007d18:	a803      	add	r0, sp, #12
    end = cp + *bootutil_keys[key_id].len;
 c007d1a:	440c      	add	r4, r1
    if ((rc = mbedtls_asn1_get_tag(p, end, &len,
 c007d1c:	2330      	movs	r3, #48	; 0x30
 c007d1e:	4621      	mov	r1, r4
 c007d20:	f7fd fa6a 	bl	c0051f8 <mbedtls_asn1_get_tag>
 c007d24:	b110      	cbz	r0, c007d2c <bootutil_verify_sig+0x44>
        return -1;
 c007d26:	f04f 34ff 	mov.w	r4, #4294967295
 c007d2a:	e00d      	b.n	c007d48 <bootutil_verify_sig+0x60>
    if (*p + len != end) {
 c007d2c:	9b03      	ldr	r3, [sp, #12]
 c007d2e:	9acc      	ldr	r2, [sp, #816]	; 0x330
 c007d30:	4413      	add	r3, r2
 c007d32:	429c      	cmp	r4, r3
 c007d34:	f040 80e2 	bne.w	c007efc <bootutil_verify_sig+0x214>
    if ((rc = mbedtls_asn1_get_mpi(p, end, &ctx->N)) != 0 ||
 c007d38:	4621      	mov	r1, r4
 c007d3a:	aa0f      	add	r2, sp, #60	; 0x3c
 c007d3c:	a803      	add	r0, sp, #12
 c007d3e:	f7fd fa93 	bl	c005268 <mbedtls_asn1_get_mpi>
 c007d42:	b148      	cbz	r0, c007d58 <bootutil_verify_sig+0x70>
        return -3;
 c007d44:	f06f 0402 	mvn.w	r4, #2
    if (rc || slen != ctx.len) {
        mbedtls_rsa_free(&ctx);
        return rc;
    }
    rc = bootutil_cmp_rsasig(&ctx, hash, hlen, sig);
    mbedtls_rsa_free(&ctx);
 c007d48:	a80d      	add	r0, sp, #52	; 0x34
 c007d4a:	f7ff fc65 	bl	c007618 <mbedtls_rsa_free>

    return rc;
}
 c007d4e:	4620      	mov	r0, r4
 c007d50:	f50d 6d96 	add.w	sp, sp, #1200	; 0x4b0
 c007d54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      (rc = mbedtls_asn1_get_mpi(p, end, &ctx->E)) != 0) {
 c007d58:	f10d 0a48 	add.w	sl, sp, #72	; 0x48
 c007d5c:	4652      	mov	r2, sl
 c007d5e:	4621      	mov	r1, r4
 c007d60:	a803      	add	r0, sp, #12
 c007d62:	f7fd fa81 	bl	c005268 <mbedtls_asn1_get_mpi>
    if ((rc = mbedtls_asn1_get_mpi(p, end, &ctx->N)) != 0 ||
 c007d66:	4605      	mov	r5, r0
 c007d68:	2800      	cmp	r0, #0
 c007d6a:	d1eb      	bne.n	c007d44 <bootutil_verify_sig+0x5c>
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c007d6c:	a80f      	add	r0, sp, #60	; 0x3c
 c007d6e:	f7fd fc68 	bl	c005642 <mbedtls_mpi_size>
    if (*p != end) {
 c007d72:	9b03      	ldr	r3, [sp, #12]
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c007d74:	900e      	str	r0, [sp, #56]	; 0x38
    if (*p != end) {
 c007d76:	429c      	cmp	r4, r3
 c007d78:	f040 80bd 	bne.w	c007ef6 <bootutil_verify_sig+0x20e>
    rc = mbedtls_rsa_import(ctx, &ctx->N, NULL, NULL, NULL, &ctx->E);
 c007d7c:	462b      	mov	r3, r5
 c007d7e:	462a      	mov	r2, r5
 c007d80:	e9cd 5a00 	strd	r5, sl, [sp]
 c007d84:	a90f      	add	r1, sp, #60	; 0x3c
 c007d86:	a80d      	add	r0, sp, #52	; 0x34
 c007d88:	f7ff f8dc 	bl	c006f44 <mbedtls_rsa_import>
    if (rc != 0) {
 c007d8c:	2800      	cmp	r0, #0
 c007d8e:	f040 80af 	bne.w	c007ef0 <bootutil_verify_sig+0x208>
    rc = mbedtls_rsa_check_pubkey(ctx);
 c007d92:	a80d      	add	r0, sp, #52	; 0x34
 c007d94:	f7ff f926 	bl	c006fe4 <mbedtls_rsa_check_pubkey>
    if (rc != 0) {
 c007d98:	4604      	mov	r4, r0
 c007d9a:	2800      	cmp	r0, #0
 c007d9c:	f040 80a5 	bne.w	c007eea <bootutil_verify_sig+0x202>
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c007da0:	a80f      	add	r0, sp, #60	; 0x3c
 c007da2:	f7fd fc4e 	bl	c005642 <mbedtls_mpi_size>
    if (rc || slen != ctx.len) {
 c007da6:	4286      	cmp	r6, r0
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c007da8:	900e      	str	r0, [sp, #56]	; 0x38
    if (rc || slen != ctx.len) {
 c007daa:	d1cd      	bne.n	c007d48 <bootutil_verify_sig+0x60>
    if (ctx->len != PSS_EMLEN || PSS_EMLEN > MBEDTLS_MPI_MAX_SIZE) {
 c007dac:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 c007db0:	d1b9      	bne.n	c007d26 <bootutil_verify_sig+0x3e>
    if (hlen != PSS_HLEN) {
 c007db2:	f1b9 0f20 	cmp.w	r9, #32
 c007db6:	d1b6      	bne.n	c007d26 <bootutil_verify_sig+0x3e>
    if (mbedtls_rsa_public(ctx, sig, em)) {
 c007db8:	4641      	mov	r1, r8
 c007dba:	aacc      	add	r2, sp, #816	; 0x330
 c007dbc:	a80d      	add	r0, sp, #52	; 0x34
 c007dbe:	f7ff f967 	bl	c007090 <mbedtls_rsa_public>
 c007dc2:	4604      	mov	r4, r0
 c007dc4:	2800      	cmp	r0, #0
 c007dc6:	d1ae      	bne.n	c007d26 <bootutil_verify_sig+0x3e>
    if (em[PSS_EMLEN - 1] != 0xbc) {
 c007dc8:	f89d 342f 	ldrb.w	r3, [sp, #1071]	; 0x42f
 c007dcc:	2bbc      	cmp	r3, #188	; 0xbc
 c007dce:	d1aa      	bne.n	c007d26 <bootutil_verify_sig+0x3e>
    uint8_t counter[4] = { 0, 0, 0, 0 };
 c007dd0:	f10d 08e0 	add.w	r8, sp, #224	; 0xe0
    int count = PSS_MASK_LEN;
 c007dd4:	26df      	movs	r6, #223	; 0xdf
 c007dd6:	4645      	mov	r5, r8
    uint8_t counter[4] = { 0, 0, 0, 0 };
 c007dd8:	9004      	str	r0, [sp, #16]
#ifdef MCUBOOT_USE_MBED_TLS
typedef mbedtls_sha256_context bootutil_sha256_context;

static inline void bootutil_sha256_init(bootutil_sha256_context *ctx)
{
    mbedtls_sha256_init(ctx);
 c007dda:	a870      	add	r0, sp, #448	; 0x1c0
 c007ddc:	f7fa fc52 	bl	c002684 <mbedtls_sha256_init>
    (void)mbedtls_sha256_starts_ret(ctx, 0);
 c007de0:	2100      	movs	r1, #0
 c007de2:	a870      	add	r0, sp, #448	; 0x1c0
 c007de4:	f7fa fc76 	bl	c0026d4 <mbedtls_sha256_starts_ret>

static inline void bootutil_sha256_update(bootutil_sha256_context *ctx,
                                          const void *data,
                                          uint32_t data_len)
{
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c007de8:	2220      	movs	r2, #32
 c007dea:	f20d 410f 	addw	r1, sp, #1039	; 0x40f
 c007dee:	a870      	add	r0, sp, #448	; 0x1c0
 c007df0:	f7fa fc94 	bl	c00271c <mbedtls_sha256_update_ret>
 c007df4:	2204      	movs	r2, #4
 c007df6:	a904      	add	r1, sp, #16
 c007df8:	a870      	add	r0, sp, #448	; 0x1c0
 c007dfa:	f7fa fc8f 	bl	c00271c <mbedtls_sha256_update_ret>
}

static inline void bootutil_sha256_finish(bootutil_sha256_context *ctx,
                                          uint8_t *output)
{
    (void)mbedtls_sha256_finish_ret(ctx, output);
 c007dfe:	a905      	add	r1, sp, #20
 c007e00:	a870      	add	r0, sp, #448	; 0x1c0
 c007e02:	f7fa fcdb 	bl	c0027bc <mbedtls_sha256_finish_ret>
        if (bytes > count)
 c007e06:	2e1f      	cmp	r6, #31
 c007e08:	bfd4      	ite	le
 c007e0a:	46b1      	movle	r9, r6
 c007e0c:	f04f 0920 	movgt.w	r9, #32
        counter[3]++;
 c007e10:	f89d 3013 	ldrb.w	r3, [sp, #19]
        memcpy(mask, htmp, bytes);
 c007e14:	4640      	mov	r0, r8
        counter[3]++;
 c007e16:	3301      	adds	r3, #1
        memcpy(mask, htmp, bytes);
 c007e18:	464a      	mov	r2, r9
 c007e1a:	a905      	add	r1, sp, #20
        count -= bytes;
 c007e1c:	eba6 0609 	sub.w	r6, r6, r9
        counter[3]++;
 c007e20:	f88d 3013 	strb.w	r3, [sp, #19]
        memcpy(mask, htmp, bytes);
 c007e24:	f000 feb2 	bl	c008b8c <memcpy>
    while (count > 0) {
 c007e28:	2e00      	cmp	r6, #0
        mask += bytes;
 c007e2a:	44c8      	add	r8, r9
    while (count > 0) {
 c007e2c:	dcd5      	bgt.n	c007dda <bootutil_verify_sig+0xf2>
    for (i = 0; i < PSS_MASK_LEN; i++) {
 c007e2e:	4628      	mov	r0, r5
 c007e30:	462a      	mov	r2, r5
 c007e32:	23df      	movs	r3, #223	; 0xdf
 c007e34:	aecc      	add	r6, sp, #816	; 0x330
        db_mask[i] ^= em[i];
 c007e36:	7811      	ldrb	r1, [r2, #0]
 c007e38:	f816 cb01 	ldrb.w	ip, [r6], #1
    for (i = 0; i < PSS_MASK_LEN; i++) {
 c007e3c:	3b01      	subs	r3, #1
        db_mask[i] ^= em[i];
 c007e3e:	ea81 010c 	eor.w	r1, r1, ip
 c007e42:	f802 1b01 	strb.w	r1, [r2], #1
    for (i = 0; i < PSS_MASK_LEN; i++) {
 c007e46:	d1f6      	bne.n	c007e36 <bootutil_verify_sig+0x14e>
    db_mask[0] &= 0x7F;
 c007e48:	782a      	ldrb	r2, [r5, #0]
 c007e4a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c007e4e:	702a      	strb	r2, [r5, #0]
        if (db_mask[i] != 0) {
 c007e50:	f810 6b01 	ldrb.w	r6, [r0], #1
 c007e54:	2e00      	cmp	r6, #0
 c007e56:	f47f af66 	bne.w	c007d26 <bootutil_verify_sig+0x3e>
    for (i = 0; i < PSS_MASK_ZERO_COUNT; i++) {
 c007e5a:	3301      	adds	r3, #1
 c007e5c:	2bbe      	cmp	r3, #190	; 0xbe
 c007e5e:	d1f7      	bne.n	c007e50 <bootutil_verify_sig+0x168>
    if (db_mask[PSS_MASK_ONE_POS] != 1) {
 c007e60:	f895 30be 	ldrb.w	r3, [r5, #190]	; 0xbe
 c007e64:	2b01      	cmp	r3, #1
 c007e66:	f47f af5e 	bne.w	c007d26 <bootutil_verify_sig+0x3e>
    mbedtls_sha256_init(ctx);
 c007e6a:	a870      	add	r0, sp, #448	; 0x1c0
 c007e6c:	f7fa fc0a 	bl	c002684 <mbedtls_sha256_init>
    (void)mbedtls_sha256_starts_ret(ctx, 0);
 c007e70:	4631      	mov	r1, r6
 c007e72:	a870      	add	r0, sp, #448	; 0x1c0
 c007e74:	f7fa fc2e 	bl	c0026d4 <mbedtls_sha256_starts_ret>
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c007e78:	2208      	movs	r2, #8
 c007e7a:	4923      	ldr	r1, [pc, #140]	; (c007f08 <bootutil_verify_sig+0x220>)
 c007e7c:	a870      	add	r0, sp, #448	; 0x1c0
 c007e7e:	f7fa fc4d 	bl	c00271c <mbedtls_sha256_update_ret>
 c007e82:	2220      	movs	r2, #32
 c007e84:	4639      	mov	r1, r7
 c007e86:	a870      	add	r0, sp, #448	; 0x1c0
 c007e88:	f7fa fc48 	bl	c00271c <mbedtls_sha256_update_ret>
 c007e8c:	2220      	movs	r2, #32
 c007e8e:	f20d 119f 	addw	r1, sp, #415	; 0x19f
 c007e92:	a870      	add	r0, sp, #448	; 0x1c0
 c007e94:	f7fa fc42 	bl	c00271c <mbedtls_sha256_update_ret>
    (void)mbedtls_sha256_finish_ret(ctx, output);
 c007e98:	a905      	add	r1, sp, #20
 c007e9a:	a870      	add	r0, sp, #448	; 0x1c0
 c007e9c:	f7fa fc8e 	bl	c0027bc <mbedtls_sha256_finish_ret>
    if (boot_secure_memequal(h2, &em[PSS_HASH_OFFSET], PSS_HLEN) != 0) {
 c007ea0:	2220      	movs	r2, #32
 c007ea2:	f20d 410f 	addw	r1, sp, #1039	; 0x40f
 c007ea6:	a805      	add	r0, sp, #20
 c007ea8:	f7ff fda3 	bl	c0079f2 <boot_secure_memequal>
 c007eac:	2800      	cmp	r0, #0
 c007eae:	f47f af3a 	bne.w	c007d26 <bootutil_verify_sig+0x3e>
    if (ImageValidEnable == 1)
 c007eb2:	4b16      	ldr	r3, [pc, #88]	; (c007f0c <bootutil_verify_sig+0x224>)
 c007eb4:	781b      	ldrb	r3, [r3, #0]
 c007eb6:	2b01      	cmp	r3, #1
 c007eb8:	f47f af46 	bne.w	c007d48 <bootutil_verify_sig+0x60>
        if (ImageValidIndex >= MCUBOOT_IMAGE_NUMBER)
 c007ebc:	4d14      	ldr	r5, [pc, #80]	; (c007f10 <bootutil_verify_sig+0x228>)
 c007ebe:	782b      	ldrb	r3, [r5, #0]
 c007ec0:	2b00      	cmp	r3, #0
 c007ec2:	f47f af30 	bne.w	c007d26 <bootutil_verify_sig+0x3e>
        em[PSS_HASH_OFFSET] ^= IMAGE_VALID;
 c007ec6:	f89d 340f 	ldrb.w	r3, [sp, #1039]	; 0x40f
        ImageValidStatus[ImageValidIndex++] = boot_secure_memequal(h2, &em[PSS_HASH_OFFSET], PSS_HLEN);
 c007eca:	2220      	movs	r2, #32
        em[PSS_HASH_OFFSET] ^= IMAGE_VALID;
 c007ecc:	f083 0355 	eor.w	r3, r3, #85	; 0x55
        ImageValidStatus[ImageValidIndex++] = boot_secure_memequal(h2, &em[PSS_HASH_OFFSET], PSS_HLEN);
 c007ed0:	f20d 410f 	addw	r1, sp, #1039	; 0x40f
 c007ed4:	a805      	add	r0, sp, #20
        em[PSS_HASH_OFFSET] ^= IMAGE_VALID;
 c007ed6:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
        ImageValidStatus[ImageValidIndex++] = boot_secure_memequal(h2, &em[PSS_HASH_OFFSET], PSS_HLEN);
 c007eda:	f7ff fd8a 	bl	c0079f2 <boot_secure_memequal>
 c007ede:	782b      	ldrb	r3, [r5, #0]
 c007ee0:	1c5a      	adds	r2, r3, #1
 c007ee2:	702a      	strb	r2, [r5, #0]
 c007ee4:	4a0b      	ldr	r2, [pc, #44]	; (c007f14 <bootutil_verify_sig+0x22c>)
 c007ee6:	54d0      	strb	r0, [r2, r3]
 c007ee8:	e72e      	b.n	c007d48 <bootutil_verify_sig+0x60>
        return -6;
 c007eea:	f06f 0405 	mvn.w	r4, #5
 c007eee:	e72b      	b.n	c007d48 <bootutil_verify_sig+0x60>
        return -5;
 c007ef0:	f06f 0404 	mvn.w	r4, #4
 c007ef4:	e728      	b.n	c007d48 <bootutil_verify_sig+0x60>
        return -4;
 c007ef6:	f06f 0403 	mvn.w	r4, #3
 c007efa:	e725      	b.n	c007d48 <bootutil_verify_sig+0x60>
        return -2;
 c007efc:	f06f 0401 	mvn.w	r4, #1
        mbedtls_rsa_free(&ctx);
 c007f00:	e722      	b.n	c007d48 <bootutil_verify_sig+0x60>
 c007f02:	bf00      	nop
 c007f04:	0c0014b8 	.word	0x0c0014b8
 c007f08:	0c00a895 	.word	0x0c00a895
 c007f0c:	30030120 	.word	0x30030120
 c007f10:	30030121 	.word	0x30030121
 c007f14:	30030004 	.word	0x30030004

0c007f18 <bootutil_get_img_security_cnt>:
 */
int32_t
bootutil_get_img_security_cnt(struct image_header *hdr,
                              const struct flash_area *fap,
                              uint32_t *img_security_cnt)
{
 c007f18:	b530      	push	{r4, r5, lr}
 c007f1a:	460c      	mov	r4, r1
 c007f1c:	4615      	mov	r5, r2
    struct image_tlv_iter it;
    uint32_t off;
    uint16_t len;
    int32_t rc;

    if ((hdr == NULL) ||
 c007f1e:	4601      	mov	r1, r0
{
 c007f20:	b08b      	sub	sp, #44	; 0x2c
    if ((hdr == NULL) ||
 c007f22:	b320      	cbz	r0, c007f6e <bootutil_get_img_security_cnt+0x56>
 c007f24:	b31c      	cbz	r4, c007f6e <bootutil_get_img_security_cnt+0x56>
        (fap == NULL) ||
 c007f26:	b312      	cbz	r2, c007f6e <bootutil_get_img_security_cnt+0x56>
        /* Invalid parameter. */
        return BOOT_EBADARGS;
    }

    /* The security counter TLV is in the protected part of the TLV area. */
    if (hdr->ih_protect_tlv_size == 0) {
 c007f28:	8943      	ldrh	r3, [r0, #10]
 c007f2a:	b913      	cbnz	r3, c007f32 <bootutil_get_img_security_cnt+0x1a>
        return BOOT_EBADIMAGE;
 c007f2c:	2003      	movs	r0, #3
    if (rc != 0) {
        return BOOT_EFLASH;
    }

    return 0;
}
 c007f2e:	b00b      	add	sp, #44	; 0x2c
 c007f30:	bd30      	pop	{r4, r5, pc}
    rc = bootutil_tlv_iter_begin(&it, hdr, fap, IMAGE_TLV_SEC_CNT, true);
 c007f32:	2301      	movs	r3, #1
 c007f34:	4622      	mov	r2, r4
 c007f36:	9300      	str	r3, [sp, #0]
 c007f38:	a804      	add	r0, sp, #16
 c007f3a:	2350      	movs	r3, #80	; 0x50
 c007f3c:	f000 fbbf 	bl	c0086be <bootutil_tlv_iter_begin>
    if (rc) {
 c007f40:	2800      	cmp	r0, #0
 c007f42:	d1f4      	bne.n	c007f2e <bootutil_get_img_security_cnt+0x16>
    rc = bootutil_tlv_iter_next(&it, &off, &len, NULL);
 c007f44:	4603      	mov	r3, r0
 c007f46:	f10d 020a 	add.w	r2, sp, #10
 c007f4a:	a903      	add	r1, sp, #12
 c007f4c:	a804      	add	r0, sp, #16
 c007f4e:	f000 fc02 	bl	c008756 <bootutil_tlv_iter_next>
    if (rc != 0) {
 c007f52:	b970      	cbnz	r0, c007f72 <bootutil_get_img_security_cnt+0x5a>
    if (len != sizeof(*img_security_cnt)) {
 c007f54:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 c007f58:	2b04      	cmp	r3, #4
 c007f5a:	d1e7      	bne.n	c007f2c <bootutil_get_img_security_cnt+0x14>
    rc = flash_area_read(fap, off, img_security_cnt, len);
 c007f5c:	462a      	mov	r2, r5
 c007f5e:	4620      	mov	r0, r4
 c007f60:	9903      	ldr	r1, [sp, #12]
 c007f62:	f000 fcbb 	bl	c0088dc <flash_area_read>
    if (rc != 0) {
 c007f66:	3800      	subs	r0, #0
 c007f68:	bf18      	it	ne
 c007f6a:	2001      	movne	r0, #1
 c007f6c:	e7df      	b.n	c007f2e <bootutil_get_img_security_cnt+0x16>
        return BOOT_EBADARGS;
 c007f6e:	2007      	movs	r0, #7
 c007f70:	e7dd      	b.n	c007f2e <bootutil_get_img_security_cnt+0x16>
        return -1;
 c007f72:	f04f 30ff 	mov.w	r0, #4294967295
 c007f76:	e7da      	b.n	c007f2e <bootutil_get_img_security_cnt+0x16>

0c007f78 <bootutil_img_validate>:
int
bootutil_img_validate(struct enc_key_data *enc_state, int image_index,
                      struct image_header *hdr, const struct flash_area *fap,
                      uint8_t *tmp_buf, uint32_t tmp_buf_sz, uint8_t *seed,
                      int seed_len, uint8_t *out_hash)
{
 c007f78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c007f7c:	ed2d 8b02 	vpush	{d8}
    uint8_t buf[SIG_BUF_SIZE];
    uint8_t hash[32];
    int rc;
#ifdef MCUBOOT_HW_ROLLBACK_PROT
    uint32_t security_cnt = UINT32_MAX;
    uint32_t img_security_cnt = 0;
 c007f80:	f04f 0800 	mov.w	r8, #0
{
 c007f84:	461d      	mov	r5, r3
    uint32_t img_security_cnt = 0;
 c007f86:	f04f 33ff 	mov.w	r3, #4294967295
{
 c007f8a:	f5ad 7d3d 	sub.w	sp, sp, #756	; 0x2f4
 c007f8e:	ee08 0a10 	vmov	s16, r0
 c007f92:	e9dd 46ca 	ldrd	r4, r6, [sp, #808]	; 0x328
    mbedtls_sha256_init(ctx);
 c007f96:	a860      	add	r0, sp, #384	; 0x180
 c007f98:	468b      	mov	fp, r1
 c007f9a:	4617      	mov	r7, r2
    uint32_t img_security_cnt = 0;
 c007f9c:	e9cd 3808 	strd	r3, r8, [sp, #32]
{
 c007fa0:	f8dd a320 	ldr.w	sl, [sp, #800]	; 0x320
 c007fa4:	f7fa fb6e 	bl	c002684 <mbedtls_sha256_init>
    (void)mbedtls_sha256_starts_ret(ctx, 0);
 c007fa8:	4641      	mov	r1, r8
 c007faa:	a860      	add	r0, sp, #384	; 0x180
 c007fac:	f7fa fb92 	bl	c0026d4 <mbedtls_sha256_starts_ret>
    if (seed && (seed_len > 0)) {
 c007fb0:	b134      	cbz	r4, c007fc0 <bootutil_img_validate+0x48>
 c007fb2:	4546      	cmp	r6, r8
 c007fb4:	dd04      	ble.n	c007fc0 <bootutil_img_validate+0x48>
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c007fb6:	4632      	mov	r2, r6
 c007fb8:	4621      	mov	r1, r4
 c007fba:	a860      	add	r0, sp, #384	; 0x180
 c007fbc:	f7fa fbae 	bl	c00271c <mbedtls_sha256_update_ret>
    for (off = 0; off < size; off += blk_sz) {
 c007fc0:	2400      	movs	r4, #0
    size += hdr->ih_img_size;
 c007fc2:	68fb      	ldr	r3, [r7, #12]
    size = hdr_size = hdr->ih_hdr_size;
 c007fc4:	f8b7 8008 	ldrh.w	r8, [r7, #8]
    size += hdr->ih_img_size;
 c007fc8:	eb08 0903 	add.w	r9, r8, r3
    size += hdr->ih_protect_tlv_size;
 c007fcc:	897b      	ldrh	r3, [r7, #10]
 c007fce:	444b      	add	r3, r9
 c007fd0:	9304      	str	r3, [sp, #16]
    for (off = 0; off < size; off += blk_sz) {
 c007fd2:	9b04      	ldr	r3, [sp, #16]
 c007fd4:	42a3      	cmp	r3, r4
 c007fd6:	d84b      	bhi.n	c008070 <bootutil_img_validate+0xf8>
    (void)mbedtls_sha256_finish_ret(ctx, output);
 c007fd8:	a910      	add	r1, sp, #64	; 0x40
 c007fda:	a860      	add	r0, sp, #384	; 0x180
 c007fdc:	f7fa fbee 	bl	c0027bc <mbedtls_sha256_finish_ret>
            tmp_buf_sz, hash, seed, seed_len);
    if (rc) {
        return rc;
    }

    if (out_hash) {
 c007fe0:	9bcc      	ldr	r3, [sp, #816]	; 0x330
 c007fe2:	b153      	cbz	r3, c007ffa <bootutil_img_validate+0x82>
        memcpy(out_hash, hash, 32);
 c007fe4:	ac10      	add	r4, sp, #64	; 0x40
 c007fe6:	ae18      	add	r6, sp, #96	; 0x60
 c007fe8:	4622      	mov	r2, r4
 c007fea:	ca03      	ldmia	r2!, {r0, r1}
 c007fec:	42b2      	cmp	r2, r6
 c007fee:	6018      	str	r0, [r3, #0]
 c007ff0:	6059      	str	r1, [r3, #4]
 c007ff2:	4614      	mov	r4, r2
 c007ff4:	f103 0308 	add.w	r3, r3, #8
 c007ff8:	d1f6      	bne.n	c007fe8 <bootutil_img_validate+0x70>
    }

    rc = bootutil_tlv_iter_begin(&it, hdr, fap, IMAGE_TLV_ANY, false);
 c007ffa:	2300      	movs	r3, #0
 c007ffc:	4639      	mov	r1, r7
 c007ffe:	9300      	str	r3, [sp, #0]
 c008000:	462a      	mov	r2, r5
 c008002:	f64f 73ff 	movw	r3, #65535	; 0xffff
 c008006:	a80a      	add	r0, sp, #40	; 0x28
 c008008:	f000 fb59 	bl	c0086be <bootutil_tlv_iter_begin>
    if (rc) {
 c00800c:	4601      	mov	r1, r0
 c00800e:	2800      	cmp	r0, #0
 c008010:	d179      	bne.n	c008106 <bootutil_img_validate+0x18e>
    int32_t security_counter_valid = 0;
 c008012:	4607      	mov	r7, r0
    int sha256_valid = 0;
 c008014:	4681      	mov	r9, r0
    int key_id = -1;
 c008016:	f04f 34ff 	mov.w	r4, #4294967295
    bootutil_sha256_update(&sha256_ctx, key->key, *key->len);
 c00801a:	f8df a248 	ldr.w	sl, [pc, #584]	; c008264 <bootutil_img_validate+0x2ec>
    int valid_signature = 0;
 c00801e:	9004      	str	r0, [sp, #16]
    bootutil_sha256_update(&sha256_ctx, key->key, *key->len);
 c008020:	eb0a 08cb 	add.w	r8, sl, fp, lsl #3
    /*
     * Traverse through all of the TLVs, performing any checks we know
     * and are able to do.
     */
    while (true) {
        rc = bootutil_tlv_iter_next(&it, &off, &len, &type);
 c008024:	f10d 031a 	add.w	r3, sp, #26
 c008028:	aa06      	add	r2, sp, #24
 c00802a:	a907      	add	r1, sp, #28
 c00802c:	a80a      	add	r0, sp, #40	; 0x28
 c00802e:	f000 fb92 	bl	c008756 <bootutil_tlv_iter_next>
        if (rc < 0) {
 c008032:	2800      	cmp	r0, #0
 c008034:	db65      	blt.n	c008102 <bootutil_img_validate+0x18a>
            return -1;
        } else if (rc > 0) {
 c008036:	f040 80fb 	bne.w	c008230 <bootutil_img_validate+0x2b8>
            break;
        }

        if (type == IMAGE_TLV_SHA256) {
 c00803a:	f8bd 601a 	ldrh.w	r6, [sp, #26]
 c00803e:	2e10      	cmp	r6, #16
 c008040:	d168      	bne.n	c008114 <bootutil_img_validate+0x19c>
            /*
             * Verify the SHA256 image hash.  This must always be
             * present.
             */
            if (len != sizeof(hash)) {
 c008042:	f8bd 6018 	ldrh.w	r6, [sp, #24]
 c008046:	2e20      	cmp	r6, #32
 c008048:	d15b      	bne.n	c008102 <bootutil_img_validate+0x18a>
                return -1;
            }
            rc = flash_area_read(fap, off, buf, sizeof hash);
 c00804a:	9907      	ldr	r1, [sp, #28]
 c00804c:	4633      	mov	r3, r6
 c00804e:	4628      	mov	r0, r5
 c008050:	aa20      	add	r2, sp, #128	; 0x80
 c008052:	f000 fc43 	bl	c0088dc <flash_area_read>
            if (rc) {
 c008056:	4601      	mov	r1, r0
 c008058:	2800      	cmp	r0, #0
 c00805a:	d154      	bne.n	c008106 <bootutil_img_validate+0x18e>
                return rc;
            }
            if (boot_secure_memequal(hash, buf, sizeof(hash))) {
 c00805c:	4632      	mov	r2, r6
 c00805e:	a920      	add	r1, sp, #128	; 0x80
 c008060:	a810      	add	r0, sp, #64	; 0x40
 c008062:	f7ff fcc6 	bl	c0079f2 <boot_secure_memequal>
 c008066:	2800      	cmp	r0, #0
 c008068:	d14b      	bne.n	c008102 <bootutil_img_validate+0x18a>
                return -1;
            }

            sha256_valid = 1;
 c00806a:	f04f 0901 	mov.w	r9, #1
 c00806e:	e7d9      	b.n	c008024 <bootutil_img_validate+0xac>
        blk_sz = size - off;
 c008070:	9b04      	ldr	r3, [sp, #16]
 c008072:	1b1e      	subs	r6, r3, r4
        if (blk_sz > tmp_buf_sz) {
 c008074:	9bc9      	ldr	r3, [sp, #804]	; 0x324
 c008076:	429e      	cmp	r6, r3
 c008078:	bf28      	it	cs
 c00807a:	461e      	movcs	r6, r3
        if ((off < hdr_size) && ((off + blk_sz) > hdr_size)) {
 c00807c:	45a0      	cmp	r8, r4
 c00807e:	d904      	bls.n	c00808a <bootutil_img_validate+0x112>
 c008080:	19a3      	adds	r3, r4, r6
 c008082:	4598      	cmp	r8, r3
            blk_sz = hdr_size - off;
 c008084:	bf38      	it	cc
 c008086:	eba8 0604 	subcc.w	r6, r8, r4
        if ((off < tlv_off) && ((off + blk_sz) > tlv_off)) {
 c00808a:	45a1      	cmp	r9, r4
 c00808c:	d904      	bls.n	c008098 <bootutil_img_validate+0x120>
 c00808e:	19a3      	adds	r3, r4, r6
 c008090:	4599      	cmp	r9, r3
            blk_sz = tlv_off - off;
 c008092:	bf38      	it	cc
 c008094:	eba9 0604 	subcc.w	r6, r9, r4
        rc = flash_area_read(fap, off, tmp_buf, blk_sz);
 c008098:	4621      	mov	r1, r4
 c00809a:	4633      	mov	r3, r6
 c00809c:	4652      	mov	r2, sl
 c00809e:	4628      	mov	r0, r5
 c0080a0:	f000 fc1c 	bl	c0088dc <flash_area_read>
        if (rc) {
 c0080a4:	4601      	mov	r1, r0
 c0080a6:	bb70      	cbnz	r0, c008106 <bootutil_img_validate+0x18e>
    if (MUST_DECRYPT_PRIMARY_ONLY(fap, image_index, hdr)) {
 c0080a8:	693b      	ldr	r3, [r7, #16]
 c0080aa:	f003 0306 	and.w	r3, r3, #6
 c0080ae:	2b06      	cmp	r3, #6
 c0080b0:	d111      	bne.n	c0080d6 <bootutil_img_validate+0x15e>
            if (off >= hdr_size && off < tlv_off) {
 c0080b2:	45a0      	cmp	r8, r4
 c0080b4:	d816      	bhi.n	c0080e4 <bootutil_img_validate+0x16c>
 c0080b6:	45a1      	cmp	r9, r4
 c0080b8:	d914      	bls.n	c0080e4 <bootutil_img_validate+0x16c>
                blk_off = (off - hdr_size) & 0xf;
 c0080ba:	eba4 0308 	sub.w	r3, r4, r8
 c0080be:	f003 020f 	and.w	r2, r3, #15
                boot_encrypt(enc_state, image_index, fap, off - hdr_size,
 c0080c2:	e9cd 6200 	strd	r6, r2, [sp]
 c0080c6:	4659      	mov	r1, fp
 c0080c8:	462a      	mov	r2, r5
 c0080ca:	ee18 0a10 	vmov	r0, s16
 c0080ce:	f8cd a008 	str.w	sl, [sp, #8]
 c0080d2:	f7ff fdbf 	bl	c007c54 <boot_encrypt>
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c0080d6:	4632      	mov	r2, r6
 c0080d8:	4651      	mov	r1, sl
 c0080da:	a860      	add	r0, sp, #384	; 0x180
 c0080dc:	f7fa fb1e 	bl	c00271c <mbedtls_sha256_update_ret>
    for (off = 0; off < size; off += blk_sz) {
 c0080e0:	4434      	add	r4, r6
 c0080e2:	e776      	b.n	c007fd2 <bootutil_img_validate+0x5a>
                BOOT_LOG_INF("Controlling an encrypted primary image");
 c0080e4:	4857      	ldr	r0, [pc, #348]	; (c008244 <bootutil_img_validate+0x2cc>)
 c0080e6:	f000 fe97 	bl	c008e18 <puts>
                if (blk_sz == hdr_size)
 c0080ea:	45b0      	cmp	r8, r6
 c0080ec:	d106      	bne.n	c0080fc <bootutil_img_validate+0x184>
                    header->ih_flags &=~IMAGE_F_ENCRYPTED;
 c0080ee:	f8da 3010 	ldr.w	r3, [sl, #16]
 c0080f2:	f023 0304 	bic.w	r3, r3, #4
 c0080f6:	f8ca 3010 	str.w	r3, [sl, #16]
 c0080fa:	e7ec      	b.n	c0080d6 <bootutil_img_validate+0x15e>
                    BOOT_LOG_INF("Header does not fit in a block size: not supported with MCUBOOT_PRIMARY_ONLY");
 c0080fc:	4852      	ldr	r0, [pc, #328]	; (c008248 <bootutil_img_validate+0x2d0>)
 c0080fe:	f000 fe8b 	bl	c008e18 <puts>
            }
            if (rc)
            {

                BOOT_LOG_INF("unexpected TLV %x ", type);
                return rc;
 c008102:	f04f 31ff 	mov.w	r1, #4294967295
            off += sizeof(data);
        }
    }
#endif /* !defined(MCUBOOT_PRIMARY_ONLY) */
    return 0;
}
 c008106:	4608      	mov	r0, r1
 c008108:	f50d 7d3d 	add.w	sp, sp, #756	; 0x2f4
 c00810c:	ecbd 8b02 	vpop	{d8}
 c008110:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        } else if (type == IMAGE_TLV_KEYHASH) {
 c008114:	2e01      	cmp	r6, #1
 c008116:	d12f      	bne.n	c008178 <bootutil_img_validate+0x200>
            if (len > 32) {
 c008118:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 c00811c:	2b20      	cmp	r3, #32
 c00811e:	d8f0      	bhi.n	c008102 <bootutil_img_validate+0x18a>
            rc = flash_area_read(fap, off, buf, len);
 c008120:	9907      	ldr	r1, [sp, #28]
 c008122:	4628      	mov	r0, r5
 c008124:	aa20      	add	r2, sp, #128	; 0x80
 c008126:	f000 fbd9 	bl	c0088dc <flash_area_read>
            if (rc) {
 c00812a:	4601      	mov	r1, r0
 c00812c:	2800      	cmp	r0, #0
 c00812e:	d1ea      	bne.n	c008106 <bootutil_img_validate+0x18e>
            key_id = bootutil_find_key(image_index, buf, len);
 c008130:	f89d 4018 	ldrb.w	r4, [sp, #24]
    if (keyhash_len > 32) {
 c008134:	2c20      	cmp	r4, #32
 c008136:	d902      	bls.n	c00813e <bootutil_img_validate+0x1c6>
            key_id = -1;
 c008138:	f04f 34ff 	mov.w	r4, #4294967295
 c00813c:	e772      	b.n	c008024 <bootutil_img_validate+0xac>
 c00813e:	9005      	str	r0, [sp, #20]
    mbedtls_sha256_init(ctx);
 c008140:	a860      	add	r0, sp, #384	; 0x180
 c008142:	f7fa fa9f 	bl	c002684 <mbedtls_sha256_init>
    (void)mbedtls_sha256_starts_ret(ctx, 0);
 c008146:	9905      	ldr	r1, [sp, #20]
 c008148:	a860      	add	r0, sp, #384	; 0x180
 c00814a:	f7fa fac3 	bl	c0026d4 <mbedtls_sha256_starts_ret>
    bootutil_sha256_update(&sha256_ctx, key->key, *key->len);
 c00814e:	f8d8 3004 	ldr.w	r3, [r8, #4]
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c008152:	f85a 103b 	ldr.w	r1, [sl, fp, lsl #3]
 c008156:	681a      	ldr	r2, [r3, #0]
 c008158:	a860      	add	r0, sp, #384	; 0x180
 c00815a:	f7fa fadf 	bl	c00271c <mbedtls_sha256_update_ret>
    (void)mbedtls_sha256_finish_ret(ctx, output);
 c00815e:	a918      	add	r1, sp, #96	; 0x60
 c008160:	a860      	add	r0, sp, #384	; 0x180
 c008162:	f7fa fb2b 	bl	c0027bc <mbedtls_sha256_finish_ret>
    if (!boot_secure_memequal(hash, keyhash, keyhash_len)) {
 c008166:	4622      	mov	r2, r4
 c008168:	a920      	add	r1, sp, #128	; 0x80
 c00816a:	a818      	add	r0, sp, #96	; 0x60
 c00816c:	f7ff fc41 	bl	c0079f2 <boot_secure_memequal>
 c008170:	2800      	cmp	r0, #0
 c008172:	d1e1      	bne.n	c008138 <bootutil_img_validate+0x1c0>
        return (int)image_index;
 c008174:	465c      	mov	r4, fp
 c008176:	e755      	b.n	c008024 <bootutil_img_validate+0xac>
        } else if (type == EXPECTED_SIG_TLV) {
 c008178:	2e20      	cmp	r6, #32
 c00817a:	d128      	bne.n	c0081ce <bootutil_img_validate+0x256>
            if (key_id < 0 || key_id >= bootutil_key_cnt) {
 c00817c:	2c00      	cmp	r4, #0
 c00817e:	dbdb      	blt.n	c008138 <bootutil_img_validate+0x1c0>
 c008180:	4b32      	ldr	r3, [pc, #200]	; (c00824c <bootutil_img_validate+0x2d4>)
 c008182:	681b      	ldr	r3, [r3, #0]
 c008184:	42a3      	cmp	r3, r4
 c008186:	ddd7      	ble.n	c008138 <bootutil_img_validate+0x1c0>
            if (!EXPECTED_SIG_LEN(len) || len > sizeof(buf)) {
 c008188:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 c00818c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 c008190:	d1b7      	bne.n	c008102 <bootutil_img_validate+0x18a>
            rc = flash_area_read(fap, off, buf, len);
 c008192:	4628      	mov	r0, r5
 c008194:	9907      	ldr	r1, [sp, #28]
 c008196:	aa20      	add	r2, sp, #128	; 0x80
 c008198:	f000 fba0 	bl	c0088dc <flash_area_read>
            if (rc) {
 c00819c:	2800      	cmp	r0, #0
 c00819e:	d1b0      	bne.n	c008102 <bootutil_img_validate+0x18a>
			BOOT_LOG_INF("verify sig key id %d", key_id);
 c0081a0:	4621      	mov	r1, r4
 c0081a2:	482b      	ldr	r0, [pc, #172]	; (c008250 <bootutil_img_validate+0x2d8>)
            rc = bootutil_verify_sig(hash, sizeof(hash), buf, len, key_id);
 c0081a4:	b2e4      	uxtb	r4, r4
			BOOT_LOG_INF("verify sig key id %d", key_id);
 c0081a6:	f000 fdb1 	bl	c008d0c <iprintf>
            rc = bootutil_verify_sig(hash, sizeof(hash), buf, len, key_id);
 c0081aa:	4631      	mov	r1, r6
 c0081ac:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 c0081b0:	9400      	str	r4, [sp, #0]
 c0081b2:	aa20      	add	r2, sp, #128	; 0x80
 c0081b4:	a810      	add	r0, sp, #64	; 0x40
 c0081b6:	f7ff fd97 	bl	c007ce8 <bootutil_verify_sig>
            if (rc == 0) {
 c0081ba:	2800      	cmp	r0, #0
 c0081bc:	d1bc      	bne.n	c008138 <bootutil_img_validate+0x1c0>
				BOOT_LOG_INF("signature OK");
 c0081be:	4825      	ldr	r0, [pc, #148]	; (c008254 <bootutil_img_validate+0x2dc>)
 c0081c0:	f000 fe2a 	bl	c008e18 <puts>
                valid_signature = 1;
 c0081c4:	2301      	movs	r3, #1
            key_id = -1;
 c0081c6:	f04f 34ff 	mov.w	r4, #4294967295
                valid_signature = 1;
 c0081ca:	9304      	str	r3, [sp, #16]
 c0081cc:	e72a      	b.n	c008024 <bootutil_img_validate+0xac>
        } else if (type == IMAGE_TLV_SEC_CNT) {
 c0081ce:	2e50      	cmp	r6, #80	; 0x50
 c0081d0:	d123      	bne.n	c00821a <bootutil_img_validate+0x2a2>
            if (len != sizeof(img_security_cnt)) {
 c0081d2:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 c0081d6:	2b04      	cmp	r3, #4
 c0081d8:	d193      	bne.n	c008102 <bootutil_img_validate+0x18a>
            rc = flash_area_read(fap, off, &img_security_cnt, len);
 c0081da:	9907      	ldr	r1, [sp, #28]
 c0081dc:	4628      	mov	r0, r5
 c0081de:	aa09      	add	r2, sp, #36	; 0x24
 c0081e0:	f000 fb7c 	bl	c0088dc <flash_area_read>
            if (rc) {
 c0081e4:	4601      	mov	r1, r0
 c0081e6:	2800      	cmp	r0, #0
 c0081e8:	d18d      	bne.n	c008106 <bootutil_img_validate+0x18e>
            rc = boot_nv_security_counter_get(image_index, &security_cnt);
 c0081ea:	a908      	add	r1, sp, #32
 c0081ec:	4658      	mov	r0, fp
 c0081ee:	f000 fc45 	bl	c008a7c <boot_nv_security_counter_get>
            if (rc) {
 c0081f2:	4601      	mov	r1, r0
 c0081f4:	2800      	cmp	r0, #0
 c0081f6:	d186      	bne.n	c008106 <bootutil_img_validate+0x18e>
            BOOT_LOG_INF("verify counter  %d %x %x", image_index,img_security_cnt, security_cnt );
 c0081f8:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
 c0081fc:	4659      	mov	r1, fp
 c0081fe:	4816      	ldr	r0, [pc, #88]	; (c008258 <bootutil_img_validate+0x2e0>)
 c008200:	f000 fd84 	bl	c008d0c <iprintf>
            if (img_security_cnt < security_cnt) {
 c008204:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
 c008208:	429a      	cmp	r2, r3
 c00820a:	f4ff af7a 	bcc.w	c008102 <bootutil_img_validate+0x18a>
            BOOT_LOG_INF("counter  %d : ok", image_index );
 c00820e:	4659      	mov	r1, fp
 c008210:	4812      	ldr	r0, [pc, #72]	; (c00825c <bootutil_img_validate+0x2e4>)
 c008212:	f000 fd7b 	bl	c008d0c <iprintf>
            security_counter_valid = 1;
 c008216:	2701      	movs	r7, #1
 c008218:	e704      	b.n	c008024 <bootutil_img_validate+0xac>
            if (type == IMAGE_TLV_ENC_RSA2048)
 c00821a:	2e30      	cmp	r6, #48	; 0x30
 c00821c:	f43f af02 	beq.w	c008024 <bootutil_img_validate+0xac>
            if (type == IMAGE_TLV_DEPENDENCY)
 c008220:	2e40      	cmp	r6, #64	; 0x40
 c008222:	f43f aeff 	beq.w	c008024 <bootutil_img_validate+0xac>
                BOOT_LOG_INF("unexpected TLV %x ", type);
 c008226:	4631      	mov	r1, r6
 c008228:	480d      	ldr	r0, [pc, #52]	; (c008260 <bootutil_img_validate+0x2e8>)
 c00822a:	f000 fd6f 	bl	c008d0c <iprintf>
 c00822e:	e768      	b.n	c008102 <bootutil_img_validate+0x18a>
    if (!sha256_valid) {
 c008230:	f1b9 0f00 	cmp.w	r9, #0
 c008234:	f43f af65 	beq.w	c008102 <bootutil_img_validate+0x18a>
    } else if (!valid_signature) {
 c008238:	9b04      	ldr	r3, [sp, #16]
 c00823a:	2b00      	cmp	r3, #0
 c00823c:	f43f af61 	beq.w	c008102 <bootutil_img_validate+0x18a>
    } else if (!security_counter_valid) {
 c008240:	1e79      	subs	r1, r7, #1
 c008242:	e760      	b.n	c008106 <bootutil_img_validate+0x18e>
 c008244:	0c00a89d 	.word	0x0c00a89d
 c008248:	0c00a8cb 	.word	0x0c00a8cb
 c00824c:	0c0014b4 	.word	0x0c0014b4
 c008250:	0c00a91f 	.word	0x0c00a91f
 c008254:	0c00a93c 	.word	0x0c00a93c
 c008258:	0c00a950 	.word	0x0c00a950
 c00825c:	0c00a971 	.word	0x0c00a971
 c008260:	0c00a98a 	.word	0x0c00a98a
 c008264:	0c0014b8 	.word	0x0c0014b8

0c008268 <boot_read_image_headers.isra.0>:
    return rc;
}
#endif /* !MCUBOOT_OVERWRITE_ONLY */

static int
boot_read_image_headers(struct boot_loader_state *state, bool require_all,
 c008268:	460b      	mov	r3, r1
 c00826a:	4602      	mov	r2, r0
{
    int rc;
    int i;

    for (i = 0; i < BOOT_NUM_SLOTS; i++) {
        rc = boot_read_image_header(state, i, boot_img_hdr(state, i), bs);
 c00826c:	2100      	movs	r1, #0
 c00826e:	f000 ba0b 	b.w	c008688 <boot_read_image_header>

0c008272 <boot_update_security_counter.constprop.0>:
 *                      that is currently stored in the given slot.
 *
 * @return              0 on success; nonzero on failure.
 */
static int
boot_update_security_counter(uint8_t image_index, int slot,
 c008272:	b513      	push	{r0, r1, r4, lr}
                             struct image_header *hdr)
{
    const struct flash_area *fap = NULL;
 c008274:	2100      	movs	r1, #0
boot_update_security_counter(uint8_t image_index, int slot,
 c008276:	4604      	mov	r4, r0
    uint32_t img_security_cnt;
    int rc;

    rc = flash_area_open(flash_area_id_from_multi_image_slot(image_index, slot),
 c008278:	4608      	mov	r0, r1
    const struct flash_area *fap = NULL;
 c00827a:	9100      	str	r1, [sp, #0]
    rc = flash_area_open(flash_area_id_from_multi_image_slot(image_index, slot),
 c00827c:	f000 fb8e 	bl	c00899c <flash_area_id_from_multi_image_slot>
 c008280:	4669      	mov	r1, sp
 c008282:	b2c0      	uxtb	r0, r0
 c008284:	f000 fb1e 	bl	c0088c4 <flash_area_open>
                         &fap);
    if (rc != 0) {
 c008288:	b980      	cbnz	r0, c0082ac <boot_update_security_counter.constprop.0+0x3a>
        rc = BOOT_EFLASH;
        goto done;
    }

    rc = bootutil_get_img_security_cnt(hdr, fap, &img_security_cnt);
 c00828a:	4620      	mov	r0, r4
 c00828c:	9900      	ldr	r1, [sp, #0]
 c00828e:	aa01      	add	r2, sp, #4
 c008290:	f7ff fe42 	bl	c007f18 <bootutil_get_img_security_cnt>
    if (rc != 0) {
 c008294:	4604      	mov	r4, r0
 c008296:	b918      	cbnz	r0, c0082a0 <boot_update_security_counter.constprop.0+0x2e>
        goto done;
    }

    rc = boot_nv_security_counter_update(image_index, img_security_cnt);
 c008298:	9901      	ldr	r1, [sp, #4]
 c00829a:	f000 fc03 	bl	c008aa4 <boot_nv_security_counter_update>
 c00829e:	4604      	mov	r4, r0
    if (rc != 0) {
        goto done;
    }

done:
    flash_area_close(fap);
 c0082a0:	9800      	ldr	r0, [sp, #0]
 c0082a2:	f000 fb19 	bl	c0088d8 <flash_area_close>
    return rc;
}
 c0082a6:	4620      	mov	r0, r4
 c0082a8:	b002      	add	sp, #8
 c0082aa:	bd10      	pop	{r4, pc}
        rc = BOOT_EFLASH;
 c0082ac:	2401      	movs	r4, #1
 c0082ae:	e7f7      	b.n	c0082a0 <boot_update_security_counter.constprop.0+0x2e>

0c0082b0 <boot_read_sectors>:
    num_sectors = BOOT_MAX_IMG_SECTORS;
 c0082b0:	23d6      	movs	r3, #214	; 0xd6
{
 c0082b2:	b537      	push	{r0, r1, r2, r4, r5, lr}
    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
 c0082b4:	6a42      	ldr	r2, [r0, #36]	; 0x24
{
 c0082b6:	4604      	mov	r4, r0
    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
 c0082b8:	a901      	add	r1, sp, #4
 c0082ba:	2001      	movs	r0, #1
    num_sectors = BOOT_MAX_IMG_SECTORS;
 c0082bc:	9301      	str	r3, [sp, #4]
    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
 c0082be:	f000 fb8d 	bl	c0089dc <flash_area_get_sectors>
    if (rc != 0) {
 c0082c2:	4605      	mov	r5, r0
 c0082c4:	b940      	cbnz	r0, c0082d8 <boot_read_sectors+0x28>
    *out_num_sectors = num_sectors;
 c0082c6:	9b01      	ldr	r3, [sp, #4]
    elem_sz = flash_area_align(BOOT_IMG_AREA(state, BOOT_PRIMARY_SLOT));
 c0082c8:	6a20      	ldr	r0, [r4, #32]
    *out_num_sectors = num_sectors;
 c0082ca:	62a3      	str	r3, [r4, #40]	; 0x28
    elem_sz = flash_area_align(BOOT_IMG_AREA(state, BOOT_PRIMARY_SLOT));
 c0082cc:	f000 fb4a 	bl	c008964 <flash_area_align>
    BOOT_WRITE_SZ(state) = boot_write_sz(state);
 c0082d0:	6320      	str	r0, [r4, #48]	; 0x30
}
 c0082d2:	4628      	mov	r0, r5
 c0082d4:	b003      	add	sp, #12
 c0082d6:	bd30      	pop	{r4, r5, pc}
        return BOOT_EFLASH;
 c0082d8:	2501      	movs	r5, #1
 c0082da:	e7fa      	b.n	c0082d2 <boot_read_sectors+0x22>

0c0082dc <boot_copy_region>:
int
boot_copy_region(struct boot_loader_state *state,
                 const struct flash_area *fap_src,
                 const struct flash_area *fap_dst,
                 uint32_t off_src, uint32_t off_dst, uint32_t sz)
{
 c0082dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0082e0:	ed2d 8b02 	vpush	{d8}
 c0082e4:	b087      	sub	sp, #28
 c0082e6:	9304      	str	r3, [sp, #16]
                        blk_sz = 0;
                    } else {
                        blk_sz = tlv_off - (off + bytes_copied);
                    }
                }
                boot_encrypt(BOOT_CURR_ENC(state), image_index, fap_src,
 c0082e8:	f100 0334 	add.w	r3, r0, #52	; 0x34
{
 c0082ec:	4606      	mov	r6, r0
 c0082ee:	4689      	mov	r9, r1
 c0082f0:	4692      	mov	sl, r2
    bytes_copied = 0;
 c0082f2:	2700      	movs	r7, #0
                boot_encrypt(BOOT_CURR_ENC(state), image_index, fap_src,
 c0082f4:	ee08 3a10 	vmov	s16, r3
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
 c0082f8:	f8df 80d4 	ldr.w	r8, [pc, #212]	; c0083d0 <boot_copy_region+0xf4>
                    BOOT_LOG_INF("ih_flags %x",((struct image_header *)buf)->ih_flags);
 c0082fc:	f8df b0d4 	ldr.w	fp, [pc, #212]	; c0083d4 <boot_copy_region+0xf8>
    while (bytes_copied < sz) {
 c008300:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 c008302:	429f      	cmp	r7, r3
 c008304:	d301      	bcc.n	c00830a <boot_copy_region+0x2e>
        bytes_copied += chunk_sz;

        MCUBOOT_WATCHDOG_FEED();
    }

    return 0;
 c008306:	2000      	movs	r0, #0
 c008308:	e010      	b.n	c00832c <boot_copy_region+0x50>
        if (sz - bytes_copied > sizeof buf) {
 c00830a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
 c00830c:	4648      	mov	r0, r9
        if (sz - bytes_copied > sizeof buf) {
 c00830e:	1bdc      	subs	r4, r3, r7
 c008310:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 c008314:	bf28      	it	cs
 c008316:	f44f 5480 	movcs.w	r4, #4096	; 0x1000
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
 c00831a:	9b04      	ldr	r3, [sp, #16]
 c00831c:	4a2c      	ldr	r2, [pc, #176]	; (c0083d0 <boot_copy_region+0xf4>)
 c00831e:	18fd      	adds	r5, r7, r3
 c008320:	4629      	mov	r1, r5
 c008322:	4623      	mov	r3, r4
 c008324:	f000 fada 	bl	c0088dc <flash_area_read>
        if (rc != 0) {
 c008328:	b128      	cbz	r0, c008336 <boot_copy_region+0x5a>
            return BOOT_EFLASH;
 c00832a:	2001      	movs	r0, #1
}
 c00832c:	b007      	add	sp, #28
 c00832e:	ecbd 8b02 	vpop	{d8}
 c008332:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if (IS_ENCRYPTED(hdr)) {
 c008336:	6932      	ldr	r2, [r6, #16]
 c008338:	0752      	lsls	r2, r2, #29
 c00833a:	d531      	bpl.n	c0083a0 <boot_copy_region+0xc4>
                if (off + bytes_copied < hdr->ih_hdr_size) {
 c00833c:	8932      	ldrh	r2, [r6, #8]
 c00833e:	4295      	cmp	r5, r2
 c008340:	d241      	bcs.n	c0083c6 <boot_copy_region+0xea>
                    BOOT_LOG_INF("ih_flags %x",((struct image_header *)buf)->ih_flags);
 c008342:	f8d8 1010 	ldr.w	r1, [r8, #16]
 c008346:	9005      	str	r0, [sp, #20]
 c008348:	4658      	mov	r0, fp
 c00834a:	f000 fcdf 	bl	c008d0c <iprintf>
                    ((struct image_header *)buf)->ih_flags &=~IMAGE_F_ENCRYPTED;
 c00834e:	f8d8 1010 	ldr.w	r1, [r8, #16]
                    BOOT_LOG_INF("ih_flags %x",((struct image_header *)buf)->ih_flags);
 c008352:	4658      	mov	r0, fp
                    ((struct image_header *)buf)->ih_flags &=~IMAGE_F_ENCRYPTED;
 c008354:	f021 0104 	bic.w	r1, r1, #4
 c008358:	f8c8 1010 	str.w	r1, [r8, #16]
                    BOOT_LOG_INF("ih_flags %x",((struct image_header *)buf)->ih_flags);
 c00835c:	f000 fcd6 	bl	c008d0c <iprintf>
                    blk_off = 0;
 c008360:	9b05      	ldr	r3, [sp, #20]
                    blk_sz = chunk_sz - hdr->ih_hdr_size;
 c008362:	8930      	ldrh	r0, [r6, #8]
                    blk_off = 0;
 c008364:	461a      	mov	r2, r3
                    blk_sz = chunk_sz - hdr->ih_hdr_size;
 c008366:	eba4 0c00 	sub.w	ip, r4, r0
                tlv_off = BOOT_TLV_OFF(hdr);
 c00836a:	8933      	ldrh	r3, [r6, #8]
 c00836c:	68f1      	ldr	r1, [r6, #12]
                if (off + bytes_copied + chunk_sz > tlv_off) {
 c00836e:	eb05 0e04 	add.w	lr, r5, r4
                tlv_off = BOOT_TLV_OFF(hdr);
 c008372:	4419      	add	r1, r3
                if (off + bytes_copied + chunk_sz > tlv_off) {
 c008374:	458e      	cmp	lr, r1
 c008376:	d905      	bls.n	c008384 <boot_copy_region+0xa8>
                    if (off + bytes_copied >= tlv_off) {
 c008378:	428d      	cmp	r5, r1
                        blk_sz = 0;
 c00837a:	bf2c      	ite	cs
 c00837c:	f04f 0c00 	movcs.w	ip, #0
                        blk_sz = tlv_off - (off + bytes_copied);
 c008380:	eba1 0c05 	subcc.w	ip, r1, r5
                boot_encrypt(BOOT_CURR_ENC(state), image_index, fap_src,
 c008384:	1aed      	subs	r5, r5, r3
 c008386:	eb00 0308 	add.w	r3, r0, r8
 c00838a:	e9cd 2301 	strd	r2, r3, [sp, #4]
 c00838e:	2100      	movs	r1, #0
 c008390:	182b      	adds	r3, r5, r0
 c008392:	464a      	mov	r2, r9
 c008394:	ee18 0a10 	vmov	r0, s16
 c008398:	f8cd c000 	str.w	ip, [sp]
 c00839c:	f7ff fc5a 	bl	c007c54 <boot_encrypt>
        rc = flash_area_erase(fap_dst, off_dst + bytes_copied, chunk_sz);
 c0083a0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 c0083a2:	4622      	mov	r2, r4
 c0083a4:	18f9      	adds	r1, r7, r3
 c0083a6:	4650      	mov	r0, sl
 c0083a8:	9105      	str	r1, [sp, #20]
 c0083aa:	f000 fab7 	bl	c00891c <flash_area_erase>
        if (rc != 0) {
 c0083ae:	2800      	cmp	r0, #0
 c0083b0:	d1bb      	bne.n	c00832a <boot_copy_region+0x4e>
        rc = flash_area_write(fap_dst, off_dst + bytes_copied, buf, chunk_sz);
 c0083b2:	4623      	mov	r3, r4
 c0083b4:	4642      	mov	r2, r8
 c0083b6:	4650      	mov	r0, sl
 c0083b8:	9905      	ldr	r1, [sp, #20]
 c0083ba:	f000 fa9f 	bl	c0088fc <flash_area_write>
        if (rc != 0) {
 c0083be:	2800      	cmp	r0, #0
 c0083c0:	d1b3      	bne.n	c00832a <boot_copy_region+0x4e>
        bytes_copied += chunk_sz;
 c0083c2:	4427      	add	r7, r4
 c0083c4:	e79c      	b.n	c008300 <boot_copy_region+0x24>
                    blk_off = ((off + bytes_copied) - hdr->ih_hdr_size) & 0xf;
 c0083c6:	1aaa      	subs	r2, r5, r2
                blk_sz = chunk_sz;
 c0083c8:	46a4      	mov	ip, r4
                    blk_off = ((off + bytes_copied) - hdr->ih_hdr_size) & 0xf;
 c0083ca:	f002 020f 	and.w	r2, r2, #15
 c0083ce:	e7cc      	b.n	c00836a <boot_copy_region+0x8e>
 c0083d0:	30032604 	.word	0x30032604
 c0083d4:	0c00a9a5 	.word	0x0c00a9a5

0c0083d8 <context_boot_go>:
#endif
}

int
context_boot_go(struct boot_loader_state *state, struct boot_rsp *rsp)
{
 c0083d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#endif
#if MCUBOOT_SWAP_USING_SCRATCH
    TARGET_STATIC boot_sector_t scratch_sectors[BOOT_MAX_IMG_SECTORS];
#endif

    memset(state, 0, sizeof(struct boot_loader_state));
 c0083dc:	f44f 72a8 	mov.w	r2, #336	; 0x150
{
 c0083e0:	b091      	sub	sp, #68	; 0x44
 c0083e2:	460e      	mov	r6, r1
    memset(state, 0, sizeof(struct boot_loader_state));
 c0083e4:	2100      	movs	r1, #0
{
 c0083e6:	4604      	mov	r4, r0
    memset(state, 0, sizeof(struct boot_loader_state));
 c0083e8:	f000 fbdd 	bl	c008ba6 <memset>

        /* Open primary and secondary image areas for the duration
         * of this call.
         */
        for (slot = 0; slot < BOOT_NUM_SLOTS; slot++) {
            fa_id = flash_area_id_from_multi_image_slot(image_index, slot);
 c0083ec:	2100      	movs	r1, #0
        BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors =
 c0083ee:	4b93      	ldr	r3, [pc, #588]	; (c00863c <context_boot_go+0x264>)
            fa_id = flash_area_id_from_multi_image_slot(image_index, slot);
 c0083f0:	4608      	mov	r0, r1
        BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors =
 c0083f2:	6263      	str	r3, [r4, #36]	; 0x24
            fa_id = flash_area_id_from_multi_image_slot(image_index, slot);
 c0083f4:	f000 fad2 	bl	c00899c <flash_area_id_from_multi_image_slot>
            rc = flash_area_open(fa_id, &BOOT_IMG_AREA(state, slot));
 c0083f8:	f104 0120 	add.w	r1, r4, #32
 c0083fc:	b2c0      	uxtb	r0, r0
 c0083fe:	f000 fa61 	bl	c0088c4 <flash_area_open>
    rc = boot_read_sectors(state);
 c008402:	4620      	mov	r0, r4
 c008404:	f7ff ff54 	bl	c0082b0 <boot_read_sectors>
    if (rc != 0) {
 c008408:	4605      	mov	r5, r0
 c00840a:	b128      	cbz	r0, c008418 <context_boot_go+0x40>
        BOOT_LOG_WRN("Failed reading sectors; BOOT_MAX_IMG_SECTORS=%d"
 c00840c:	21d6      	movs	r1, #214	; 0xd6
 c00840e:	488c      	ldr	r0, [pc, #560]	; (c008640 <context_boot_go+0x268>)
            BOOT_LOG_WRN("Image %d is installed ",
 c008410:	f000 fc7c 	bl	c008d0c <iprintf>
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
 c008414:	2301      	movs	r3, #1
 c008416:	e015      	b.n	c008444 <context_boot_go+0x6c>
    rc = boot_read_image_headers(state, false, NULL);
 c008418:	4601      	mov	r1, r0
 c00841a:	4620      	mov	r0, r4
 c00841c:	f7ff ff24 	bl	c008268 <boot_read_image_headers.isra.0>
    if (rc != 0) {
 c008420:	4601      	mov	r1, r0
 c008422:	b110      	cbz	r0, c00842a <context_boot_go+0x52>
        BOOT_LOG_WRN("Failed reading image headers; Image=%u",
 c008424:	4629      	mov	r1, r5
 c008426:	4887      	ldr	r0, [pc, #540]	; (c008644 <context_boot_go+0x26c>)
 c008428:	e7f2      	b.n	c008410 <context_boot_go+0x38>
    if (boot_img_hdr(state,0)->ih_magic == IMAGE_MAGIC) {
 c00842a:	6822      	ldr	r2, [r4, #0]
 c00842c:	4b86      	ldr	r3, [pc, #536]	; (c008648 <context_boot_go+0x270>)
 c00842e:	429a      	cmp	r2, r3
 c008430:	d10a      	bne.n	c008448 <context_boot_go+0x70>
        if (IS_PRIMARY_ONLY(BOOT_IMG_HDR(state)) && IS_ENCRYPTED(BOOT_IMG_HDR(state))) {
 c008432:	6923      	ldr	r3, [r4, #16]
 c008434:	f003 0306 	and.w	r3, r3, #6
 c008438:	2b06      	cmp	r3, #6
 c00843a:	d112      	bne.n	c008462 <context_boot_go+0x8a>
            BOOT_LOG_WRN("Image %d is encrypted ",
 c00843c:	4883      	ldr	r0, [pc, #524]	; (c00864c <context_boot_go+0x274>)
 c00843e:	f000 fc65 	bl	c008d0c <iprintf>
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_PERM;
 c008442:	2303      	movs	r3, #3
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
 c008444:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
#endif

        /* Determine swap type and complete swap if it has been aborted. */
        boot_prepare_image_for_update(state, &bs);

        if (BOOT_IS_UPGRADE(BOOT_SWAP_TYPE(state))) {
 c008448:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
#endif /* (BOOT_IMAGE_NUMBER > 1) */

        /* Set the previously determined swap type */
        bs.swap_type = BOOT_SWAP_TYPE(state);

        switch (BOOT_SWAP_TYPE(state)) {
 c00844c:	2b04      	cmp	r3, #4
        bs.swap_type = BOOT_SWAP_TYPE(state);
 c00844e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        switch (BOOT_SWAP_TYPE(state)) {
 c008452:	d808      	bhi.n	c008466 <context_boot_go+0x8e>
 c008454:	2b01      	cmp	r3, #1
 c008456:	d808      	bhi.n	c00846a <context_boot_go+0x92>
 c008458:	d04c      	beq.n	c0084f4 <context_boot_go+0x11c>
            }
#endif /* !MCUBOOT_OVERWRITE_ONLY */
            break;

        default:
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_PANIC;
 c00845a:	23ff      	movs	r3, #255	; 0xff
 c00845c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
 c008460:	e048      	b.n	c0084f4 <context_boot_go+0x11c>
            BOOT_LOG_WRN("Image %d is installed ",
 c008462:	487b      	ldr	r0, [pc, #492]	; (c008650 <context_boot_go+0x278>)
 c008464:	e7d4      	b.n	c008410 <context_boot_go+0x38>
        switch (BOOT_SWAP_TYPE(state)) {
 c008466:	2b05      	cmp	r3, #5
 c008468:	e7f6      	b.n	c008458 <context_boot_go+0x80>
    for (sect = 0, size = 0; sect < sect_count; sect++) {
 c00846a:	2500      	movs	r5, #0
 c00846c:	462b      	mov	r3, r5
    sect_count = boot_img_num_sectors(state, BOOT_PRIMARY_SLOT);
 c00846e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    for (sect = 0, size = 0; sect < sect_count; sect++) {
 c008470:	4299      	cmp	r1, r3
 c008472:	d131      	bne.n	c0084d8 <context_boot_go+0x100>
    BOOT_LOG_INF("Image upgrade primary slot -> primary slot");
 c008474:	4877      	ldr	r0, [pc, #476]	; (c008654 <context_boot_go+0x27c>)
 c008476:	f000 fccf 	bl	c008e18 <puts>
    BOOT_LOG_INF("Power off not supported");
 c00847a:	4877      	ldr	r0, [pc, #476]	; (c008658 <context_boot_go+0x280>)
 c00847c:	f000 fccc 	bl	c008e18 <puts>
    rc = boot_enc_load(BOOT_CURR_ENC(state), image_index,
 c008480:	f104 0834 	add.w	r8, r4, #52	; 0x34
    rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY(image_index),
 c008484:	a907      	add	r1, sp, #28
 c008486:	2001      	movs	r0, #1
    rc = boot_enc_load(BOOT_CURR_ENC(state), image_index,
 c008488:	f10d 0920 	add.w	r9, sp, #32
    rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY(image_index),
 c00848c:	f000 fa1a 	bl	c0088c4 <flash_area_open>
    rc = boot_enc_load(BOOT_CURR_ENC(state), image_index,
 c008490:	4622      	mov	r2, r4
 c008492:	2100      	movs	r1, #0
 c008494:	9b07      	ldr	r3, [sp, #28]
 c008496:	4640      	mov	r0, r8
 c008498:	f8cd 9000 	str.w	r9, [sp]
 c00849c:	f7ff fb9e 	bl	c007bdc <boot_enc_load>
 c0084a0:	4607      	mov	r7, r0
    BOOT_LOG_INF("Load Encrypted Key");
 c0084a2:	486e      	ldr	r0, [pc, #440]	; (c00865c <context_boot_go+0x284>)
 c0084a4:	f000 fcb8 	bl	c008e18 <puts>
    if (rc < 0) {
 c0084a8:	2f00      	cmp	r7, #0
 c0084aa:	db23      	blt.n	c0084f4 <context_boot_go+0x11c>
    if (rc == 0 && boot_enc_set_key(BOOT_CURR_ENC(state), 0, bs)) {
 c0084ac:	d01b      	beq.n	c0084e6 <context_boot_go+0x10e>
    BOOT_LOG_INF("Copying the primary slot to the primary slot: 0x%x bytes",
 c0084ae:	4629      	mov	r1, r5
 c0084b0:	486b      	ldr	r0, [pc, #428]	; (c008660 <context_boot_go+0x288>)
 c0084b2:	f000 fc2b 	bl	c008d0c <iprintf>
    rc = boot_copy_region(state, fap_primary_slot, fap_primary_slot, 0, 0, size);
 c0084b6:	2300      	movs	r3, #0
 c0084b8:	9a07      	ldr	r2, [sp, #28]
 c0084ba:	4620      	mov	r0, r4
 c0084bc:	4611      	mov	r1, r2
 c0084be:	9501      	str	r5, [sp, #4]
 c0084c0:	9300      	str	r3, [sp, #0]
 c0084c2:	f7ff ff0b 	bl	c0082dc <boot_copy_region>
    rc = boot_update_security_counter(BOOT_CURR_IMG(state), BOOT_PRIMARY_SLOT,
 c0084c6:	4620      	mov	r0, r4
 c0084c8:	f7ff fed3 	bl	c008272 <boot_update_security_counter.constprop.0>
    if (rc != 0) {
 c0084cc:	2800      	cmp	r0, #0
 c0084ce:	d038      	beq.n	c008542 <context_boot_go+0x16a>
        BOOT_LOG_ERR("Security counter update failed after image upgrade.");
 c0084d0:	4864      	ldr	r0, [pc, #400]	; (c008664 <context_boot_go+0x28c>)
 c0084d2:	f000 fca1 	bl	c008e18 <puts>
        return rc;
 c0084d6:	e00d      	b.n	c0084f4 <context_boot_go+0x11c>

static inline size_t
boot_img_sector_size(const struct boot_loader_state *state,
                     size_t slot, size_t sector)
{
    return BOOT_IMG(state, slot).sectors[sector].fs_size;
 c0084d8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 c0084da:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
        size += this_size;
 c0084de:	6852      	ldr	r2, [r2, #4]
    for (sect = 0, size = 0; sect < sect_count; sect++) {
 c0084e0:	3301      	adds	r3, #1
        size += this_size;
 c0084e2:	4415      	add	r5, r2
    for (sect = 0, size = 0; sect < sect_count; sect++) {
 c0084e4:	e7c4      	b.n	c008470 <context_boot_go+0x98>
    if (rc == 0 && boot_enc_set_key(BOOT_CURR_ENC(state), 0, bs)) {
 c0084e6:	464a      	mov	r2, r9
 c0084e8:	4639      	mov	r1, r7
 c0084ea:	4640      	mov	r0, r8
 c0084ec:	f7ff fa8e 	bl	c007a0c <boot_enc_set_key>
 c0084f0:	2800      	cmp	r0, #0
 c0084f2:	d0dc      	beq.n	c0084ae <context_boot_go+0xd6>
    /* Iterate over all the images. At this point all required update operations
     * have finished. By the end of the loop each image in the primary slot will
     * have been re-validated.
     */
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
        if (BOOT_SWAP_TYPE(state) != BOOT_SWAP_TYPE_NONE) {
 c0084f4:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 c0084f8:	2b01      	cmp	r3, #1
 c0084fa:	d126      	bne.n	c00854a <context_boot_go+0x172>
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c0084fc:	2100      	movs	r1, #0
        }

#ifdef MCUBOOT_VALIDATE_PRIMARY_SLOT
#if defined(MCUBOOT_DOUBLE_SIGN_VERIF)
        /* Enable image validation double check */
        ImageValidEnable = 1;
 c0084fe:	2301      	movs	r3, #1
 c008500:	4f59      	ldr	r7, [pc, #356]	; (c008668 <context_boot_go+0x290>)
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c008502:	4608      	mov	r0, r1
        ImageValidEnable = 1;
 c008504:	703b      	strb	r3, [r7, #0]
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c008506:	f000 fa49 	bl	c00899c <flash_area_id_from_multi_image_slot>
    rc = flash_area_open(area_id, &fap);
 c00850a:	a906      	add	r1, sp, #24
 c00850c:	b2c0      	uxtb	r0, r0
 c00850e:	f000 f9d9 	bl	c0088c4 <flash_area_open>
    if (rc != 0) {
 c008512:	4601      	mov	r1, r0
 c008514:	2800      	cmp	r0, #0
 c008516:	f040 808f 	bne.w	c008638 <context_boot_go+0x260>
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c00851a:	f000 fa3f 	bl	c00899c <flash_area_id_from_multi_image_slot>
    rc = flash_area_open(area_id, &fap);
 c00851e:	a907      	add	r1, sp, #28
 c008520:	b2c0      	uxtb	r0, r0
 c008522:	f000 f9cf 	bl	c0088c4 <flash_area_open>
    if (rc != 0) {
 c008526:	bb10      	cbnz	r0, c00856e <context_boot_go+0x196>
    erased_val = flash_area_erased_val(fap);
 c008528:	9807      	ldr	r0, [sp, #28]
 c00852a:	f000 fa4b 	bl	c0089c4 <flash_area_erased_val>
 c00852e:	4605      	mov	r5, r0
    flash_area_close(fap);
 c008530:	9807      	ldr	r0, [sp, #28]
 c008532:	f000 f9d1 	bl	c0088d8 <flash_area_close>
boot_data_is_set_to(uint8_t val, void *data, size_t len)
 c008536:	1e63      	subs	r3, r4, #1
 c008538:	1ce2      	adds	r2, r4, #3
    for (i = 0; i < len; i++) {
 c00853a:	4293      	cmp	r3, r2
 c00853c:	d113      	bne.n	c008566 <context_boot_go+0x18e>
        rc = 1;
 c00853e:	2501      	movs	r5, #1
 c008540:	e04a      	b.n	c0085d8 <context_boot_go+0x200>
    flash_area_close(fap_primary_slot);
 c008542:	9807      	ldr	r0, [sp, #28]
 c008544:	f000 f9c8 	bl	c0088d8 <flash_area_close>
    return 0;
 c008548:	e7d4      	b.n	c0084f4 <context_boot_go+0x11c>
            rc = boot_read_image_headers(state, false, &bs);
 c00854a:	4620      	mov	r0, r4
 c00854c:	a908      	add	r1, sp, #32
 c00854e:	f7ff fe8b 	bl	c008268 <boot_read_image_headers.isra.0>
            if (rc != 0) {
 c008552:	4605      	mov	r5, r0
 c008554:	2800      	cmp	r0, #0
 c008556:	d0d1      	beq.n	c0084fc <context_boot_go+0x124>
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
#if MCUBOOT_SWAP_USING_SCRATCH
        flash_area_close(BOOT_SCRATCH_AREA(state));
#endif
        for (slot = 0; slot < BOOT_NUM_SLOTS; slot++) {
            flash_area_close(BOOT_IMG_AREA(state, BOOT_NUM_SLOTS - 1 - slot));
 c008558:	6a20      	ldr	r0, [r4, #32]
 c00855a:	f000 f9bd 	bl	c0088d8 <flash_area_close>
        }
    }
    return rc;
}
 c00855e:	4628      	mov	r0, r5
 c008560:	b011      	add	sp, #68	; 0x44
 c008562:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (val != p[i]) {
 c008566:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 c00856a:	42a9      	cmp	r1, r5
 c00856c:	d0e5      	beq.n	c00853a <context_boot_go+0x162>
        (hdr->ih_flags & IMAGE_F_NON_BOOTABLE)) {
 c00856e:	6922      	ldr	r2, [r4, #16]
    if (boot_check_header_erased(state, slot) == 0 ||
 c008570:	f012 0110 	ands.w	r1, r2, #16
 c008574:	d1e3      	bne.n	c00853e <context_boot_go+0x166>
    if (hdr->ih_magic != IMAGE_MAGIC) {
 c008576:	6820      	ldr	r0, [r4, #0]
 c008578:	4b33      	ldr	r3, [pc, #204]	; (c008648 <context_boot_go+0x270>)
 c00857a:	4298      	cmp	r0, r3
 c00857c:	d009      	beq.n	c008592 <context_boot_go+0x1ba>
            flash_area_erase(fap, 0, fap->fa_size);
 c00857e:	9806      	ldr	r0, [sp, #24]
 c008580:	2100      	movs	r1, #0
 c008582:	6882      	ldr	r2, [r0, #8]
 c008584:	f000 f9ca 	bl	c00891c <flash_area_erase>
        BOOT_LOG_ERR("Image in the %s slot is not valid!",
 c008588:	4938      	ldr	r1, [pc, #224]	; (c00866c <context_boot_go+0x294>)
 c00858a:	4839      	ldr	r0, [pc, #228]	; (c008670 <context_boot_go+0x298>)
 c00858c:	f000 fbbe 	bl	c008d0c <iprintf>
        goto out;
 c008590:	e7d5      	b.n	c00853e <context_boot_go+0x166>
    if (!boot_u32_safe_add(&size, hdr->ih_img_size, hdr->ih_hdr_size)) {
 c008592:	8920      	ldrh	r0, [r4, #8]
 c008594:	68e3      	ldr	r3, [r4, #12]
    if (a > UINT32_MAX - b) {
 c008596:	43c5      	mvns	r5, r0
 c008598:	42ab      	cmp	r3, r5
 c00859a:	d8f0      	bhi.n	c00857e <context_boot_go+0x1a6>
 c00859c:	f8dd 8018 	ldr.w	r8, [sp, #24]
        *dest = a + b;
 c0085a0:	4403      	add	r3, r0
    if (size >= fap->fa_size) {
 c0085a2:	f8d8 0008 	ldr.w	r0, [r8, #8]
 c0085a6:	4283      	cmp	r3, r0
 c0085a8:	d2e9      	bcs.n	c00857e <context_boot_go+0x1a6>
    if (MUST_DECRYPT_PRIMARY_ONLY(fap, image_index, hdr)) {
 c0085aa:	f002 0206 	and.w	r2, r2, #6
 c0085ae:	2a06      	cmp	r2, #6
 c0085b0:	f104 0534 	add.w	r5, r4, #52	; 0x34
 c0085b4:	d022      	beq.n	c0085fc <context_boot_go+0x224>
    if (bootutil_img_validate(BOOT_CURR_ENC(state), image_index, hdr, fap, tmpbuf,
 c0085b6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 c0085ba:	2100      	movs	r1, #0
 c0085bc:	9301      	str	r3, [sp, #4]
 c0085be:	4b2d      	ldr	r3, [pc, #180]	; (c008674 <context_boot_go+0x29c>)
 c0085c0:	4628      	mov	r0, r5
 c0085c2:	9300      	str	r3, [sp, #0]
 c0085c4:	4622      	mov	r2, r4
 c0085c6:	4643      	mov	r3, r8
 c0085c8:	e9cd 1103 	strd	r1, r1, [sp, #12]
 c0085cc:	9102      	str	r1, [sp, #8]
 c0085ce:	f7ff fcd3 	bl	c007f78 <bootutil_img_validate>
 c0085d2:	4605      	mov	r5, r0
 c0085d4:	2800      	cmp	r0, #0
 c0085d6:	d1d2      	bne.n	c00857e <context_boot_go+0x1a6>
    flash_area_close(fap);
 c0085d8:	9806      	ldr	r0, [sp, #24]
 c0085da:	f000 f97d 	bl	c0088d8 <flash_area_close>
        if (rc != 0) {
 c0085de:	bb5d      	cbnz	r5, c008638 <context_boot_go+0x260>
        if (BOOT_SWAP_TYPE(state) == BOOT_SWAP_TYPE_NONE) {
 c0085e0:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
        ImageValidEnable = 0;
 c0085e4:	703d      	strb	r5, [r7, #0]
        if (BOOT_SWAP_TYPE(state) == BOOT_SWAP_TYPE_NONE) {
 c0085e6:	2b01      	cmp	r3, #1
 c0085e8:	d118      	bne.n	c00861c <context_boot_go+0x244>
            rc = boot_update_security_counter(
 c0085ea:	4620      	mov	r0, r4
 c0085ec:	f7ff fe41 	bl	c008272 <boot_update_security_counter.constprop.0>
            if (rc != 0) {
 c0085f0:	4605      	mov	r5, r0
 c0085f2:	b198      	cbz	r0, c00861c <context_boot_go+0x244>
                BOOT_LOG_ERR("Security counter update failed after image "
 c0085f4:	4820      	ldr	r0, [pc, #128]	; (c008678 <context_boot_go+0x2a0>)
 c0085f6:	f000 fc0f 	bl	c008e18 <puts>
                goto out;
 c0085fa:	e7ad      	b.n	c008558 <context_boot_go+0x180>
        rc = boot_enc_load(BOOT_CURR_ENC(state), image_index, hdr, fap, bs);
 c0085fc:	4622      	mov	r2, r4
 c0085fe:	4643      	mov	r3, r8
 c008600:	4628      	mov	r0, r5
 c008602:	9100      	str	r1, [sp, #0]
 c008604:	f7ff faea 	bl	c007bdc <boot_enc_load>
        if (rc < 0) {
 c008608:	1e02      	subs	r2, r0, #0
 c00860a:	dbb8      	blt.n	c00857e <context_boot_go+0x1a6>
        if (rc == 0 && boot_enc_set_key(BOOT_CURR_ENC(state), 0, bs)) {
 c00860c:	d1d3      	bne.n	c0085b6 <context_boot_go+0x1de>
 c00860e:	4611      	mov	r1, r2
 c008610:	4628      	mov	r0, r5
 c008612:	f7ff f9fb 	bl	c007a0c <boot_enc_set_key>
 c008616:	2800      	cmp	r0, #0
 c008618:	d0cd      	beq.n	c0085b6 <context_boot_go+0x1de>
 c00861a:	e7b0      	b.n	c00857e <context_boot_go+0x1a6>
    memset(&bs, 0, sizeof(struct boot_status));
 c00861c:	2220      	movs	r2, #32
 c00861e:	2100      	movs	r1, #0
 c008620:	eb0d 0002 	add.w	r0, sp, r2
 c008624:	f000 fabf 	bl	c008ba6 <memset>
    rsp->br_flash_dev_id = BOOT_IMG_AREA(state, BOOT_PRIMARY_SLOT)->fa_device_id;
 c008628:	6a23      	ldr	r3, [r4, #32]
    rsp->br_hdr = boot_img_hdr(state, BOOT_PRIMARY_SLOT);
 c00862a:	2500      	movs	r5, #0
    rsp->br_flash_dev_id = BOOT_IMG_AREA(state, BOOT_PRIMARY_SLOT)->fa_device_id;
 c00862c:	785a      	ldrb	r2, [r3, #1]
 c00862e:	7132      	strb	r2, [r6, #4]
    rsp->br_image_off = boot_img_slot_off(state, BOOT_PRIMARY_SLOT);
 c008630:	685b      	ldr	r3, [r3, #4]
    rsp->br_hdr = boot_img_hdr(state, BOOT_PRIMARY_SLOT);
 c008632:	6034      	str	r4, [r6, #0]
    rsp->br_image_off = boot_img_slot_off(state, BOOT_PRIMARY_SLOT);
 c008634:	60b3      	str	r3, [r6, #8]
    return &BOOT_IMG(state, slot).hdr;
 c008636:	e78f      	b.n	c008558 <context_boot_go+0x180>
            rc = BOOT_EBADIMAGE;
 c008638:	2503      	movs	r5, #3
 c00863a:	e78d      	b.n	c008558 <context_boot_go+0x180>
 c00863c:	30033604 	.word	0x30033604
 c008640:	0c00a9b9 	.word	0x0c00a9b9
 c008644:	0c00a9fe 	.word	0x0c00a9fe
 c008648:	96f3b83d 	.word	0x96f3b83d
 c00864c:	0c00aa2d 	.word	0x0c00aa2d
 c008650:	0c00aa4c 	.word	0x0c00aa4c
 c008654:	0c00aa6b 	.word	0x0c00aa6b
 c008658:	0c00aa9d 	.word	0x0c00aa9d
 c00865c:	0c00aabc 	.word	0x0c00aabc
 c008660:	0c00aad6 	.word	0x0c00aad6
 c008664:	0c00ab17 	.word	0x0c00ab17
 c008668:	30030120 	.word	0x30030120
 c00866c:	0c00ab52 	.word	0x0c00ab52
 c008670:	0c00ab5a 	.word	0x0c00ab5a
 c008674:	30033cb4 	.word	0x30033cb4
 c008678:	0c00ab85 	.word	0x0c00ab85

0c00867c <boot_go>:
 *
 * @return                      0 on success; nonzero on failure.
 */
int
boot_go(struct boot_rsp *rsp)
{
 c00867c:	4601      	mov	r1, r0
    return context_boot_go(&boot_data, rsp);
 c00867e:	4801      	ldr	r0, [pc, #4]	; (c008684 <boot_go+0x8>)
 c008680:	f7ff beaa 	b.w	c0083d8 <context_boot_go>
 c008684:	300324b4 	.word	0x300324b4

0c008688 <boot_read_image_header>:
#endif

int
boot_read_image_header(struct boot_loader_state *state, int slot,
                       struct image_header *out_hdr, struct boot_status *bs)
{
 c008688:	b51f      	push	{r0, r1, r2, r3, r4, lr}

#if (BOOT_IMAGE_NUMBER == 1)
    (void)state;
#endif

    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c00868a:	2000      	movs	r0, #0
{
 c00868c:	9201      	str	r2, [sp, #4]
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c00868e:	f000 f985 	bl	c00899c <flash_area_id_from_multi_image_slot>
    rc = flash_area_open(area_id, &fap);
 c008692:	a903      	add	r1, sp, #12
 c008694:	b2c0      	uxtb	r0, r0
 c008696:	f000 f915 	bl	c0088c4 <flash_area_open>
    if (rc != 0) {
 c00869a:	4601      	mov	r1, r0
 c00869c:	b968      	cbnz	r0, c0086ba <boot_read_image_header+0x32>
        rc = BOOT_EFLASH;
        goto done;
    }

    rc = flash_area_read(fap, 0, out_hdr, sizeof *out_hdr);
 c00869e:	2320      	movs	r3, #32
 c0086a0:	9a01      	ldr	r2, [sp, #4]
 c0086a2:	9803      	ldr	r0, [sp, #12]
 c0086a4:	f000 f91a 	bl	c0088dc <flash_area_read>
    if (rc != 0) {
 c0086a8:	1e04      	subs	r4, r0, #0
 c0086aa:	bf18      	it	ne
 c0086ac:	2401      	movne	r4, #1
    }

    rc = 0;

done:
    flash_area_close(fap);
 c0086ae:	9803      	ldr	r0, [sp, #12]
 c0086b0:	f000 f912 	bl	c0088d8 <flash_area_close>
    return rc;
}
 c0086b4:	4620      	mov	r0, r4
 c0086b6:	b004      	add	sp, #16
 c0086b8:	bd10      	pop	{r4, pc}
        rc = BOOT_EFLASH;
 c0086ba:	2401      	movs	r4, #1
 c0086bc:	e7f7      	b.n	c0086ae <boot_read_image_header+0x26>

0c0086be <bootutil_tlv_iter_begin>:
 *          -1 on errors
 */
int
bootutil_tlv_iter_begin(struct image_tlv_iter *it, const struct image_header *hdr,
                        const struct flash_area *fap, uint16_t type, bool prot)
{
 c0086be:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c0086c2:	460e      	mov	r6, r1
 c0086c4:	4617      	mov	r7, r2
 c0086c6:	4699      	mov	r9, r3
    uint32_t off_;
    struct image_tlv_info info;

    if (it == NULL || hdr == NULL || fap == NULL) {
 c0086c8:	4604      	mov	r4, r0
 c0086ca:	b928      	cbnz	r0, c0086d8 <bootutil_tlv_iter_begin+0x1a>
        return -1;
 c0086cc:	f04f 38ff 	mov.w	r8, #4294967295
    it->prot_end = off_ + it->hdr->ih_protect_tlv_size;
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
    // position on first TLV
    it->tlv_off = off_ + sizeof(info);
    return 0;
}
 c0086d0:	4640      	mov	r0, r8
 c0086d2:	b003      	add	sp, #12
 c0086d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (it == NULL || hdr == NULL || fap == NULL) {
 c0086d8:	2900      	cmp	r1, #0
 c0086da:	d0f7      	beq.n	c0086cc <bootutil_tlv_iter_begin+0xe>
 c0086dc:	2a00      	cmp	r2, #0
 c0086de:	d0f5      	beq.n	c0086cc <bootutil_tlv_iter_begin+0xe>
    off_ = BOOT_TLV_OFF(hdr);
 c0086e0:	68cb      	ldr	r3, [r1, #12]
 c0086e2:	890d      	ldrh	r5, [r1, #8]
    if (flash_area_read(fap, off_, &info, sizeof(info))) {
 c0086e4:	4638      	mov	r0, r7
    off_ = BOOT_TLV_OFF(hdr);
 c0086e6:	441d      	add	r5, r3
    if (flash_area_read(fap, off_, &info, sizeof(info))) {
 c0086e8:	2304      	movs	r3, #4
 c0086ea:	4629      	mov	r1, r5
 c0086ec:	eb0d 0203 	add.w	r2, sp, r3
 c0086f0:	f000 f8f4 	bl	c0088dc <flash_area_read>
 c0086f4:	4680      	mov	r8, r0
 c0086f6:	2800      	cmp	r0, #0
 c0086f8:	d1e8      	bne.n	c0086cc <bootutil_tlv_iter_begin+0xe>
    if (info.it_magic == IMAGE_TLV_PROT_INFO_MAGIC) {
 c0086fa:	f646 1208 	movw	r2, #26888	; 0x6908
 c0086fe:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 c008702:	8973      	ldrh	r3, [r6, #10]
 c008704:	4291      	cmp	r1, r2
 c008706:	d123      	bne.n	c008750 <bootutil_tlv_iter_begin+0x92>
        if (hdr->ih_protect_tlv_size != info.it_tlv_tot) {
 c008708:	f8bd 1006 	ldrh.w	r1, [sp, #6]
 c00870c:	4299      	cmp	r1, r3
 c00870e:	d1dd      	bne.n	c0086cc <bootutil_tlv_iter_begin+0xe>
        if (flash_area_read(fap, off_ + info.it_tlv_tot, &info, sizeof(info))) {
 c008710:	2304      	movs	r3, #4
 c008712:	4638      	mov	r0, r7
 c008714:	eb0d 0203 	add.w	r2, sp, r3
 c008718:	4429      	add	r1, r5
 c00871a:	f000 f8df 	bl	c0088dc <flash_area_read>
 c00871e:	2800      	cmp	r0, #0
 c008720:	d1d4      	bne.n	c0086cc <bootutil_tlv_iter_begin+0xe>
    if (info.it_magic != IMAGE_TLV_INFO_MAGIC) {
 c008722:	f646 1307 	movw	r3, #26887	; 0x6907
 c008726:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 c00872a:	429a      	cmp	r2, r3
 c00872c:	d1ce      	bne.n	c0086cc <bootutil_tlv_iter_begin+0xe>
    it->prot = prot;
 c00872e:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
 c008732:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    it->prot = prot;
 c008736:	72a3      	strb	r3, [r4, #10]
    it->prot_end = off_ + it->hdr->ih_protect_tlv_size;
 c008738:	8973      	ldrh	r3, [r6, #10]
    it->fap = fap;
 c00873a:	e9c4 6700 	strd	r6, r7, [r4]
    it->prot_end = off_ + it->hdr->ih_protect_tlv_size;
 c00873e:	442b      	add	r3, r5
 c008740:	60e3      	str	r3, [r4, #12]
    it->tlv_off = off_ + sizeof(info);
 c008742:	3504      	adds	r5, #4
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
 c008744:	4413      	add	r3, r2
    it->type = type;
 c008746:	f8a4 9008 	strh.w	r9, [r4, #8]
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
 c00874a:	6163      	str	r3, [r4, #20]
    it->tlv_off = off_ + sizeof(info);
 c00874c:	6125      	str	r5, [r4, #16]
    return 0;
 c00874e:	e7bf      	b.n	c0086d0 <bootutil_tlv_iter_begin+0x12>
    } else if (hdr->ih_protect_tlv_size != 0) {
 c008750:	2b00      	cmp	r3, #0
 c008752:	d0e6      	beq.n	c008722 <bootutil_tlv_iter_begin+0x64>
 c008754:	e7ba      	b.n	c0086cc <bootutil_tlv_iter_begin+0xe>

0c008756 <bootutil_tlv_iter_next>:
 *          -1 on errors
 */
int
bootutil_tlv_iter_next(struct image_tlv_iter *it, uint32_t *off, uint16_t *len,
                       uint16_t *type)
{
 c008756:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c00875a:	460f      	mov	r7, r1
 c00875c:	4690      	mov	r8, r2
 c00875e:	461e      	mov	r6, r3
    struct image_tlv tlv;
    int rc;

    if (it == NULL || it->hdr == NULL || it->fap == NULL) {
 c008760:	4604      	mov	r4, r0
 c008762:	b920      	cbnz	r0, c00876e <bootutil_tlv_iter_next+0x18>
        return -1;
 c008764:	f04f 30ff 	mov.w	r0, #4294967295

        it->tlv_off += sizeof(tlv) + tlv.it_len;
    }

    return 1;
}
 c008768:	b003      	add	sp, #12
 c00876a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (it == NULL || it->hdr == NULL || it->fap == NULL) {
 c00876e:	6803      	ldr	r3, [r0, #0]
 c008770:	2b00      	cmp	r3, #0
 c008772:	d0f7      	beq.n	c008764 <bootutil_tlv_iter_next+0xe>
 c008774:	6843      	ldr	r3, [r0, #4]
 c008776:	2b00      	cmp	r3, #0
 c008778:	d0f4      	beq.n	c008764 <bootutil_tlv_iter_next+0xe>
        if (it->type == IMAGE_TLV_ANY || tlv.it_type == it->type) {
 c00877a:	f64f 79ff 	movw	r9, #65535	; 0xffff
    while (it->tlv_off < it->tlv_end) {
 c00877e:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
 c008782:	429a      	cmp	r2, r3
 c008784:	d216      	bcs.n	c0087b4 <bootutil_tlv_iter_next+0x5e>
        if (it->hdr->ih_protect_tlv_size > 0 && it->tlv_off == it->prot_end) {
 c008786:	6823      	ldr	r3, [r4, #0]
 c008788:	895b      	ldrh	r3, [r3, #10]
 c00878a:	b123      	cbz	r3, c008796 <bootutil_tlv_iter_next+0x40>
 c00878c:	68e3      	ldr	r3, [r4, #12]
 c00878e:	4293      	cmp	r3, r2
            it->tlv_off += sizeof(struct image_tlv_info);
 c008790:	bf04      	itt	eq
 c008792:	3304      	addeq	r3, #4
 c008794:	6123      	streq	r3, [r4, #16]
        rc = flash_area_read(it->fap, it->tlv_off, &tlv, sizeof tlv);
 c008796:	2304      	movs	r3, #4
 c008798:	6921      	ldr	r1, [r4, #16]
 c00879a:	6860      	ldr	r0, [r4, #4]
 c00879c:	eb0d 0203 	add.w	r2, sp, r3
 c0087a0:	f000 f89c 	bl	c0088dc <flash_area_read>
        if (rc) {
 c0087a4:	2800      	cmp	r0, #0
 c0087a6:	d1dd      	bne.n	c008764 <bootutil_tlv_iter_next+0xe>
        if (it->prot && it->tlv_off >= it->prot_end) {
 c0087a8:	7aa3      	ldrb	r3, [r4, #10]
 c0087aa:	6925      	ldr	r5, [r4, #16]
 c0087ac:	b123      	cbz	r3, c0087b8 <bootutil_tlv_iter_next+0x62>
 c0087ae:	68e3      	ldr	r3, [r4, #12]
 c0087b0:	42ab      	cmp	r3, r5
 c0087b2:	d801      	bhi.n	c0087b8 <bootutil_tlv_iter_next+0x62>
            return 1;
 c0087b4:	2001      	movs	r0, #1
 c0087b6:	e7d7      	b.n	c008768 <bootutil_tlv_iter_next+0x12>
        if (it->type == IMAGE_TLV_ANY || tlv.it_type == it->type) {
 c0087b8:	8921      	ldrh	r1, [r4, #8]
 c0087ba:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 c0087be:	4549      	cmp	r1, r9
 c0087c0:	f103 0204 	add.w	r2, r3, #4
 c0087c4:	d003      	beq.n	c0087ce <bootutil_tlv_iter_next+0x78>
 c0087c6:	f8bd c004 	ldrh.w	ip, [sp, #4]
 c0087ca:	458c      	cmp	ip, r1
 c0087cc:	d10b      	bne.n	c0087e6 <bootutil_tlv_iter_next+0x90>
            if (type != NULL) {
 c0087ce:	b116      	cbz	r6, c0087d6 <bootutil_tlv_iter_next+0x80>
                *type = tlv.it_type;
 c0087d0:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 c0087d4:	8031      	strh	r1, [r6, #0]
            *off = it->tlv_off + sizeof(tlv);
 c0087d6:	3504      	adds	r5, #4
 c0087d8:	603d      	str	r5, [r7, #0]
            *len = tlv.it_len;
 c0087da:	f8a8 3000 	strh.w	r3, [r8]
            it->tlv_off += sizeof(tlv) + tlv.it_len;
 c0087de:	6923      	ldr	r3, [r4, #16]
 c0087e0:	4413      	add	r3, r2
 c0087e2:	6123      	str	r3, [r4, #16]
            return 0;
 c0087e4:	e7c0      	b.n	c008768 <bootutil_tlv_iter_next+0x12>
        it->tlv_off += sizeof(tlv) + tlv.it_len;
 c0087e6:	4415      	add	r5, r2
 c0087e8:	6125      	str	r5, [r4, #16]
 c0087ea:	e7c8      	b.n	c00877e <bootutil_tlv_iter_next+0x28>

0c0087ec <main>:

    jumper(vt);
}

int main(void)
{
 c0087ec:	b530      	push	{r4, r5, lr}
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 c0087ee:	4b2a      	ldr	r3, [pc, #168]	; (c008898 <main+0xac>)
 c0087f0:	b085      	sub	sp, #20
 c0087f2:	f383 880a 	msr	MSPLIM, r3
#if defined(__ARM_ARCH_8M_MAIN__) || defined(__ARM_ARCH_8M_BASE__)
    __set_MSPLIM(msp_stack_bottom);
#endif

    /* Perform platform specific initialization */
    if (boot_platform_init() != 0) {
 c0087f6:	f7f9 fcbb 	bl	c002170 <boot_platform_init>
 c0087fa:	b100      	cbz	r0, c0087fe <main+0x12>
        while (1)
 c0087fc:	e7fe      	b.n	c0087fc <main+0x10>
            ;
    }

#if MCUBOOT_LOG_LEVEL > MCUBOOT_LOG_LEVEL_OFF
    stdio_init();
 c0087fe:	f000 f979 	bl	c008af4 <stdio_init>
#endif

    BOOT_LOG_INF("Starting bootloader");
 c008802:	4826      	ldr	r0, [pc, #152]	; (c00889c <main+0xb0>)
 c008804:	f000 fb08 	bl	c008e18 <puts>

    /* Initialise the mbedtls static memory allocator so that mbedtls allocates
     * memory from the provided static buffer instead of from the heap.
     */
    mbedtls_memory_buffer_alloc_init(mbedtls_mem_buf, BL2_MBEDTLS_MEM_BUF_LEN);
 c008808:	f44f 41e4 	mov.w	r1, #29184	; 0x7200
 c00880c:	4824      	ldr	r0, [pc, #144]	; (c0088a0 <main+0xb4>)
 c00880e:	f7fe fa95 	bl	c006d3c <mbedtls_memory_buffer_alloc_init>

    rc = boot_nv_security_counter_init();
 c008812:	f000 f92b 	bl	c008a6c <boot_nv_security_counter_init>
    if (rc != 0) {
 c008816:	b120      	cbz	r0, c008822 <main+0x36>
        BOOT_LOG_ERR("Error while initializing the security counter");
 c008818:	4822      	ldr	r0, [pc, #136]	; (c0088a4 <main+0xb8>)
 c00881a:	f000 fafd 	bl	c008e18 <puts>
        Error_Handler();
 c00881e:	f004 f88f 	bl	c00c940 <Error_Handler>
    }


    rc = boot_go(&rsp);
 c008822:	a801      	add	r0, sp, #4
 c008824:	f7ff ff2a 	bl	c00867c <boot_go>
    if (rc != 0) {
 c008828:	b120      	cbz	r0, c008834 <main+0x48>
        BOOT_LOG_ERR("Unable to find bootable image");
 c00882a:	481f      	ldr	r0, [pc, #124]	; (c0088a8 <main+0xbc>)
 c00882c:	f000 faf4 	bl	c008e18 <puts>
#ifdef MCUBOOT_EXT_LOADER
       boot_platform_noimage();
 c008830:	f7f9 fbf0 	bl	c002014 <boot_platform_noimage>
	   Error_Handler();
#endif
    }


    BOOT_LOG_INF("Bootloader chainload address offset: 0x%x",
 c008834:	9903      	ldr	r1, [sp, #12]
 c008836:	481d      	ldr	r0, [pc, #116]	; (c0088ac <main+0xc0>)
 c008838:	f000 fa68 	bl	c008d0c <iprintf>
                 rsp.br_image_off);
    BOOT_LOG_INF("Jumping to the first image slot");
 c00883c:	481c      	ldr	r0, [pc, #112]	; (c0088b0 <main+0xc4>)
 c00883e:	f000 faeb 	bl	c008e18 <puts>
    rc = flash_device_base(rsp->br_flash_dev_id, &flash_base);
 c008842:	4669      	mov	r1, sp
 c008844:	f89d 0008 	ldrb.w	r0, [sp, #8]
 c008848:	f000 f898 	bl	c00897c <flash_device_base>
    if (rsp->br_hdr->ih_flags & IMAGE_F_RAM_LOAD) {
 c00884c:	9a01      	ldr	r2, [sp, #4]
 c00884e:	4c19      	ldr	r4, [pc, #100]	; (c0088b4 <main+0xc8>)
 c008850:	6913      	ldr	r3, [r2, #16]
 c008852:	f013 0f20 	tst.w	r3, #32
        vt = (struct arm_vector_table *)(flash_base +
 c008856:	bf08      	it	eq
 c008858:	9900      	ldreq	r1, [sp, #0]
 c00885a:	8913      	ldrh	r3, [r2, #8]
 c00885c:	bf0a      	itet	eq
 c00885e:	9a03      	ldreq	r2, [sp, #12]
        vt = (struct arm_vector_table *)(rsp->br_hdr->ih_load_addr +
 c008860:	6852      	ldrne	r2, [r2, #4]
        vt = (struct arm_vector_table *)(flash_base +
 c008862:	1852      	addeq	r2, r2, r1
                                         rsp->br_image_off +
 c008864:	4413      	add	r3, r2
 c008866:	6023      	str	r3, [r4, #0]
    rc = FLASH_DEV_NAME.Uninitialize();
 c008868:	4b13      	ldr	r3, [pc, #76]	; (c0088b8 <main+0xcc>)
 c00886a:	68db      	ldr	r3, [r3, #12]
 c00886c:	4798      	blx	r3
    if(rc != ARM_DRIVER_OK) {
 c00886e:	b110      	cbz	r0, c008876 <main+0x8a>
        BOOT_LOG_ERR("Error while uninitializing Flash Interface");
 c008870:	4812      	ldr	r0, [pc, #72]	; (c0088bc <main+0xd0>)
 c008872:	f000 fad1 	bl	c008e18 <puts>
    stdio_uninit();
 c008876:	f000 f94b 	bl	c008b10 <stdio_uninit>
 c00887a:	2500      	movs	r5, #0
 c00887c:	f385 880a 	msr	MSPLIM, r5
    jumper(vt);
 c008880:	6820      	ldr	r0, [r4, #0]
 c008882:	f004 f893 	bl	c00c9ac <jumper>
    do_boot(&rsp);

    BOOT_LOG_ERR("Never should get here");
 c008886:	480e      	ldr	r0, [pc, #56]	; (c0088c0 <main+0xd4>)
 c008888:	f000 fac6 	bl	c008e18 <puts>
    Error_Handler();
 c00888c:	f004 f858 	bl	c00c940 <Error_Handler>
    return 0;
}
 c008890:	4628      	mov	r0, r5
 c008892:	b005      	add	sp, #20
 c008894:	bd30      	pop	{r4, r5, pc}
 c008896:	bf00      	nop
 c008898:	3003bed4 	.word	0x3003bed4
 c00889c:	0c00abc3 	.word	0x0c00abc3
 c0088a0:	30034cb4 	.word	0x30034cb4
 c0088a4:	0c00abde 	.word	0x0c00abde
 c0088a8:	0c00ac13 	.word	0x0c00ac13
 c0088ac:	0c00ac38 	.word	0x0c00ac38
 c0088b0:	0c00ac6a 	.word	0x0c00ac6a
 c0088b4:	3003beb4 	.word	0x3003beb4
 c0088b8:	0c00a264 	.word	0x0c00a264
 c0088bc:	0c00ac91 	.word	0x0c00ac91
 c0088c0:	0c00acc3 	.word	0x0c00acc3

0c0088c4 <flash_area_open>:
    int i;

    BOOT_LOG_DBG("area %d", id);

    for (i = 0; i < flash_map_entry_num; i++) {
        if (id == flash_map[i].fa_id) {
 c0088c4:	2801      	cmp	r0, #1
    }
    if (i == flash_map_entry_num) {
        return -1;
    }

    *area = &flash_map[i];
 c0088c6:	bf03      	ittte	eq
 c0088c8:	4b02      	ldreq	r3, [pc, #8]	; (c0088d4 <flash_area_open+0x10>)
    return 0;
 c0088ca:	2000      	moveq	r0, #0
    *area = &flash_map[i];
 c0088cc:	600b      	streq	r3, [r1, #0]
        return -1;
 c0088ce:	f04f 30ff 	movne.w	r0, #4294967295
}
 c0088d2:	4770      	bx	lr
 c0088d4:	0c00ace0 	.word	0x0c00ace0

0c0088d8 <flash_area_close>:

void flash_area_close(const struct flash_area *area)
{
    /* Nothing to do. */
}
 c0088d8:	4770      	bx	lr
	...

0c0088dc <flash_area_read>:

int flash_area_read(const struct flash_area *area, uint32_t off, void *dst,
                    uint32_t len)
{
 c0088dc:	b470      	push	{r4, r5, r6}
 c0088de:	460e      	mov	r6, r1
    BOOT_LOG_DBG("read area=%d, off=%#x, len=%#x", area->fa_id, off, len);
    return driver_list[area->fa_device_id]->ReadData(area->fa_off + off, dst, len);;
 c0088e0:	6845      	ldr	r5, [r0, #4]
{
 c0088e2:	4611      	mov	r1, r2
    return driver_list[area->fa_device_id]->ReadData(area->fa_off + off, dst, len);;
 c0088e4:	7840      	ldrb	r0, [r0, #1]
 c0088e6:	4a04      	ldr	r2, [pc, #16]	; (c0088f8 <flash_area_read+0x1c>)
 c0088e8:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 c0088ec:	1970      	adds	r0, r6, r5
 c0088ee:	6954      	ldr	r4, [r2, #20]
 c0088f0:	461a      	mov	r2, r3
 c0088f2:	4623      	mov	r3, r4
}
 c0088f4:	bc70      	pop	{r4, r5, r6}
    return driver_list[area->fa_device_id]->ReadData(area->fa_off + off, dst, len);;
 c0088f6:	4718      	bx	r3
 c0088f8:	3003008c 	.word	0x3003008c

0c0088fc <flash_area_write>:

int flash_area_write(const struct flash_area *area, uint32_t off,
                     const void *src, uint32_t len)
{
 c0088fc:	b470      	push	{r4, r5, r6}
 c0088fe:	460e      	mov	r6, r1
    BOOT_LOG_DBG("write area=%d, off=%#x, len=%#x", area->fa_id, off, len);
    return driver_list[area->fa_device_id]->ProgramData(area->fa_off + off, src, len);
 c008900:	6845      	ldr	r5, [r0, #4]
{
 c008902:	4611      	mov	r1, r2
    return driver_list[area->fa_device_id]->ProgramData(area->fa_off + off, src, len);
 c008904:	7840      	ldrb	r0, [r0, #1]
 c008906:	4a04      	ldr	r2, [pc, #16]	; (c008918 <flash_area_write+0x1c>)
 c008908:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 c00890c:	1970      	adds	r0, r6, r5
 c00890e:	6994      	ldr	r4, [r2, #24]
 c008910:	461a      	mov	r2, r3
 c008912:	4623      	mov	r3, r4
}
 c008914:	bc70      	pop	{r4, r5, r6}
    return driver_list[area->fa_device_id]->ProgramData(area->fa_off + off, src, len);
 c008916:	4718      	bx	r3
 c008918:	3003008c 	.word	0x3003008c

0c00891c <flash_area_erase>:

int flash_area_erase(const struct flash_area *area, uint32_t off, uint32_t len)
{
 c00891c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ARM_FLASH_INFO *flash_info;
    uint32_t deleted_len = 0;
    int32_t rc = 0;

    BOOT_LOG_DBG("erase area=%d, off=%#x, len=%#x", area->fa_id, off, len);
    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c008920:	f8df 903c 	ldr.w	r9, [pc, #60]	; c008960 <flash_area_erase+0x44>
 c008924:	7843      	ldrb	r3, [r0, #1]
{
 c008926:	4605      	mov	r5, r0
    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c008928:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
{
 c00892c:	460e      	mov	r6, r1
    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c00892e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
{
 c008930:	4690      	mov	r8, r2
    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c008932:	4798      	blx	r3

    if (flash_info->sector_info == NULL) {
 c008934:	6804      	ldr	r4, [r0, #0]
    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c008936:	4607      	mov	r7, r0
    if (flash_info->sector_info == NULL) {
 c008938:	b174      	cbz	r4, c008958 <flash_area_erase+0x3c>
    int32_t rc = 0;
 c00893a:	2000      	movs	r0, #0
         * Currently not supported.
         */
    }

    return rc;
}
 c00893c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            rc = driver_list[area->fa_device_id]->EraseSector(area->fa_off + off);
 c008940:	786b      	ldrb	r3, [r5, #1]
 c008942:	6868      	ldr	r0, [r5, #4]
 c008944:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 c008948:	4430      	add	r0, r6
 c00894a:	69db      	ldr	r3, [r3, #28]
 c00894c:	4798      	blx	r3
            if (rc != 0) {
 c00894e:	2800      	cmp	r0, #0
 c008950:	d1f4      	bne.n	c00893c <flash_area_erase+0x20>
            deleted_len += flash_info->sector_size;
 c008952:	68bb      	ldr	r3, [r7, #8]
 c008954:	441c      	add	r4, r3
            off         += flash_info->sector_size;
 c008956:	441e      	add	r6, r3
        while (deleted_len < len) {
 c008958:	4544      	cmp	r4, r8
 c00895a:	d3f1      	bcc.n	c008940 <flash_area_erase+0x24>
 c00895c:	e7ed      	b.n	c00893a <flash_area_erase+0x1e>
 c00895e:	bf00      	nop
 c008960:	3003008c 	.word	0x3003008c

0c008964 <flash_area_align>:

uint32_t flash_area_align(const struct flash_area *area)
{
 c008964:	b508      	push	{r3, lr}
    ARM_FLASH_INFO *flash_info;

    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c008966:	4b04      	ldr	r3, [pc, #16]	; (c008978 <flash_area_align+0x14>)
 c008968:	7842      	ldrb	r2, [r0, #1]
 c00896a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c00896e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 c008970:	4798      	blx	r3
    return flash_info->program_unit;
}
 c008972:	6900      	ldr	r0, [r0, #16]
 c008974:	bd08      	pop	{r3, pc}
 c008976:	bf00      	nop
 c008978:	3003008c 	.word	0x3003008c

0c00897c <flash_device_base>:
/* Flash device name must be specified by target */
extern ARM_DRIVER_FLASH* driver_list[2];


int flash_device_base(uint8_t fd_id, uintptr_t *ret)
{
 c00897c:	b508      	push	{r3, lr}
    if ((fd_id +FLASH_DEVICE_ID) == FLASH_DEVICE_ID) {
 c00897e:	b918      	cbnz	r0, c008988 <flash_device_base+0xc>
        *ret = FLASH_BASE_ADDRESS;
 c008980:	f04f 6340 	mov.w	r3, #201326592	; 0xc000000
 c008984:	600b      	str	r3, [r1, #0]
                     (fd_id + FLASH_DEVICE_ID), FLASH_DEVICE_ID);
        return -1;
    }
#endif /* TFM_EXTERNAL_FLASH_ENABLE */
    return 0;
}
 c008986:	bd08      	pop	{r3, pc}
        BOOT_LOG_ERR("invalid flash ID %d; expected %d",
 c008988:	2264      	movs	r2, #100	; 0x64
 c00898a:	1881      	adds	r1, r0, r2
 c00898c:	4802      	ldr	r0, [pc, #8]	; (c008998 <flash_device_base+0x1c>)
 c00898e:	f000 f9bd 	bl	c008d0c <iprintf>
        return -1;
 c008992:	f04f 30ff 	mov.w	r0, #4294967295
 c008996:	e7f6      	b.n	c008986 <flash_device_base+0xa>
 c008998:	0c00acec 	.word	0x0c00acec

0c00899c <flash_area_id_from_multi_image_slot>:
 * MCUBoot uses continuous numbering for the primary slot, the secondary slot,
 * and the scratch while TF-M might number it differently.
 */
int flash_area_id_from_multi_image_slot(int image_index, int slot)
{
    switch (slot) {
 c00899c:	2900      	cmp	r1, #0
    case 2: return FLASH_AREA_IMAGE_SCRATCH;
#endif
    }

    return -1; /* flash_area_open will fail on that */
}
 c00899e:	bf0c      	ite	eq
 c0089a0:	2001      	moveq	r0, #1
 c0089a2:	f04f 30ff 	movne.w	r0, #4294967295
 c0089a6:	4770      	bx	lr

0c0089a8 <flash_area_id_to_multi_image_slot>:
    return flash_area_id_from_multi_image_slot(0, slot);
}

int flash_area_id_to_multi_image_slot(int image_index, int area_id)
{
    if (area_id == FLASH_AREA_IMAGE_PRIMARY(image_index)) {
 c0089a8:	2901      	cmp	r1, #1
{
 c0089aa:	b508      	push	{r3, lr}
    if (area_id == FLASH_AREA_IMAGE_PRIMARY(image_index)) {
 c0089ac:	d005      	beq.n	c0089ba <flash_area_id_to_multi_image_slot+0x12>
#if !defined(MCUBOOT_PRIMARY_ONLY)
    if (area_id == FLASH_AREA_IMAGE_SECONDARY(image_index)) {
        return 1;
    }
#endif
    BOOT_LOG_ERR("invalid flash area ID");
 c0089ae:	4804      	ldr	r0, [pc, #16]	; (c0089c0 <flash_area_id_to_multi_image_slot+0x18>)
 c0089b0:	f000 fa32 	bl	c008e18 <puts>
    return -1;
 c0089b4:	f04f 30ff 	mov.w	r0, #4294967295
}
 c0089b8:	bd08      	pop	{r3, pc}
        return 0;
 c0089ba:	2000      	movs	r0, #0
 c0089bc:	e7fc      	b.n	c0089b8 <flash_area_id_to_multi_image_slot+0x10>
 c0089be:	bf00      	nop
 c0089c0:	0c00ad15 	.word	0x0c00ad15

0c0089c4 <flash_area_erased_val>:
{
    return flash_area_id_to_multi_image_slot(0, area_id);
}

uint8_t flash_area_erased_val(const struct flash_area *fap)
{
 c0089c4:	b508      	push	{r3, lr}
    (void)fap;

    return driver_list[fap->fa_device_id]->GetInfo()->erased_value;;
 c0089c6:	4b04      	ldr	r3, [pc, #16]	; (c0089d8 <flash_area_erased_val+0x14>)
 c0089c8:	7842      	ldrb	r2, [r0, #1]
 c0089ca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c0089ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 c0089d0:	4798      	blx	r3
}
 c0089d2:	7d00      	ldrb	r0, [r0, #20]
 c0089d4:	bd08      	pop	{r3, pc}
 c0089d6:	bf00      	nop
 c0089d8:	3003008c 	.word	0x3003008c

0c0089dc <flash_area_get_sectors>:
 * `ret` with all of the sectors in the area.  `*cnt` will be set to
 * the storage at `ret` and should be set to the final number of
 * sectors in this area.
 */
int flash_area_get_sectors(int idx, uint32_t *cnt, struct flash_sector *ret)
{
 c0089dc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    const struct flash_area *fa;
    uint32_t max_cnt = *cnt;
 c0089e0:	f8d1 8000 	ldr.w	r8, [r1]
{
 c0089e4:	4606      	mov	r6, r0
 c0089e6:	460d      	mov	r5, r1
    uint32_t rem_len;
    int rc = -1;

    if (flash_area_open(idx, &fa)) {
 c0089e8:	b2c0      	uxtb	r0, r0
 c0089ea:	a901      	add	r1, sp, #4
{
 c0089ec:	4617      	mov	r7, r2
    if (flash_area_open(idx, &fa)) {
 c0089ee:	f7ff ff69 	bl	c0088c4 <flash_area_open>
 c0089f2:	4604      	mov	r4, r0
 c0089f4:	2800      	cmp	r0, #0
 c0089f6:	d132      	bne.n	c008a5e <flash_area_get_sectors+0x82>
    }

    BOOT_LOG_DBG("area %d: offset=0x%x, length=0x%x", idx, fa->fa_off,
                 fa->fa_size);

    if (*cnt < 1) {
 c0089f8:	682b      	ldr	r3, [r5, #0]
 c0089fa:	b1cb      	cbz	r3, c008a30 <flash_area_get_sectors+0x54>
    BOOT_LOG_DBG("area %d: offset=0x%x, length=0x%x", idx, fa->fa_off,
 c0089fc:	9a01      	ldr	r2, [sp, #4]
        goto fa_close_out;
    }

    rem_len = fa->fa_size;
 c0089fe:	6891      	ldr	r1, [r2, #8]
    *cnt = 0;
 c008a00:	6028      	str	r0, [r5, #0]
                         idx, fa->fa_size, FLASH_AREA_IMAGE_SECTOR_SIZE);
            goto fa_close_out;
        }

        ret[*cnt].fs_off = FLASH_AREA_IMAGE_SECTOR_SIZE * (*cnt);
        ret[*cnt].fs_size = FLASH_AREA_IMAGE_SECTOR_SIZE;
 c008a02:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    while (rem_len > 0 && *cnt < max_cnt) {
 c008a06:	682b      	ldr	r3, [r5, #0]
 c008a08:	b109      	cbz	r1, c008a0e <flash_area_get_sectors+0x32>
 c008a0a:	4598      	cmp	r8, r3
 c008a0c:	d806      	bhi.n	c008a1c <flash_area_get_sectors+0x40>
        *cnt = *cnt + 1;
        rem_len -= FLASH_AREA_IMAGE_SECTOR_SIZE;
    }

    if (*cnt > max_cnt) {
 c008a0e:	4598      	cmp	r8, r3
 c008a10:	d210      	bcs.n	c008a34 <flash_area_get_sectors+0x58>
        BOOT_LOG_ERR("flash area %d sector count overflow", idx);
 c008a12:	4631      	mov	r1, r6
 c008a14:	4813      	ldr	r0, [pc, #76]	; (c008a64 <flash_area_get_sectors+0x88>)
 c008a16:	f000 f979 	bl	c008d0c <iprintf>
        goto fa_close_out;
 c008a1a:	e009      	b.n	c008a30 <flash_area_get_sectors+0x54>
        if (rem_len < FLASH_AREA_IMAGE_SECTOR_SIZE) {
 c008a1c:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 c008a20:	d20f      	bcs.n	c008a42 <flash_area_get_sectors+0x66>
            BOOT_LOG_ERR("area %d size 0x%x not divisible by sector size 0x%x",
 c008a22:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 c008a26:	4631      	mov	r1, r6
 c008a28:	6892      	ldr	r2, [r2, #8]
 c008a2a:	480f      	ldr	r0, [pc, #60]	; (c008a68 <flash_area_get_sectors+0x8c>)
 c008a2c:	f000 f96e 	bl	c008d0c <iprintf>
    int rc = -1;
 c008a30:	f04f 34ff 	mov.w	r4, #4294967295
    }

    rc = 0;

fa_close_out:
    flash_area_close(fa);
 c008a34:	9801      	ldr	r0, [sp, #4]
 c008a36:	f7ff ff4f 	bl	c0088d8 <flash_area_close>
out:
    return rc;
}
 c008a3a:	4620      	mov	r0, r4
 c008a3c:	b002      	add	sp, #8
 c008a3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ret[*cnt].fs_off = FLASH_AREA_IMAGE_SECTOR_SIZE * (*cnt);
 c008a42:	ea4f 3c03 	mov.w	ip, r3, lsl #12
 c008a46:	f847 c033 	str.w	ip, [r7, r3, lsl #3]
        ret[*cnt].fs_size = FLASH_AREA_IMAGE_SECTOR_SIZE;
 c008a4a:	682b      	ldr	r3, [r5, #0]
        rem_len -= FLASH_AREA_IMAGE_SECTOR_SIZE;
 c008a4c:	f5a1 5180 	sub.w	r1, r1, #4096	; 0x1000
        ret[*cnt].fs_size = FLASH_AREA_IMAGE_SECTOR_SIZE;
 c008a50:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 c008a54:	6058      	str	r0, [r3, #4]
        *cnt = *cnt + 1;
 c008a56:	682b      	ldr	r3, [r5, #0]
 c008a58:	3301      	adds	r3, #1
 c008a5a:	602b      	str	r3, [r5, #0]
        rem_len -= FLASH_AREA_IMAGE_SECTOR_SIZE;
 c008a5c:	e7d3      	b.n	c008a06 <flash_area_get_sectors+0x2a>
    int rc = -1;
 c008a5e:	f04f 34ff 	mov.w	r4, #4294967295
    return rc;
 c008a62:	e7ea      	b.n	c008a3a <flash_area_get_sectors+0x5e>
 c008a64:	0c00ad6e 	.word	0x0c00ad6e
 c008a68:	0c00ad32 	.word	0x0c00ad32

0c008a6c <boot_nv_security_counter_init>:

    return (enum tfm_nv_counter_t)nv_counter;
}

int32_t boot_nv_security_counter_init(void)
{
 c008a6c:	b508      	push	{r3, lr}
    enum tfm_plat_err_t err;

    err = tfm_plat_init_nv_counter();
 c008a6e:	f7f9 f97f 	bl	c001d70 <tfm_plat_init_nv_counter>
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c008a72:	3800      	subs	r0, #0
 c008a74:	bf18      	it	ne
 c008a76:	2001      	movne	r0, #1
        return -1;
    }

    return 0;
}
 c008a78:	4240      	negs	r0, r0
 c008a7a:	bd08      	pop	{r3, pc}

0c008a7c <boot_nv_security_counter_get>:
{
    enum tfm_nv_counter_t nv_counter;
    enum tfm_plat_err_t err;

    /* Check if it's a null-pointer. */
    if (!security_cnt) {
 c008a7c:	460a      	mov	r2, r1
{
 c008a7e:	b508      	push	{r3, lr}
    if (!security_cnt) {
 c008a80:	b169      	cbz	r1, c008a9e <boot_nv_security_counter_get+0x22>
    if ((UINT32_MAX - TFM_BOOT_NV_COUNTER_0) < image_id) {
 c008a82:	1d03      	adds	r3, r0, #4
 c008a84:	d80b      	bhi.n	c008a9e <boot_nv_security_counter_get+0x22>
    nv_counter = TFM_BOOT_NV_COUNTER_0 + image_id;
 c008a86:	3003      	adds	r0, #3
    if (nv_counter >= TFM_BOOT_NV_COUNTER_MAX) {
 c008a88:	2804      	cmp	r0, #4
 c008a8a:	d808      	bhi.n	c008a9e <boot_nv_security_counter_get+0x22>
    nv_counter = get_nv_counter_from_image_id(image_id);
    if (nv_counter == TFM_BOOT_NV_COUNTER_MAX) {
        return -1;
    }

    err = tfm_plat_read_nv_counter(nv_counter,
 c008a8c:	2104      	movs	r1, #4
 c008a8e:	b2c0      	uxtb	r0, r0
 c008a90:	f7f9 f92a 	bl	c001ce8 <tfm_plat_read_nv_counter>
                                   sizeof(*security_cnt),
                                   (uint8_t *)security_cnt);
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c008a94:	3800      	subs	r0, #0
 c008a96:	bf18      	it	ne
 c008a98:	2001      	movne	r0, #1
 c008a9a:	4240      	negs	r0, r0
        return -1;
    }

    return 0;
}
 c008a9c:	bd08      	pop	{r3, pc}
        return -1;
 c008a9e:	f04f 30ff 	mov.w	r0, #4294967295
 c008aa2:	e7fb      	b.n	c008a9c <boot_nv_security_counter_get+0x20>

0c008aa4 <boot_nv_security_counter_update>:

int32_t boot_nv_security_counter_update(uint32_t image_id,
                                        uint32_t img_security_cnt)
{
 c008aa4:	b508      	push	{r3, lr}
    if ((UINT32_MAX - TFM_BOOT_NV_COUNTER_0) < image_id) {
 c008aa6:	1d03      	adds	r3, r0, #4
 c008aa8:	d80a      	bhi.n	c008ac0 <boot_nv_security_counter_update+0x1c>
    nv_counter = TFM_BOOT_NV_COUNTER_0 + image_id;
 c008aaa:	3003      	adds	r0, #3
    if (nv_counter >= TFM_BOOT_NV_COUNTER_MAX) {
 c008aac:	2804      	cmp	r0, #4
 c008aae:	d807      	bhi.n	c008ac0 <boot_nv_security_counter_update+0x1c>
    nv_counter = get_nv_counter_from_image_id(image_id);
    if (nv_counter == TFM_BOOT_NV_COUNTER_MAX) {
        return -1;
    }

    err = tfm_plat_set_nv_counter(nv_counter, img_security_cnt);
 c008ab0:	b2c0      	uxtb	r0, r0
 c008ab2:	f7f9 fa6b 	bl	c001f8c <tfm_plat_set_nv_counter>
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c008ab6:	3800      	subs	r0, #0
 c008ab8:	bf18      	it	ne
 c008aba:	2001      	movne	r0, #1
 c008abc:	4240      	negs	r0, r0
        return -1;
    }

    return 0;
}
 c008abe:	bd08      	pop	{r3, pc}
        return -1;
 c008ac0:	f04f 30ff 	mov.w	r0, #4294967295
 c008ac4:	e7fb      	b.n	c008abe <boot_nv_security_counter_update+0x1a>
	...

0c008ac8 <_write>:
    return ch;
}
#elif defined(__GNUC__)
/* Redirects printf to TFM_DRIVER_STDIO in case of GNUARM */
int _write(int fd, char *str, int len)
{
 c008ac8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c008aca:	460e      	mov	r6, r1
 c008acc:	4614      	mov	r4, r2
    int i;

    for (i = 0; i < len; i++) {
 c008ace:	2500      	movs	r5, #0
    ret = TFM_DRIVER_STDIO.Send(&c, 1);
 c008ad0:	4f07      	ldr	r7, [pc, #28]	; (c008af0 <_write+0x28>)
    for (i = 0; i < len; i++) {
 c008ad2:	42a5      	cmp	r5, r4
 c008ad4:	db02      	blt.n	c008adc <_write+0x14>
        uart_putc(str[i]);
    }

    /* Return the number of characters written */
    return len;
}
 c008ad6:	4620      	mov	r0, r4
 c008ad8:	b003      	add	sp, #12
 c008ada:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uart_putc(str[i]);
 c008adc:	5d73      	ldrb	r3, [r6, r5]
    ret = TFM_DRIVER_STDIO.Send(&c, 1);
 c008ade:	2101      	movs	r1, #1
 c008ae0:	f88d 3007 	strb.w	r3, [sp, #7]
 c008ae4:	f10d 0007 	add.w	r0, sp, #7
 c008ae8:	697b      	ldr	r3, [r7, #20]
 c008aea:	4798      	blx	r3
    for (i = 0; i < len; i++) {
 c008aec:	3501      	adds	r5, #1
 c008aee:	e7f0      	b.n	c008ad2 <_write+0xa>
 c008af0:	0c00a210 	.word	0x0c00a210

0c008af4 <stdio_init>:
    return ch;
}
#endif

void stdio_init(void)
{
 c008af4:	b510      	push	{r4, lr}
#ifdef NDEBUG
    __attribute__((unused))
#endif
    int32_t ret = ARM_DRIVER_OK;
    ret = TFM_DRIVER_STDIO.Initialize(NULL);
 c008af6:	4c05      	ldr	r4, [pc, #20]	; (c008b0c <stdio_init+0x18>)
 c008af8:	2000      	movs	r0, #0
 c008afa:	68a3      	ldr	r3, [r4, #8]
 c008afc:	4798      	blx	r3
    ASSERT_HIGH(ret);

    ret = TFM_DRIVER_STDIO.Control(ARM_USART_MODE_ASYNCHRONOUS, 115200);
 c008afe:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 c008b00:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
    ASSERT_HIGH(ret);
}
 c008b04:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ret = TFM_DRIVER_STDIO.Control(ARM_USART_MODE_ASYNCHRONOUS, 115200);
 c008b08:	2001      	movs	r0, #1
 c008b0a:	4718      	bx	r3
 c008b0c:	0c00a210 	.word	0x0c00a210

0c008b10 <stdio_uninit>:
{
#ifdef NDEBUG
    __attribute__((unused))
#endif
    int32_t ret = ARM_DRIVER_OK;
    ret = TFM_DRIVER_STDIO.Uninitialize();
 c008b10:	4b01      	ldr	r3, [pc, #4]	; (c008b18 <stdio_uninit+0x8>)
 c008b12:	68db      	ldr	r3, [r3, #12]
 c008b14:	4718      	bx	r3
 c008b16:	bf00      	nop
 c008b18:	0c00a210 	.word	0x0c00a210

0c008b1c <exit>:
 c008b1c:	b508      	push	{r3, lr}
 c008b1e:	4b07      	ldr	r3, [pc, #28]	; (c008b3c <exit+0x20>)
 c008b20:	4604      	mov	r4, r0
 c008b22:	b113      	cbz	r3, c008b2a <exit+0xe>
 c008b24:	2100      	movs	r1, #0
 c008b26:	e000      	b.n	c008b2a <exit+0xe>
 c008b28:	bf00      	nop
 c008b2a:	4b05      	ldr	r3, [pc, #20]	; (c008b40 <exit+0x24>)
 c008b2c:	6818      	ldr	r0, [r3, #0]
 c008b2e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 c008b30:	b103      	cbz	r3, c008b34 <exit+0x18>
 c008b32:	4798      	blx	r3
 c008b34:	4620      	mov	r0, r4
 c008b36:	f001 fa0b 	bl	c009f50 <_exit>
 c008b3a:	bf00      	nop
 c008b3c:	00000000 	.word	0x00000000
 c008b40:	0c00ad9c 	.word	0x0c00ad9c

0c008b44 <__libc_init_array>:
 c008b44:	b570      	push	{r4, r5, r6, lr}
 c008b46:	4d0d      	ldr	r5, [pc, #52]	; (c008b7c <__libc_init_array+0x38>)
 c008b48:	2600      	movs	r6, #0
 c008b4a:	4c0d      	ldr	r4, [pc, #52]	; (c008b80 <__libc_init_array+0x3c>)
 c008b4c:	1b64      	subs	r4, r4, r5
 c008b4e:	10a4      	asrs	r4, r4, #2
 c008b50:	42a6      	cmp	r6, r4
 c008b52:	d109      	bne.n	c008b68 <__libc_init_array+0x24>
 c008b54:	4d0b      	ldr	r5, [pc, #44]	; (c008b84 <__libc_init_array+0x40>)
 c008b56:	2600      	movs	r6, #0
 c008b58:	4c0b      	ldr	r4, [pc, #44]	; (c008b88 <__libc_init_array+0x44>)
 c008b5a:	f001 f9fb 	bl	c009f54 <_init>
 c008b5e:	1b64      	subs	r4, r4, r5
 c008b60:	10a4      	asrs	r4, r4, #2
 c008b62:	42a6      	cmp	r6, r4
 c008b64:	d105      	bne.n	c008b72 <__libc_init_array+0x2e>
 c008b66:	bd70      	pop	{r4, r5, r6, pc}
 c008b68:	f855 3b04 	ldr.w	r3, [r5], #4
 c008b6c:	3601      	adds	r6, #1
 c008b6e:	4798      	blx	r3
 c008b70:	e7ee      	b.n	c008b50 <__libc_init_array+0xc>
 c008b72:	f855 3b04 	ldr.w	r3, [r5], #4
 c008b76:	3601      	adds	r6, #1
 c008b78:	4798      	blx	r3
 c008b7a:	e7f2      	b.n	c008b62 <__libc_init_array+0x1e>
 c008b7c:	300300f8 	.word	0x300300f8
 c008b80:	300300f8 	.word	0x300300f8
 c008b84:	300300f8 	.word	0x300300f8
 c008b88:	300300fc 	.word	0x300300fc

0c008b8c <memcpy>:
 c008b8c:	440a      	add	r2, r1
 c008b8e:	1e43      	subs	r3, r0, #1
 c008b90:	4291      	cmp	r1, r2
 c008b92:	d100      	bne.n	c008b96 <memcpy+0xa>
 c008b94:	4770      	bx	lr
 c008b96:	b510      	push	{r4, lr}
 c008b98:	f811 4b01 	ldrb.w	r4, [r1], #1
 c008b9c:	4291      	cmp	r1, r2
 c008b9e:	f803 4f01 	strb.w	r4, [r3, #1]!
 c008ba2:	d1f9      	bne.n	c008b98 <memcpy+0xc>
 c008ba4:	bd10      	pop	{r4, pc}

0c008ba6 <memset>:
 c008ba6:	4402      	add	r2, r0
 c008ba8:	4603      	mov	r3, r0
 c008baa:	4293      	cmp	r3, r2
 c008bac:	d100      	bne.n	c008bb0 <memset+0xa>
 c008bae:	4770      	bx	lr
 c008bb0:	f803 1b01 	strb.w	r1, [r3], #1
 c008bb4:	e7f9      	b.n	c008baa <memset+0x4>
	...

0c008bb8 <_free_r>:
 c008bb8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c008bba:	2900      	cmp	r1, #0
 c008bbc:	d047      	beq.n	c008c4e <_free_r+0x96>
 c008bbe:	f851 3c04 	ldr.w	r3, [r1, #-4]
 c008bc2:	1f0c      	subs	r4, r1, #4
 c008bc4:	9001      	str	r0, [sp, #4]
 c008bc6:	2b00      	cmp	r3, #0
 c008bc8:	bfb8      	it	lt
 c008bca:	18e4      	addlt	r4, r4, r3
 c008bcc:	f000 fc18 	bl	c009400 <__malloc_lock>
 c008bd0:	4a20      	ldr	r2, [pc, #128]	; (c008c54 <_free_r+0x9c>)
 c008bd2:	9801      	ldr	r0, [sp, #4]
 c008bd4:	6813      	ldr	r3, [r2, #0]
 c008bd6:	4615      	mov	r5, r2
 c008bd8:	b933      	cbnz	r3, c008be8 <_free_r+0x30>
 c008bda:	6063      	str	r3, [r4, #4]
 c008bdc:	6014      	str	r4, [r2, #0]
 c008bde:	b003      	add	sp, #12
 c008be0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 c008be4:	f000 bc12 	b.w	c00940c <__malloc_unlock>
 c008be8:	42a3      	cmp	r3, r4
 c008bea:	d90b      	bls.n	c008c04 <_free_r+0x4c>
 c008bec:	6821      	ldr	r1, [r4, #0]
 c008bee:	1862      	adds	r2, r4, r1
 c008bf0:	4293      	cmp	r3, r2
 c008bf2:	bf02      	ittt	eq
 c008bf4:	681a      	ldreq	r2, [r3, #0]
 c008bf6:	685b      	ldreq	r3, [r3, #4]
 c008bf8:	1852      	addeq	r2, r2, r1
 c008bfa:	6063      	str	r3, [r4, #4]
 c008bfc:	bf08      	it	eq
 c008bfe:	6022      	streq	r2, [r4, #0]
 c008c00:	602c      	str	r4, [r5, #0]
 c008c02:	e7ec      	b.n	c008bde <_free_r+0x26>
 c008c04:	461a      	mov	r2, r3
 c008c06:	685b      	ldr	r3, [r3, #4]
 c008c08:	b10b      	cbz	r3, c008c0e <_free_r+0x56>
 c008c0a:	42a3      	cmp	r3, r4
 c008c0c:	d9fa      	bls.n	c008c04 <_free_r+0x4c>
 c008c0e:	6811      	ldr	r1, [r2, #0]
 c008c10:	1855      	adds	r5, r2, r1
 c008c12:	42a5      	cmp	r5, r4
 c008c14:	d10b      	bne.n	c008c2e <_free_r+0x76>
 c008c16:	6824      	ldr	r4, [r4, #0]
 c008c18:	4421      	add	r1, r4
 c008c1a:	1854      	adds	r4, r2, r1
 c008c1c:	6011      	str	r1, [r2, #0]
 c008c1e:	42a3      	cmp	r3, r4
 c008c20:	d1dd      	bne.n	c008bde <_free_r+0x26>
 c008c22:	681c      	ldr	r4, [r3, #0]
 c008c24:	685b      	ldr	r3, [r3, #4]
 c008c26:	4421      	add	r1, r4
 c008c28:	6053      	str	r3, [r2, #4]
 c008c2a:	6011      	str	r1, [r2, #0]
 c008c2c:	e7d7      	b.n	c008bde <_free_r+0x26>
 c008c2e:	d902      	bls.n	c008c36 <_free_r+0x7e>
 c008c30:	230c      	movs	r3, #12
 c008c32:	6003      	str	r3, [r0, #0]
 c008c34:	e7d3      	b.n	c008bde <_free_r+0x26>
 c008c36:	6825      	ldr	r5, [r4, #0]
 c008c38:	1961      	adds	r1, r4, r5
 c008c3a:	428b      	cmp	r3, r1
 c008c3c:	bf02      	ittt	eq
 c008c3e:	6819      	ldreq	r1, [r3, #0]
 c008c40:	685b      	ldreq	r3, [r3, #4]
 c008c42:	1949      	addeq	r1, r1, r5
 c008c44:	6063      	str	r3, [r4, #4]
 c008c46:	bf08      	it	eq
 c008c48:	6021      	streq	r1, [r4, #0]
 c008c4a:	6054      	str	r4, [r2, #4]
 c008c4c:	e7c7      	b.n	c008bde <_free_r+0x26>
 c008c4e:	b003      	add	sp, #12
 c008c50:	bd30      	pop	{r4, r5, pc}
 c008c52:	bf00      	nop
 c008c54:	3003beb8 	.word	0x3003beb8

0c008c58 <_malloc_r>:
 c008c58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c008c5a:	1ccd      	adds	r5, r1, #3
 c008c5c:	4606      	mov	r6, r0
 c008c5e:	f025 0503 	bic.w	r5, r5, #3
 c008c62:	3508      	adds	r5, #8
 c008c64:	2d0c      	cmp	r5, #12
 c008c66:	bf38      	it	cc
 c008c68:	250c      	movcc	r5, #12
 c008c6a:	2d00      	cmp	r5, #0
 c008c6c:	db01      	blt.n	c008c72 <_malloc_r+0x1a>
 c008c6e:	42a9      	cmp	r1, r5
 c008c70:	d903      	bls.n	c008c7a <_malloc_r+0x22>
 c008c72:	230c      	movs	r3, #12
 c008c74:	6033      	str	r3, [r6, #0]
 c008c76:	2000      	movs	r0, #0
 c008c78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c008c7a:	f000 fbc1 	bl	c009400 <__malloc_lock>
 c008c7e:	4921      	ldr	r1, [pc, #132]	; (c008d04 <_malloc_r+0xac>)
 c008c80:	680a      	ldr	r2, [r1, #0]
 c008c82:	4614      	mov	r4, r2
 c008c84:	b99c      	cbnz	r4, c008cae <_malloc_r+0x56>
 c008c86:	4f20      	ldr	r7, [pc, #128]	; (c008d08 <_malloc_r+0xb0>)
 c008c88:	683b      	ldr	r3, [r7, #0]
 c008c8a:	b923      	cbnz	r3, c008c96 <_malloc_r+0x3e>
 c008c8c:	4621      	mov	r1, r4
 c008c8e:	4630      	mov	r0, r6
 c008c90:	f000 f8ca 	bl	c008e28 <_sbrk_r>
 c008c94:	6038      	str	r0, [r7, #0]
 c008c96:	4629      	mov	r1, r5
 c008c98:	4630      	mov	r0, r6
 c008c9a:	f000 f8c5 	bl	c008e28 <_sbrk_r>
 c008c9e:	1c43      	adds	r3, r0, #1
 c008ca0:	d123      	bne.n	c008cea <_malloc_r+0x92>
 c008ca2:	230c      	movs	r3, #12
 c008ca4:	4630      	mov	r0, r6
 c008ca6:	6033      	str	r3, [r6, #0]
 c008ca8:	f000 fbb0 	bl	c00940c <__malloc_unlock>
 c008cac:	e7e3      	b.n	c008c76 <_malloc_r+0x1e>
 c008cae:	6823      	ldr	r3, [r4, #0]
 c008cb0:	1b5b      	subs	r3, r3, r5
 c008cb2:	d417      	bmi.n	c008ce4 <_malloc_r+0x8c>
 c008cb4:	2b0b      	cmp	r3, #11
 c008cb6:	d903      	bls.n	c008cc0 <_malloc_r+0x68>
 c008cb8:	6023      	str	r3, [r4, #0]
 c008cba:	441c      	add	r4, r3
 c008cbc:	6025      	str	r5, [r4, #0]
 c008cbe:	e004      	b.n	c008cca <_malloc_r+0x72>
 c008cc0:	6863      	ldr	r3, [r4, #4]
 c008cc2:	42a2      	cmp	r2, r4
 c008cc4:	bf0c      	ite	eq
 c008cc6:	600b      	streq	r3, [r1, #0]
 c008cc8:	6053      	strne	r3, [r2, #4]
 c008cca:	4630      	mov	r0, r6
 c008ccc:	f000 fb9e 	bl	c00940c <__malloc_unlock>
 c008cd0:	f104 000b 	add.w	r0, r4, #11
 c008cd4:	1d23      	adds	r3, r4, #4
 c008cd6:	f020 0007 	bic.w	r0, r0, #7
 c008cda:	1ac2      	subs	r2, r0, r3
 c008cdc:	d0cc      	beq.n	c008c78 <_malloc_r+0x20>
 c008cde:	1a1b      	subs	r3, r3, r0
 c008ce0:	50a3      	str	r3, [r4, r2]
 c008ce2:	e7c9      	b.n	c008c78 <_malloc_r+0x20>
 c008ce4:	4622      	mov	r2, r4
 c008ce6:	6864      	ldr	r4, [r4, #4]
 c008ce8:	e7cc      	b.n	c008c84 <_malloc_r+0x2c>
 c008cea:	1cc4      	adds	r4, r0, #3
 c008cec:	f024 0403 	bic.w	r4, r4, #3
 c008cf0:	42a0      	cmp	r0, r4
 c008cf2:	d0e3      	beq.n	c008cbc <_malloc_r+0x64>
 c008cf4:	1a21      	subs	r1, r4, r0
 c008cf6:	4630      	mov	r0, r6
 c008cf8:	f000 f896 	bl	c008e28 <_sbrk_r>
 c008cfc:	3001      	adds	r0, #1
 c008cfe:	d1dd      	bne.n	c008cbc <_malloc_r+0x64>
 c008d00:	e7cf      	b.n	c008ca2 <_malloc_r+0x4a>
 c008d02:	bf00      	nop
 c008d04:	3003beb8 	.word	0x3003beb8
 c008d08:	3003bebc 	.word	0x3003bebc

0c008d0c <iprintf>:
 c008d0c:	b40f      	push	{r0, r1, r2, r3}
 c008d0e:	4b0a      	ldr	r3, [pc, #40]	; (c008d38 <iprintf+0x2c>)
 c008d10:	b513      	push	{r0, r1, r4, lr}
 c008d12:	681c      	ldr	r4, [r3, #0]
 c008d14:	b124      	cbz	r4, c008d20 <iprintf+0x14>
 c008d16:	69a3      	ldr	r3, [r4, #24]
 c008d18:	b913      	cbnz	r3, c008d20 <iprintf+0x14>
 c008d1a:	4620      	mov	r0, r4
 c008d1c:	f000 fa6c 	bl	c0091f8 <__sinit>
 c008d20:	ab05      	add	r3, sp, #20
 c008d22:	9a04      	ldr	r2, [sp, #16]
 c008d24:	68a1      	ldr	r1, [r4, #8]
 c008d26:	4620      	mov	r0, r4
 c008d28:	9301      	str	r3, [sp, #4]
 c008d2a:	f000 fb9f 	bl	c00946c <_vfiprintf_r>
 c008d2e:	b002      	add	sp, #8
 c008d30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c008d34:	b004      	add	sp, #16
 c008d36:	4770      	bx	lr
 c008d38:	30030094 	.word	0x30030094

0c008d3c <_puts_r>:
 c008d3c:	b570      	push	{r4, r5, r6, lr}
 c008d3e:	460e      	mov	r6, r1
 c008d40:	4605      	mov	r5, r0
 c008d42:	b118      	cbz	r0, c008d4c <_puts_r+0x10>
 c008d44:	6983      	ldr	r3, [r0, #24]
 c008d46:	b90b      	cbnz	r3, c008d4c <_puts_r+0x10>
 c008d48:	f000 fa56 	bl	c0091f8 <__sinit>
 c008d4c:	69ab      	ldr	r3, [r5, #24]
 c008d4e:	68ac      	ldr	r4, [r5, #8]
 c008d50:	b913      	cbnz	r3, c008d58 <_puts_r+0x1c>
 c008d52:	4628      	mov	r0, r5
 c008d54:	f000 fa50 	bl	c0091f8 <__sinit>
 c008d58:	4b2c      	ldr	r3, [pc, #176]	; (c008e0c <_puts_r+0xd0>)
 c008d5a:	429c      	cmp	r4, r3
 c008d5c:	d120      	bne.n	c008da0 <_puts_r+0x64>
 c008d5e:	686c      	ldr	r4, [r5, #4]
 c008d60:	6e63      	ldr	r3, [r4, #100]	; 0x64
 c008d62:	07db      	lsls	r3, r3, #31
 c008d64:	d405      	bmi.n	c008d72 <_puts_r+0x36>
 c008d66:	89a3      	ldrh	r3, [r4, #12]
 c008d68:	0598      	lsls	r0, r3, #22
 c008d6a:	d402      	bmi.n	c008d72 <_puts_r+0x36>
 c008d6c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 c008d6e:	f000 fae1 	bl	c009334 <__retarget_lock_acquire_recursive>
 c008d72:	89a3      	ldrh	r3, [r4, #12]
 c008d74:	0719      	lsls	r1, r3, #28
 c008d76:	d51d      	bpl.n	c008db4 <_puts_r+0x78>
 c008d78:	6923      	ldr	r3, [r4, #16]
 c008d7a:	b1db      	cbz	r3, c008db4 <_puts_r+0x78>
 c008d7c:	3e01      	subs	r6, #1
 c008d7e:	68a3      	ldr	r3, [r4, #8]
 c008d80:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 c008d84:	3b01      	subs	r3, #1
 c008d86:	60a3      	str	r3, [r4, #8]
 c008d88:	bb39      	cbnz	r1, c008dda <_puts_r+0x9e>
 c008d8a:	2b00      	cmp	r3, #0
 c008d8c:	da38      	bge.n	c008e00 <_puts_r+0xc4>
 c008d8e:	4622      	mov	r2, r4
 c008d90:	210a      	movs	r1, #10
 c008d92:	4628      	mov	r0, r5
 c008d94:	f000 f858 	bl	c008e48 <__swbuf_r>
 c008d98:	3001      	adds	r0, #1
 c008d9a:	d011      	beq.n	c008dc0 <_puts_r+0x84>
 c008d9c:	250a      	movs	r5, #10
 c008d9e:	e011      	b.n	c008dc4 <_puts_r+0x88>
 c008da0:	4b1b      	ldr	r3, [pc, #108]	; (c008e10 <_puts_r+0xd4>)
 c008da2:	429c      	cmp	r4, r3
 c008da4:	d101      	bne.n	c008daa <_puts_r+0x6e>
 c008da6:	68ac      	ldr	r4, [r5, #8]
 c008da8:	e7da      	b.n	c008d60 <_puts_r+0x24>
 c008daa:	4b1a      	ldr	r3, [pc, #104]	; (c008e14 <_puts_r+0xd8>)
 c008dac:	429c      	cmp	r4, r3
 c008dae:	bf08      	it	eq
 c008db0:	68ec      	ldreq	r4, [r5, #12]
 c008db2:	e7d5      	b.n	c008d60 <_puts_r+0x24>
 c008db4:	4621      	mov	r1, r4
 c008db6:	4628      	mov	r0, r5
 c008db8:	f000 f898 	bl	c008eec <__swsetup_r>
 c008dbc:	2800      	cmp	r0, #0
 c008dbe:	d0dd      	beq.n	c008d7c <_puts_r+0x40>
 c008dc0:	f04f 35ff 	mov.w	r5, #4294967295
 c008dc4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 c008dc6:	07da      	lsls	r2, r3, #31
 c008dc8:	d405      	bmi.n	c008dd6 <_puts_r+0x9a>
 c008dca:	89a3      	ldrh	r3, [r4, #12]
 c008dcc:	059b      	lsls	r3, r3, #22
 c008dce:	d402      	bmi.n	c008dd6 <_puts_r+0x9a>
 c008dd0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 c008dd2:	f000 fab0 	bl	c009336 <__retarget_lock_release_recursive>
 c008dd6:	4628      	mov	r0, r5
 c008dd8:	bd70      	pop	{r4, r5, r6, pc}
 c008dda:	2b00      	cmp	r3, #0
 c008ddc:	da04      	bge.n	c008de8 <_puts_r+0xac>
 c008dde:	69a2      	ldr	r2, [r4, #24]
 c008de0:	429a      	cmp	r2, r3
 c008de2:	dc06      	bgt.n	c008df2 <_puts_r+0xb6>
 c008de4:	290a      	cmp	r1, #10
 c008de6:	d004      	beq.n	c008df2 <_puts_r+0xb6>
 c008de8:	6823      	ldr	r3, [r4, #0]
 c008dea:	1c5a      	adds	r2, r3, #1
 c008dec:	6022      	str	r2, [r4, #0]
 c008dee:	7019      	strb	r1, [r3, #0]
 c008df0:	e7c5      	b.n	c008d7e <_puts_r+0x42>
 c008df2:	4622      	mov	r2, r4
 c008df4:	4628      	mov	r0, r5
 c008df6:	f000 f827 	bl	c008e48 <__swbuf_r>
 c008dfa:	3001      	adds	r0, #1
 c008dfc:	d1bf      	bne.n	c008d7e <_puts_r+0x42>
 c008dfe:	e7df      	b.n	c008dc0 <_puts_r+0x84>
 c008e00:	6823      	ldr	r3, [r4, #0]
 c008e02:	250a      	movs	r5, #10
 c008e04:	1c5a      	adds	r2, r3, #1
 c008e06:	6022      	str	r2, [r4, #0]
 c008e08:	701d      	strb	r5, [r3, #0]
 c008e0a:	e7db      	b.n	c008dc4 <_puts_r+0x88>
 c008e0c:	0c00adc0 	.word	0x0c00adc0
 c008e10:	0c00ade0 	.word	0x0c00ade0
 c008e14:	0c00ada0 	.word	0x0c00ada0

0c008e18 <puts>:
 c008e18:	4b02      	ldr	r3, [pc, #8]	; (c008e24 <puts+0xc>)
 c008e1a:	4601      	mov	r1, r0
 c008e1c:	6818      	ldr	r0, [r3, #0]
 c008e1e:	f7ff bf8d 	b.w	c008d3c <_puts_r>
 c008e22:	bf00      	nop
 c008e24:	30030094 	.word	0x30030094

0c008e28 <_sbrk_r>:
 c008e28:	b538      	push	{r3, r4, r5, lr}
 c008e2a:	2300      	movs	r3, #0
 c008e2c:	4d05      	ldr	r5, [pc, #20]	; (c008e44 <_sbrk_r+0x1c>)
 c008e2e:	4604      	mov	r4, r0
 c008e30:	4608      	mov	r0, r1
 c008e32:	602b      	str	r3, [r5, #0]
 c008e34:	f001 f87e 	bl	c009f34 <_sbrk>
 c008e38:	1c43      	adds	r3, r0, #1
 c008e3a:	d102      	bne.n	c008e42 <_sbrk_r+0x1a>
 c008e3c:	682b      	ldr	r3, [r5, #0]
 c008e3e:	b103      	cbz	r3, c008e42 <_sbrk_r+0x1a>
 c008e40:	6023      	str	r3, [r4, #0]
 c008e42:	bd38      	pop	{r3, r4, r5, pc}
 c008e44:	3003bed0 	.word	0x3003bed0

0c008e48 <__swbuf_r>:
 c008e48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c008e4a:	460e      	mov	r6, r1
 c008e4c:	4614      	mov	r4, r2
 c008e4e:	4605      	mov	r5, r0
 c008e50:	b118      	cbz	r0, c008e5a <__swbuf_r+0x12>
 c008e52:	6983      	ldr	r3, [r0, #24]
 c008e54:	b90b      	cbnz	r3, c008e5a <__swbuf_r+0x12>
 c008e56:	f000 f9cf 	bl	c0091f8 <__sinit>
 c008e5a:	4b21      	ldr	r3, [pc, #132]	; (c008ee0 <__swbuf_r+0x98>)
 c008e5c:	429c      	cmp	r4, r3
 c008e5e:	d12b      	bne.n	c008eb8 <__swbuf_r+0x70>
 c008e60:	686c      	ldr	r4, [r5, #4]
 c008e62:	69a3      	ldr	r3, [r4, #24]
 c008e64:	60a3      	str	r3, [r4, #8]
 c008e66:	89a3      	ldrh	r3, [r4, #12]
 c008e68:	071a      	lsls	r2, r3, #28
 c008e6a:	d52f      	bpl.n	c008ecc <__swbuf_r+0x84>
 c008e6c:	6923      	ldr	r3, [r4, #16]
 c008e6e:	b36b      	cbz	r3, c008ecc <__swbuf_r+0x84>
 c008e70:	6923      	ldr	r3, [r4, #16]
 c008e72:	b2f6      	uxtb	r6, r6
 c008e74:	6820      	ldr	r0, [r4, #0]
 c008e76:	4637      	mov	r7, r6
 c008e78:	1ac0      	subs	r0, r0, r3
 c008e7a:	6963      	ldr	r3, [r4, #20]
 c008e7c:	4283      	cmp	r3, r0
 c008e7e:	dc04      	bgt.n	c008e8a <__swbuf_r+0x42>
 c008e80:	4621      	mov	r1, r4
 c008e82:	4628      	mov	r0, r5
 c008e84:	f000 f924 	bl	c0090d0 <_fflush_r>
 c008e88:	bb30      	cbnz	r0, c008ed8 <__swbuf_r+0x90>
 c008e8a:	68a3      	ldr	r3, [r4, #8]
 c008e8c:	3001      	adds	r0, #1
 c008e8e:	3b01      	subs	r3, #1
 c008e90:	60a3      	str	r3, [r4, #8]
 c008e92:	6823      	ldr	r3, [r4, #0]
 c008e94:	1c5a      	adds	r2, r3, #1
 c008e96:	6022      	str	r2, [r4, #0]
 c008e98:	701e      	strb	r6, [r3, #0]
 c008e9a:	6963      	ldr	r3, [r4, #20]
 c008e9c:	4283      	cmp	r3, r0
 c008e9e:	d004      	beq.n	c008eaa <__swbuf_r+0x62>
 c008ea0:	89a3      	ldrh	r3, [r4, #12]
 c008ea2:	07db      	lsls	r3, r3, #31
 c008ea4:	d506      	bpl.n	c008eb4 <__swbuf_r+0x6c>
 c008ea6:	2e0a      	cmp	r6, #10
 c008ea8:	d104      	bne.n	c008eb4 <__swbuf_r+0x6c>
 c008eaa:	4621      	mov	r1, r4
 c008eac:	4628      	mov	r0, r5
 c008eae:	f000 f90f 	bl	c0090d0 <_fflush_r>
 c008eb2:	b988      	cbnz	r0, c008ed8 <__swbuf_r+0x90>
 c008eb4:	4638      	mov	r0, r7
 c008eb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c008eb8:	4b0a      	ldr	r3, [pc, #40]	; (c008ee4 <__swbuf_r+0x9c>)
 c008eba:	429c      	cmp	r4, r3
 c008ebc:	d101      	bne.n	c008ec2 <__swbuf_r+0x7a>
 c008ebe:	68ac      	ldr	r4, [r5, #8]
 c008ec0:	e7cf      	b.n	c008e62 <__swbuf_r+0x1a>
 c008ec2:	4b09      	ldr	r3, [pc, #36]	; (c008ee8 <__swbuf_r+0xa0>)
 c008ec4:	429c      	cmp	r4, r3
 c008ec6:	bf08      	it	eq
 c008ec8:	68ec      	ldreq	r4, [r5, #12]
 c008eca:	e7ca      	b.n	c008e62 <__swbuf_r+0x1a>
 c008ecc:	4621      	mov	r1, r4
 c008ece:	4628      	mov	r0, r5
 c008ed0:	f000 f80c 	bl	c008eec <__swsetup_r>
 c008ed4:	2800      	cmp	r0, #0
 c008ed6:	d0cb      	beq.n	c008e70 <__swbuf_r+0x28>
 c008ed8:	f04f 37ff 	mov.w	r7, #4294967295
 c008edc:	e7ea      	b.n	c008eb4 <__swbuf_r+0x6c>
 c008ede:	bf00      	nop
 c008ee0:	0c00adc0 	.word	0x0c00adc0
 c008ee4:	0c00ade0 	.word	0x0c00ade0
 c008ee8:	0c00ada0 	.word	0x0c00ada0

0c008eec <__swsetup_r>:
 c008eec:	4b32      	ldr	r3, [pc, #200]	; (c008fb8 <__swsetup_r+0xcc>)
 c008eee:	b570      	push	{r4, r5, r6, lr}
 c008ef0:	681d      	ldr	r5, [r3, #0]
 c008ef2:	4606      	mov	r6, r0
 c008ef4:	460c      	mov	r4, r1
 c008ef6:	b125      	cbz	r5, c008f02 <__swsetup_r+0x16>
 c008ef8:	69ab      	ldr	r3, [r5, #24]
 c008efa:	b913      	cbnz	r3, c008f02 <__swsetup_r+0x16>
 c008efc:	4628      	mov	r0, r5
 c008efe:	f000 f97b 	bl	c0091f8 <__sinit>
 c008f02:	4b2e      	ldr	r3, [pc, #184]	; (c008fbc <__swsetup_r+0xd0>)
 c008f04:	429c      	cmp	r4, r3
 c008f06:	d10f      	bne.n	c008f28 <__swsetup_r+0x3c>
 c008f08:	686c      	ldr	r4, [r5, #4]
 c008f0a:	89a3      	ldrh	r3, [r4, #12]
 c008f0c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 c008f10:	0719      	lsls	r1, r3, #28
 c008f12:	d42c      	bmi.n	c008f6e <__swsetup_r+0x82>
 c008f14:	06dd      	lsls	r5, r3, #27
 c008f16:	d411      	bmi.n	c008f3c <__swsetup_r+0x50>
 c008f18:	2309      	movs	r3, #9
 c008f1a:	6033      	str	r3, [r6, #0]
 c008f1c:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 c008f20:	f04f 30ff 	mov.w	r0, #4294967295
 c008f24:	81a3      	strh	r3, [r4, #12]
 c008f26:	e03e      	b.n	c008fa6 <__swsetup_r+0xba>
 c008f28:	4b25      	ldr	r3, [pc, #148]	; (c008fc0 <__swsetup_r+0xd4>)
 c008f2a:	429c      	cmp	r4, r3
 c008f2c:	d101      	bne.n	c008f32 <__swsetup_r+0x46>
 c008f2e:	68ac      	ldr	r4, [r5, #8]
 c008f30:	e7eb      	b.n	c008f0a <__swsetup_r+0x1e>
 c008f32:	4b24      	ldr	r3, [pc, #144]	; (c008fc4 <__swsetup_r+0xd8>)
 c008f34:	429c      	cmp	r4, r3
 c008f36:	bf08      	it	eq
 c008f38:	68ec      	ldreq	r4, [r5, #12]
 c008f3a:	e7e6      	b.n	c008f0a <__swsetup_r+0x1e>
 c008f3c:	0758      	lsls	r0, r3, #29
 c008f3e:	d512      	bpl.n	c008f66 <__swsetup_r+0x7a>
 c008f40:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c008f42:	b141      	cbz	r1, c008f56 <__swsetup_r+0x6a>
 c008f44:	f104 0344 	add.w	r3, r4, #68	; 0x44
 c008f48:	4299      	cmp	r1, r3
 c008f4a:	d002      	beq.n	c008f52 <__swsetup_r+0x66>
 c008f4c:	4630      	mov	r0, r6
 c008f4e:	f7ff fe33 	bl	c008bb8 <_free_r>
 c008f52:	2300      	movs	r3, #0
 c008f54:	6363      	str	r3, [r4, #52]	; 0x34
 c008f56:	89a3      	ldrh	r3, [r4, #12]
 c008f58:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 c008f5c:	81a3      	strh	r3, [r4, #12]
 c008f5e:	2300      	movs	r3, #0
 c008f60:	6063      	str	r3, [r4, #4]
 c008f62:	6923      	ldr	r3, [r4, #16]
 c008f64:	6023      	str	r3, [r4, #0]
 c008f66:	89a3      	ldrh	r3, [r4, #12]
 c008f68:	f043 0308 	orr.w	r3, r3, #8
 c008f6c:	81a3      	strh	r3, [r4, #12]
 c008f6e:	6923      	ldr	r3, [r4, #16]
 c008f70:	b94b      	cbnz	r3, c008f86 <__swsetup_r+0x9a>
 c008f72:	89a3      	ldrh	r3, [r4, #12]
 c008f74:	f403 7320 	and.w	r3, r3, #640	; 0x280
 c008f78:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 c008f7c:	d003      	beq.n	c008f86 <__swsetup_r+0x9a>
 c008f7e:	4621      	mov	r1, r4
 c008f80:	4630      	mov	r0, r6
 c008f82:	f000 f9fd 	bl	c009380 <__smakebuf_r>
 c008f86:	89a0      	ldrh	r0, [r4, #12]
 c008f88:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 c008f8c:	f010 0301 	ands.w	r3, r0, #1
 c008f90:	d00a      	beq.n	c008fa8 <__swsetup_r+0xbc>
 c008f92:	2300      	movs	r3, #0
 c008f94:	60a3      	str	r3, [r4, #8]
 c008f96:	6963      	ldr	r3, [r4, #20]
 c008f98:	425b      	negs	r3, r3
 c008f9a:	61a3      	str	r3, [r4, #24]
 c008f9c:	6923      	ldr	r3, [r4, #16]
 c008f9e:	b943      	cbnz	r3, c008fb2 <__swsetup_r+0xc6>
 c008fa0:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 c008fa4:	d1ba      	bne.n	c008f1c <__swsetup_r+0x30>
 c008fa6:	bd70      	pop	{r4, r5, r6, pc}
 c008fa8:	0781      	lsls	r1, r0, #30
 c008faa:	bf58      	it	pl
 c008fac:	6963      	ldrpl	r3, [r4, #20]
 c008fae:	60a3      	str	r3, [r4, #8]
 c008fb0:	e7f4      	b.n	c008f9c <__swsetup_r+0xb0>
 c008fb2:	2000      	movs	r0, #0
 c008fb4:	e7f7      	b.n	c008fa6 <__swsetup_r+0xba>
 c008fb6:	bf00      	nop
 c008fb8:	30030094 	.word	0x30030094
 c008fbc:	0c00adc0 	.word	0x0c00adc0
 c008fc0:	0c00ade0 	.word	0x0c00ade0
 c008fc4:	0c00ada0 	.word	0x0c00ada0

0c008fc8 <__sflush_r>:
 c008fc8:	898a      	ldrh	r2, [r1, #12]
 c008fca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c008fce:	4605      	mov	r5, r0
 c008fd0:	0710      	lsls	r0, r2, #28
 c008fd2:	460c      	mov	r4, r1
 c008fd4:	d458      	bmi.n	c009088 <__sflush_r+0xc0>
 c008fd6:	684b      	ldr	r3, [r1, #4]
 c008fd8:	2b00      	cmp	r3, #0
 c008fda:	dc05      	bgt.n	c008fe8 <__sflush_r+0x20>
 c008fdc:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 c008fde:	2b00      	cmp	r3, #0
 c008fe0:	dc02      	bgt.n	c008fe8 <__sflush_r+0x20>
 c008fe2:	2000      	movs	r0, #0
 c008fe4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c008fe8:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 c008fea:	2e00      	cmp	r6, #0
 c008fec:	d0f9      	beq.n	c008fe2 <__sflush_r+0x1a>
 c008fee:	2300      	movs	r3, #0
 c008ff0:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 c008ff4:	682f      	ldr	r7, [r5, #0]
 c008ff6:	602b      	str	r3, [r5, #0]
 c008ff8:	d032      	beq.n	c009060 <__sflush_r+0x98>
 c008ffa:	6d60      	ldr	r0, [r4, #84]	; 0x54
 c008ffc:	89a3      	ldrh	r3, [r4, #12]
 c008ffe:	075a      	lsls	r2, r3, #29
 c009000:	d505      	bpl.n	c00900e <__sflush_r+0x46>
 c009002:	6863      	ldr	r3, [r4, #4]
 c009004:	1ac0      	subs	r0, r0, r3
 c009006:	6b63      	ldr	r3, [r4, #52]	; 0x34
 c009008:	b10b      	cbz	r3, c00900e <__sflush_r+0x46>
 c00900a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 c00900c:	1ac0      	subs	r0, r0, r3
 c00900e:	2300      	movs	r3, #0
 c009010:	4602      	mov	r2, r0
 c009012:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 c009014:	4628      	mov	r0, r5
 c009016:	6a21      	ldr	r1, [r4, #32]
 c009018:	47b0      	blx	r6
 c00901a:	1c43      	adds	r3, r0, #1
 c00901c:	89a3      	ldrh	r3, [r4, #12]
 c00901e:	d106      	bne.n	c00902e <__sflush_r+0x66>
 c009020:	6829      	ldr	r1, [r5, #0]
 c009022:	291d      	cmp	r1, #29
 c009024:	d82c      	bhi.n	c009080 <__sflush_r+0xb8>
 c009026:	4a29      	ldr	r2, [pc, #164]	; (c0090cc <__sflush_r+0x104>)
 c009028:	40ca      	lsrs	r2, r1
 c00902a:	07d6      	lsls	r6, r2, #31
 c00902c:	d528      	bpl.n	c009080 <__sflush_r+0xb8>
 c00902e:	2200      	movs	r2, #0
 c009030:	04d9      	lsls	r1, r3, #19
 c009032:	6062      	str	r2, [r4, #4]
 c009034:	6922      	ldr	r2, [r4, #16]
 c009036:	6022      	str	r2, [r4, #0]
 c009038:	d504      	bpl.n	c009044 <__sflush_r+0x7c>
 c00903a:	1c42      	adds	r2, r0, #1
 c00903c:	d101      	bne.n	c009042 <__sflush_r+0x7a>
 c00903e:	682b      	ldr	r3, [r5, #0]
 c009040:	b903      	cbnz	r3, c009044 <__sflush_r+0x7c>
 c009042:	6560      	str	r0, [r4, #84]	; 0x54
 c009044:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c009046:	602f      	str	r7, [r5, #0]
 c009048:	2900      	cmp	r1, #0
 c00904a:	d0ca      	beq.n	c008fe2 <__sflush_r+0x1a>
 c00904c:	f104 0344 	add.w	r3, r4, #68	; 0x44
 c009050:	4299      	cmp	r1, r3
 c009052:	d002      	beq.n	c00905a <__sflush_r+0x92>
 c009054:	4628      	mov	r0, r5
 c009056:	f7ff fdaf 	bl	c008bb8 <_free_r>
 c00905a:	2000      	movs	r0, #0
 c00905c:	6360      	str	r0, [r4, #52]	; 0x34
 c00905e:	e7c1      	b.n	c008fe4 <__sflush_r+0x1c>
 c009060:	6a21      	ldr	r1, [r4, #32]
 c009062:	2301      	movs	r3, #1
 c009064:	4628      	mov	r0, r5
 c009066:	47b0      	blx	r6
 c009068:	1c41      	adds	r1, r0, #1
 c00906a:	d1c7      	bne.n	c008ffc <__sflush_r+0x34>
 c00906c:	682b      	ldr	r3, [r5, #0]
 c00906e:	2b00      	cmp	r3, #0
 c009070:	d0c4      	beq.n	c008ffc <__sflush_r+0x34>
 c009072:	2b1d      	cmp	r3, #29
 c009074:	d001      	beq.n	c00907a <__sflush_r+0xb2>
 c009076:	2b16      	cmp	r3, #22
 c009078:	d101      	bne.n	c00907e <__sflush_r+0xb6>
 c00907a:	602f      	str	r7, [r5, #0]
 c00907c:	e7b1      	b.n	c008fe2 <__sflush_r+0x1a>
 c00907e:	89a3      	ldrh	r3, [r4, #12]
 c009080:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c009084:	81a3      	strh	r3, [r4, #12]
 c009086:	e7ad      	b.n	c008fe4 <__sflush_r+0x1c>
 c009088:	690f      	ldr	r7, [r1, #16]
 c00908a:	2f00      	cmp	r7, #0
 c00908c:	d0a9      	beq.n	c008fe2 <__sflush_r+0x1a>
 c00908e:	0793      	lsls	r3, r2, #30
 c009090:	680e      	ldr	r6, [r1, #0]
 c009092:	600f      	str	r7, [r1, #0]
 c009094:	bf0c      	ite	eq
 c009096:	694b      	ldreq	r3, [r1, #20]
 c009098:	2300      	movne	r3, #0
 c00909a:	eba6 0807 	sub.w	r8, r6, r7
 c00909e:	608b      	str	r3, [r1, #8]
 c0090a0:	f1b8 0f00 	cmp.w	r8, #0
 c0090a4:	dd9d      	ble.n	c008fe2 <__sflush_r+0x1a>
 c0090a6:	4643      	mov	r3, r8
 c0090a8:	463a      	mov	r2, r7
 c0090aa:	6a21      	ldr	r1, [r4, #32]
 c0090ac:	4628      	mov	r0, r5
 c0090ae:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 c0090b0:	47b0      	blx	r6
 c0090b2:	2800      	cmp	r0, #0
 c0090b4:	dc06      	bgt.n	c0090c4 <__sflush_r+0xfc>
 c0090b6:	89a3      	ldrh	r3, [r4, #12]
 c0090b8:	f04f 30ff 	mov.w	r0, #4294967295
 c0090bc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c0090c0:	81a3      	strh	r3, [r4, #12]
 c0090c2:	e78f      	b.n	c008fe4 <__sflush_r+0x1c>
 c0090c4:	4407      	add	r7, r0
 c0090c6:	eba8 0800 	sub.w	r8, r8, r0
 c0090ca:	e7e9      	b.n	c0090a0 <__sflush_r+0xd8>
 c0090cc:	20400001 	.word	0x20400001

0c0090d0 <_fflush_r>:
 c0090d0:	b538      	push	{r3, r4, r5, lr}
 c0090d2:	690b      	ldr	r3, [r1, #16]
 c0090d4:	4605      	mov	r5, r0
 c0090d6:	460c      	mov	r4, r1
 c0090d8:	b913      	cbnz	r3, c0090e0 <_fflush_r+0x10>
 c0090da:	2500      	movs	r5, #0
 c0090dc:	4628      	mov	r0, r5
 c0090de:	bd38      	pop	{r3, r4, r5, pc}
 c0090e0:	b118      	cbz	r0, c0090ea <_fflush_r+0x1a>
 c0090e2:	6983      	ldr	r3, [r0, #24]
 c0090e4:	b90b      	cbnz	r3, c0090ea <_fflush_r+0x1a>
 c0090e6:	f000 f887 	bl	c0091f8 <__sinit>
 c0090ea:	4b14      	ldr	r3, [pc, #80]	; (c00913c <_fflush_r+0x6c>)
 c0090ec:	429c      	cmp	r4, r3
 c0090ee:	d11b      	bne.n	c009128 <_fflush_r+0x58>
 c0090f0:	686c      	ldr	r4, [r5, #4]
 c0090f2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c0090f6:	2b00      	cmp	r3, #0
 c0090f8:	d0ef      	beq.n	c0090da <_fflush_r+0xa>
 c0090fa:	6e62      	ldr	r2, [r4, #100]	; 0x64
 c0090fc:	07d0      	lsls	r0, r2, #31
 c0090fe:	d404      	bmi.n	c00910a <_fflush_r+0x3a>
 c009100:	0599      	lsls	r1, r3, #22
 c009102:	d402      	bmi.n	c00910a <_fflush_r+0x3a>
 c009104:	6da0      	ldr	r0, [r4, #88]	; 0x58
 c009106:	f000 f915 	bl	c009334 <__retarget_lock_acquire_recursive>
 c00910a:	4628      	mov	r0, r5
 c00910c:	4621      	mov	r1, r4
 c00910e:	f7ff ff5b 	bl	c008fc8 <__sflush_r>
 c009112:	6e63      	ldr	r3, [r4, #100]	; 0x64
 c009114:	4605      	mov	r5, r0
 c009116:	07da      	lsls	r2, r3, #31
 c009118:	d4e0      	bmi.n	c0090dc <_fflush_r+0xc>
 c00911a:	89a3      	ldrh	r3, [r4, #12]
 c00911c:	059b      	lsls	r3, r3, #22
 c00911e:	d4dd      	bmi.n	c0090dc <_fflush_r+0xc>
 c009120:	6da0      	ldr	r0, [r4, #88]	; 0x58
 c009122:	f000 f908 	bl	c009336 <__retarget_lock_release_recursive>
 c009126:	e7d9      	b.n	c0090dc <_fflush_r+0xc>
 c009128:	4b05      	ldr	r3, [pc, #20]	; (c009140 <_fflush_r+0x70>)
 c00912a:	429c      	cmp	r4, r3
 c00912c:	d101      	bne.n	c009132 <_fflush_r+0x62>
 c00912e:	68ac      	ldr	r4, [r5, #8]
 c009130:	e7df      	b.n	c0090f2 <_fflush_r+0x22>
 c009132:	4b04      	ldr	r3, [pc, #16]	; (c009144 <_fflush_r+0x74>)
 c009134:	429c      	cmp	r4, r3
 c009136:	bf08      	it	eq
 c009138:	68ec      	ldreq	r4, [r5, #12]
 c00913a:	e7da      	b.n	c0090f2 <_fflush_r+0x22>
 c00913c:	0c00adc0 	.word	0x0c00adc0
 c009140:	0c00ade0 	.word	0x0c00ade0
 c009144:	0c00ada0 	.word	0x0c00ada0

0c009148 <std>:
 c009148:	2300      	movs	r3, #0
 c00914a:	b510      	push	{r4, lr}
 c00914c:	4604      	mov	r4, r0
 c00914e:	6083      	str	r3, [r0, #8]
 c009150:	8181      	strh	r1, [r0, #12]
 c009152:	4619      	mov	r1, r3
 c009154:	6643      	str	r3, [r0, #100]	; 0x64
 c009156:	81c2      	strh	r2, [r0, #14]
 c009158:	2208      	movs	r2, #8
 c00915a:	6183      	str	r3, [r0, #24]
 c00915c:	e9c0 3300 	strd	r3, r3, [r0]
 c009160:	e9c0 3304 	strd	r3, r3, [r0, #16]
 c009164:	305c      	adds	r0, #92	; 0x5c
 c009166:	f7ff fd1e 	bl	c008ba6 <memset>
 c00916a:	4b05      	ldr	r3, [pc, #20]	; (c009180 <std+0x38>)
 c00916c:	6224      	str	r4, [r4, #32]
 c00916e:	6263      	str	r3, [r4, #36]	; 0x24
 c009170:	4b04      	ldr	r3, [pc, #16]	; (c009184 <std+0x3c>)
 c009172:	62a3      	str	r3, [r4, #40]	; 0x28
 c009174:	4b04      	ldr	r3, [pc, #16]	; (c009188 <std+0x40>)
 c009176:	62e3      	str	r3, [r4, #44]	; 0x2c
 c009178:	4b04      	ldr	r3, [pc, #16]	; (c00918c <std+0x44>)
 c00917a:	6323      	str	r3, [r4, #48]	; 0x30
 c00917c:	bd10      	pop	{r4, pc}
 c00917e:	bf00      	nop
 c009180:	0c0099f9 	.word	0x0c0099f9
 c009184:	0c009a1b 	.word	0x0c009a1b
 c009188:	0c009a53 	.word	0x0c009a53
 c00918c:	0c009a77 	.word	0x0c009a77

0c009190 <_cleanup_r>:
 c009190:	4901      	ldr	r1, [pc, #4]	; (c009198 <_cleanup_r+0x8>)
 c009192:	f000 b8af 	b.w	c0092f4 <_fwalk_reent>
 c009196:	bf00      	nop
 c009198:	0c0090d1 	.word	0x0c0090d1

0c00919c <__sfmoreglue>:
 c00919c:	b570      	push	{r4, r5, r6, lr}
 c00919e:	1e4a      	subs	r2, r1, #1
 c0091a0:	2568      	movs	r5, #104	; 0x68
 c0091a2:	460e      	mov	r6, r1
 c0091a4:	4355      	muls	r5, r2
 c0091a6:	f105 0174 	add.w	r1, r5, #116	; 0x74
 c0091aa:	f7ff fd55 	bl	c008c58 <_malloc_r>
 c0091ae:	4604      	mov	r4, r0
 c0091b0:	b140      	cbz	r0, c0091c4 <__sfmoreglue+0x28>
 c0091b2:	2100      	movs	r1, #0
 c0091b4:	f105 0268 	add.w	r2, r5, #104	; 0x68
 c0091b8:	e9c0 1600 	strd	r1, r6, [r0]
 c0091bc:	300c      	adds	r0, #12
 c0091be:	60a0      	str	r0, [r4, #8]
 c0091c0:	f7ff fcf1 	bl	c008ba6 <memset>
 c0091c4:	4620      	mov	r0, r4
 c0091c6:	bd70      	pop	{r4, r5, r6, pc}

0c0091c8 <__sfp_lock_acquire>:
 c0091c8:	4801      	ldr	r0, [pc, #4]	; (c0091d0 <__sfp_lock_acquire+0x8>)
 c0091ca:	f000 b8b3 	b.w	c009334 <__retarget_lock_acquire_recursive>
 c0091ce:	bf00      	nop
 c0091d0:	3003becc 	.word	0x3003becc

0c0091d4 <__sfp_lock_release>:
 c0091d4:	4801      	ldr	r0, [pc, #4]	; (c0091dc <__sfp_lock_release+0x8>)
 c0091d6:	f000 b8ae 	b.w	c009336 <__retarget_lock_release_recursive>
 c0091da:	bf00      	nop
 c0091dc:	3003becc 	.word	0x3003becc

0c0091e0 <__sinit_lock_acquire>:
 c0091e0:	4801      	ldr	r0, [pc, #4]	; (c0091e8 <__sinit_lock_acquire+0x8>)
 c0091e2:	f000 b8a7 	b.w	c009334 <__retarget_lock_acquire_recursive>
 c0091e6:	bf00      	nop
 c0091e8:	3003bec7 	.word	0x3003bec7

0c0091ec <__sinit_lock_release>:
 c0091ec:	4801      	ldr	r0, [pc, #4]	; (c0091f4 <__sinit_lock_release+0x8>)
 c0091ee:	f000 b8a2 	b.w	c009336 <__retarget_lock_release_recursive>
 c0091f2:	bf00      	nop
 c0091f4:	3003bec7 	.word	0x3003bec7

0c0091f8 <__sinit>:
 c0091f8:	b510      	push	{r4, lr}
 c0091fa:	4604      	mov	r4, r0
 c0091fc:	f7ff fff0 	bl	c0091e0 <__sinit_lock_acquire>
 c009200:	69a3      	ldr	r3, [r4, #24]
 c009202:	b11b      	cbz	r3, c00920c <__sinit+0x14>
 c009204:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c009208:	f7ff bff0 	b.w	c0091ec <__sinit_lock_release>
 c00920c:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 c009210:	6523      	str	r3, [r4, #80]	; 0x50
 c009212:	4620      	mov	r0, r4
 c009214:	4b12      	ldr	r3, [pc, #72]	; (c009260 <__sinit+0x68>)
 c009216:	4a13      	ldr	r2, [pc, #76]	; (c009264 <__sinit+0x6c>)
 c009218:	681b      	ldr	r3, [r3, #0]
 c00921a:	62a2      	str	r2, [r4, #40]	; 0x28
 c00921c:	42a3      	cmp	r3, r4
 c00921e:	bf04      	itt	eq
 c009220:	2301      	moveq	r3, #1
 c009222:	61a3      	streq	r3, [r4, #24]
 c009224:	f000 f820 	bl	c009268 <__sfp>
 c009228:	6060      	str	r0, [r4, #4]
 c00922a:	4620      	mov	r0, r4
 c00922c:	f000 f81c 	bl	c009268 <__sfp>
 c009230:	60a0      	str	r0, [r4, #8]
 c009232:	4620      	mov	r0, r4
 c009234:	f000 f818 	bl	c009268 <__sfp>
 c009238:	2200      	movs	r2, #0
 c00923a:	2104      	movs	r1, #4
 c00923c:	60e0      	str	r0, [r4, #12]
 c00923e:	6860      	ldr	r0, [r4, #4]
 c009240:	f7ff ff82 	bl	c009148 <std>
 c009244:	2201      	movs	r2, #1
 c009246:	2109      	movs	r1, #9
 c009248:	68a0      	ldr	r0, [r4, #8]
 c00924a:	f7ff ff7d 	bl	c009148 <std>
 c00924e:	2202      	movs	r2, #2
 c009250:	2112      	movs	r1, #18
 c009252:	68e0      	ldr	r0, [r4, #12]
 c009254:	f7ff ff78 	bl	c009148 <std>
 c009258:	2301      	movs	r3, #1
 c00925a:	61a3      	str	r3, [r4, #24]
 c00925c:	e7d2      	b.n	c009204 <__sinit+0xc>
 c00925e:	bf00      	nop
 c009260:	0c00ad9c 	.word	0x0c00ad9c
 c009264:	0c009191 	.word	0x0c009191

0c009268 <__sfp>:
 c009268:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00926a:	4607      	mov	r7, r0
 c00926c:	f7ff ffac 	bl	c0091c8 <__sfp_lock_acquire>
 c009270:	4b1e      	ldr	r3, [pc, #120]	; (c0092ec <__sfp+0x84>)
 c009272:	681e      	ldr	r6, [r3, #0]
 c009274:	69b3      	ldr	r3, [r6, #24]
 c009276:	b913      	cbnz	r3, c00927e <__sfp+0x16>
 c009278:	4630      	mov	r0, r6
 c00927a:	f7ff ffbd 	bl	c0091f8 <__sinit>
 c00927e:	3648      	adds	r6, #72	; 0x48
 c009280:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 c009284:	3b01      	subs	r3, #1
 c009286:	d503      	bpl.n	c009290 <__sfp+0x28>
 c009288:	6833      	ldr	r3, [r6, #0]
 c00928a:	b30b      	cbz	r3, c0092d0 <__sfp+0x68>
 c00928c:	6836      	ldr	r6, [r6, #0]
 c00928e:	e7f7      	b.n	c009280 <__sfp+0x18>
 c009290:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 c009294:	b9d5      	cbnz	r5, c0092cc <__sfp+0x64>
 c009296:	4b16      	ldr	r3, [pc, #88]	; (c0092f0 <__sfp+0x88>)
 c009298:	f104 0058 	add.w	r0, r4, #88	; 0x58
 c00929c:	6665      	str	r5, [r4, #100]	; 0x64
 c00929e:	60e3      	str	r3, [r4, #12]
 c0092a0:	f000 f847 	bl	c009332 <__retarget_lock_init_recursive>
 c0092a4:	f7ff ff96 	bl	c0091d4 <__sfp_lock_release>
 c0092a8:	2208      	movs	r2, #8
 c0092aa:	4629      	mov	r1, r5
 c0092ac:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 c0092b0:	6025      	str	r5, [r4, #0]
 c0092b2:	61a5      	str	r5, [r4, #24]
 c0092b4:	e9c4 5501 	strd	r5, r5, [r4, #4]
 c0092b8:	e9c4 5504 	strd	r5, r5, [r4, #16]
 c0092bc:	f7ff fc73 	bl	c008ba6 <memset>
 c0092c0:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 c0092c4:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 c0092c8:	4620      	mov	r0, r4
 c0092ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c0092cc:	3468      	adds	r4, #104	; 0x68
 c0092ce:	e7d9      	b.n	c009284 <__sfp+0x1c>
 c0092d0:	2104      	movs	r1, #4
 c0092d2:	4638      	mov	r0, r7
 c0092d4:	f7ff ff62 	bl	c00919c <__sfmoreglue>
 c0092d8:	4604      	mov	r4, r0
 c0092da:	6030      	str	r0, [r6, #0]
 c0092dc:	2800      	cmp	r0, #0
 c0092de:	d1d5      	bne.n	c00928c <__sfp+0x24>
 c0092e0:	f7ff ff78 	bl	c0091d4 <__sfp_lock_release>
 c0092e4:	230c      	movs	r3, #12
 c0092e6:	603b      	str	r3, [r7, #0]
 c0092e8:	e7ee      	b.n	c0092c8 <__sfp+0x60>
 c0092ea:	bf00      	nop
 c0092ec:	0c00ad9c 	.word	0x0c00ad9c
 c0092f0:	ffff0001 	.word	0xffff0001

0c0092f4 <_fwalk_reent>:
 c0092f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c0092f8:	4606      	mov	r6, r0
 c0092fa:	4688      	mov	r8, r1
 c0092fc:	f100 0448 	add.w	r4, r0, #72	; 0x48
 c009300:	2700      	movs	r7, #0
 c009302:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 c009306:	f1b9 0901 	subs.w	r9, r9, #1
 c00930a:	d505      	bpl.n	c009318 <_fwalk_reent+0x24>
 c00930c:	6824      	ldr	r4, [r4, #0]
 c00930e:	2c00      	cmp	r4, #0
 c009310:	d1f7      	bne.n	c009302 <_fwalk_reent+0xe>
 c009312:	4638      	mov	r0, r7
 c009314:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c009318:	89ab      	ldrh	r3, [r5, #12]
 c00931a:	2b01      	cmp	r3, #1
 c00931c:	d907      	bls.n	c00932e <_fwalk_reent+0x3a>
 c00931e:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 c009322:	3301      	adds	r3, #1
 c009324:	d003      	beq.n	c00932e <_fwalk_reent+0x3a>
 c009326:	4629      	mov	r1, r5
 c009328:	4630      	mov	r0, r6
 c00932a:	47c0      	blx	r8
 c00932c:	4307      	orrs	r7, r0
 c00932e:	3568      	adds	r5, #104	; 0x68
 c009330:	e7e9      	b.n	c009306 <_fwalk_reent+0x12>

0c009332 <__retarget_lock_init_recursive>:
 c009332:	4770      	bx	lr

0c009334 <__retarget_lock_acquire_recursive>:
 c009334:	4770      	bx	lr

0c009336 <__retarget_lock_release_recursive>:
 c009336:	4770      	bx	lr

0c009338 <__swhatbuf_r>:
 c009338:	b570      	push	{r4, r5, r6, lr}
 c00933a:	460e      	mov	r6, r1
 c00933c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c009340:	b096      	sub	sp, #88	; 0x58
 c009342:	4614      	mov	r4, r2
 c009344:	2900      	cmp	r1, #0
 c009346:	461d      	mov	r5, r3
 c009348:	da07      	bge.n	c00935a <__swhatbuf_r+0x22>
 c00934a:	2300      	movs	r3, #0
 c00934c:	602b      	str	r3, [r5, #0]
 c00934e:	89b3      	ldrh	r3, [r6, #12]
 c009350:	061a      	lsls	r2, r3, #24
 c009352:	d410      	bmi.n	c009376 <__swhatbuf_r+0x3e>
 c009354:	f44f 6380 	mov.w	r3, #1024	; 0x400
 c009358:	e00e      	b.n	c009378 <__swhatbuf_r+0x40>
 c00935a:	466a      	mov	r2, sp
 c00935c:	f000 fbb2 	bl	c009ac4 <_fstat_r>
 c009360:	2800      	cmp	r0, #0
 c009362:	dbf2      	blt.n	c00934a <__swhatbuf_r+0x12>
 c009364:	9a01      	ldr	r2, [sp, #4]
 c009366:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 c00936a:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 c00936e:	425a      	negs	r2, r3
 c009370:	415a      	adcs	r2, r3
 c009372:	602a      	str	r2, [r5, #0]
 c009374:	e7ee      	b.n	c009354 <__swhatbuf_r+0x1c>
 c009376:	2340      	movs	r3, #64	; 0x40
 c009378:	2000      	movs	r0, #0
 c00937a:	6023      	str	r3, [r4, #0]
 c00937c:	b016      	add	sp, #88	; 0x58
 c00937e:	bd70      	pop	{r4, r5, r6, pc}

0c009380 <__smakebuf_r>:
 c009380:	898b      	ldrh	r3, [r1, #12]
 c009382:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c009384:	079d      	lsls	r5, r3, #30
 c009386:	4606      	mov	r6, r0
 c009388:	460c      	mov	r4, r1
 c00938a:	d507      	bpl.n	c00939c <__smakebuf_r+0x1c>
 c00938c:	f104 0347 	add.w	r3, r4, #71	; 0x47
 c009390:	6023      	str	r3, [r4, #0]
 c009392:	6123      	str	r3, [r4, #16]
 c009394:	2301      	movs	r3, #1
 c009396:	6163      	str	r3, [r4, #20]
 c009398:	b002      	add	sp, #8
 c00939a:	bd70      	pop	{r4, r5, r6, pc}
 c00939c:	ab01      	add	r3, sp, #4
 c00939e:	466a      	mov	r2, sp
 c0093a0:	f7ff ffca 	bl	c009338 <__swhatbuf_r>
 c0093a4:	9900      	ldr	r1, [sp, #0]
 c0093a6:	4605      	mov	r5, r0
 c0093a8:	4630      	mov	r0, r6
 c0093aa:	f7ff fc55 	bl	c008c58 <_malloc_r>
 c0093ae:	b948      	cbnz	r0, c0093c4 <__smakebuf_r+0x44>
 c0093b0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c0093b4:	059a      	lsls	r2, r3, #22
 c0093b6:	d4ef      	bmi.n	c009398 <__smakebuf_r+0x18>
 c0093b8:	f023 0303 	bic.w	r3, r3, #3
 c0093bc:	f043 0302 	orr.w	r3, r3, #2
 c0093c0:	81a3      	strh	r3, [r4, #12]
 c0093c2:	e7e3      	b.n	c00938c <__smakebuf_r+0xc>
 c0093c4:	4b0d      	ldr	r3, [pc, #52]	; (c0093fc <__smakebuf_r+0x7c>)
 c0093c6:	62b3      	str	r3, [r6, #40]	; 0x28
 c0093c8:	89a3      	ldrh	r3, [r4, #12]
 c0093ca:	6020      	str	r0, [r4, #0]
 c0093cc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c0093d0:	6120      	str	r0, [r4, #16]
 c0093d2:	81a3      	strh	r3, [r4, #12]
 c0093d4:	9b00      	ldr	r3, [sp, #0]
 c0093d6:	6163      	str	r3, [r4, #20]
 c0093d8:	9b01      	ldr	r3, [sp, #4]
 c0093da:	b15b      	cbz	r3, c0093f4 <__smakebuf_r+0x74>
 c0093dc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c0093e0:	4630      	mov	r0, r6
 c0093e2:	f000 fb81 	bl	c009ae8 <_isatty_r>
 c0093e6:	b128      	cbz	r0, c0093f4 <__smakebuf_r+0x74>
 c0093e8:	89a3      	ldrh	r3, [r4, #12]
 c0093ea:	f023 0303 	bic.w	r3, r3, #3
 c0093ee:	f043 0301 	orr.w	r3, r3, #1
 c0093f2:	81a3      	strh	r3, [r4, #12]
 c0093f4:	89a0      	ldrh	r0, [r4, #12]
 c0093f6:	4305      	orrs	r5, r0
 c0093f8:	81a5      	strh	r5, [r4, #12]
 c0093fa:	e7cd      	b.n	c009398 <__smakebuf_r+0x18>
 c0093fc:	0c009191 	.word	0x0c009191

0c009400 <__malloc_lock>:
 c009400:	4801      	ldr	r0, [pc, #4]	; (c009408 <__malloc_lock+0x8>)
 c009402:	f7ff bf97 	b.w	c009334 <__retarget_lock_acquire_recursive>
 c009406:	bf00      	nop
 c009408:	3003bec8 	.word	0x3003bec8

0c00940c <__malloc_unlock>:
 c00940c:	4801      	ldr	r0, [pc, #4]	; (c009414 <__malloc_unlock+0x8>)
 c00940e:	f7ff bf92 	b.w	c009336 <__retarget_lock_release_recursive>
 c009412:	bf00      	nop
 c009414:	3003bec8 	.word	0x3003bec8

0c009418 <__sfputc_r>:
 c009418:	6893      	ldr	r3, [r2, #8]
 c00941a:	3b01      	subs	r3, #1
 c00941c:	2b00      	cmp	r3, #0
 c00941e:	6093      	str	r3, [r2, #8]
 c009420:	b410      	push	{r4}
 c009422:	da08      	bge.n	c009436 <__sfputc_r+0x1e>
 c009424:	6994      	ldr	r4, [r2, #24]
 c009426:	42a3      	cmp	r3, r4
 c009428:	db01      	blt.n	c00942e <__sfputc_r+0x16>
 c00942a:	290a      	cmp	r1, #10
 c00942c:	d103      	bne.n	c009436 <__sfputc_r+0x1e>
 c00942e:	f85d 4b04 	ldr.w	r4, [sp], #4
 c009432:	f7ff bd09 	b.w	c008e48 <__swbuf_r>
 c009436:	6813      	ldr	r3, [r2, #0]
 c009438:	1c58      	adds	r0, r3, #1
 c00943a:	6010      	str	r0, [r2, #0]
 c00943c:	4608      	mov	r0, r1
 c00943e:	7019      	strb	r1, [r3, #0]
 c009440:	f85d 4b04 	ldr.w	r4, [sp], #4
 c009444:	4770      	bx	lr

0c009446 <__sfputs_r>:
 c009446:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c009448:	4606      	mov	r6, r0
 c00944a:	460f      	mov	r7, r1
 c00944c:	4614      	mov	r4, r2
 c00944e:	18d5      	adds	r5, r2, r3
 c009450:	42ac      	cmp	r4, r5
 c009452:	d101      	bne.n	c009458 <__sfputs_r+0x12>
 c009454:	2000      	movs	r0, #0
 c009456:	e007      	b.n	c009468 <__sfputs_r+0x22>
 c009458:	463a      	mov	r2, r7
 c00945a:	f814 1b01 	ldrb.w	r1, [r4], #1
 c00945e:	4630      	mov	r0, r6
 c009460:	f7ff ffda 	bl	c009418 <__sfputc_r>
 c009464:	1c43      	adds	r3, r0, #1
 c009466:	d1f3      	bne.n	c009450 <__sfputs_r+0xa>
 c009468:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0c00946c <_vfiprintf_r>:
 c00946c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c009470:	460d      	mov	r5, r1
 c009472:	b09d      	sub	sp, #116	; 0x74
 c009474:	4614      	mov	r4, r2
 c009476:	4698      	mov	r8, r3
 c009478:	4606      	mov	r6, r0
 c00947a:	b118      	cbz	r0, c009484 <_vfiprintf_r+0x18>
 c00947c:	6983      	ldr	r3, [r0, #24]
 c00947e:	b90b      	cbnz	r3, c009484 <_vfiprintf_r+0x18>
 c009480:	f7ff feba 	bl	c0091f8 <__sinit>
 c009484:	4b89      	ldr	r3, [pc, #548]	; (c0096ac <_vfiprintf_r+0x240>)
 c009486:	429d      	cmp	r5, r3
 c009488:	d11b      	bne.n	c0094c2 <_vfiprintf_r+0x56>
 c00948a:	6875      	ldr	r5, [r6, #4]
 c00948c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 c00948e:	07d9      	lsls	r1, r3, #31
 c009490:	d405      	bmi.n	c00949e <_vfiprintf_r+0x32>
 c009492:	89ab      	ldrh	r3, [r5, #12]
 c009494:	059a      	lsls	r2, r3, #22
 c009496:	d402      	bmi.n	c00949e <_vfiprintf_r+0x32>
 c009498:	6da8      	ldr	r0, [r5, #88]	; 0x58
 c00949a:	f7ff ff4b 	bl	c009334 <__retarget_lock_acquire_recursive>
 c00949e:	89ab      	ldrh	r3, [r5, #12]
 c0094a0:	071b      	lsls	r3, r3, #28
 c0094a2:	d501      	bpl.n	c0094a8 <_vfiprintf_r+0x3c>
 c0094a4:	692b      	ldr	r3, [r5, #16]
 c0094a6:	b9eb      	cbnz	r3, c0094e4 <_vfiprintf_r+0x78>
 c0094a8:	4629      	mov	r1, r5
 c0094aa:	4630      	mov	r0, r6
 c0094ac:	f7ff fd1e 	bl	c008eec <__swsetup_r>
 c0094b0:	b1c0      	cbz	r0, c0094e4 <_vfiprintf_r+0x78>
 c0094b2:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 c0094b4:	07dc      	lsls	r4, r3, #31
 c0094b6:	d50e      	bpl.n	c0094d6 <_vfiprintf_r+0x6a>
 c0094b8:	f04f 30ff 	mov.w	r0, #4294967295
 c0094bc:	b01d      	add	sp, #116	; 0x74
 c0094be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c0094c2:	4b7b      	ldr	r3, [pc, #492]	; (c0096b0 <_vfiprintf_r+0x244>)
 c0094c4:	429d      	cmp	r5, r3
 c0094c6:	d101      	bne.n	c0094cc <_vfiprintf_r+0x60>
 c0094c8:	68b5      	ldr	r5, [r6, #8]
 c0094ca:	e7df      	b.n	c00948c <_vfiprintf_r+0x20>
 c0094cc:	4b79      	ldr	r3, [pc, #484]	; (c0096b4 <_vfiprintf_r+0x248>)
 c0094ce:	429d      	cmp	r5, r3
 c0094d0:	bf08      	it	eq
 c0094d2:	68f5      	ldreq	r5, [r6, #12]
 c0094d4:	e7da      	b.n	c00948c <_vfiprintf_r+0x20>
 c0094d6:	89ab      	ldrh	r3, [r5, #12]
 c0094d8:	0598      	lsls	r0, r3, #22
 c0094da:	d4ed      	bmi.n	c0094b8 <_vfiprintf_r+0x4c>
 c0094dc:	6da8      	ldr	r0, [r5, #88]	; 0x58
 c0094de:	f7ff ff2a 	bl	c009336 <__retarget_lock_release_recursive>
 c0094e2:	e7e9      	b.n	c0094b8 <_vfiprintf_r+0x4c>
 c0094e4:	2300      	movs	r3, #0
 c0094e6:	f8cd 800c 	str.w	r8, [sp, #12]
 c0094ea:	f04f 0901 	mov.w	r9, #1
 c0094ee:	f8df 81c8 	ldr.w	r8, [pc, #456]	; c0096b8 <_vfiprintf_r+0x24c>
 c0094f2:	9309      	str	r3, [sp, #36]	; 0x24
 c0094f4:	2320      	movs	r3, #32
 c0094f6:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 c0094fa:	2330      	movs	r3, #48	; 0x30
 c0094fc:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 c009500:	4623      	mov	r3, r4
 c009502:	469a      	mov	sl, r3
 c009504:	f813 2b01 	ldrb.w	r2, [r3], #1
 c009508:	b10a      	cbz	r2, c00950e <_vfiprintf_r+0xa2>
 c00950a:	2a25      	cmp	r2, #37	; 0x25
 c00950c:	d1f9      	bne.n	c009502 <_vfiprintf_r+0x96>
 c00950e:	ebba 0b04 	subs.w	fp, sl, r4
 c009512:	d00b      	beq.n	c00952c <_vfiprintf_r+0xc0>
 c009514:	465b      	mov	r3, fp
 c009516:	4622      	mov	r2, r4
 c009518:	4629      	mov	r1, r5
 c00951a:	4630      	mov	r0, r6
 c00951c:	f7ff ff93 	bl	c009446 <__sfputs_r>
 c009520:	3001      	adds	r0, #1
 c009522:	f000 80aa 	beq.w	c00967a <_vfiprintf_r+0x20e>
 c009526:	9a09      	ldr	r2, [sp, #36]	; 0x24
 c009528:	445a      	add	r2, fp
 c00952a:	9209      	str	r2, [sp, #36]	; 0x24
 c00952c:	f89a 3000 	ldrb.w	r3, [sl]
 c009530:	2b00      	cmp	r3, #0
 c009532:	f000 80a2 	beq.w	c00967a <_vfiprintf_r+0x20e>
 c009536:	2300      	movs	r3, #0
 c009538:	f04f 32ff 	mov.w	r2, #4294967295
 c00953c:	f10a 0a01 	add.w	sl, sl, #1
 c009540:	9304      	str	r3, [sp, #16]
 c009542:	9307      	str	r3, [sp, #28]
 c009544:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 c009548:	931a      	str	r3, [sp, #104]	; 0x68
 c00954a:	e9cd 2305 	strd	r2, r3, [sp, #20]
 c00954e:	4654      	mov	r4, sl
 c009550:	2205      	movs	r2, #5
 c009552:	4859      	ldr	r0, [pc, #356]	; (c0096b8 <_vfiprintf_r+0x24c>)
 c009554:	f814 1b01 	ldrb.w	r1, [r4], #1
 c009558:	f000 fae8 	bl	c009b2c <memchr>
 c00955c:	9a04      	ldr	r2, [sp, #16]
 c00955e:	b9d8      	cbnz	r0, c009598 <_vfiprintf_r+0x12c>
 c009560:	06d1      	lsls	r1, r2, #27
 c009562:	bf44      	itt	mi
 c009564:	2320      	movmi	r3, #32
 c009566:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 c00956a:	0713      	lsls	r3, r2, #28
 c00956c:	bf44      	itt	mi
 c00956e:	232b      	movmi	r3, #43	; 0x2b
 c009570:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 c009574:	f89a 3000 	ldrb.w	r3, [sl]
 c009578:	2b2a      	cmp	r3, #42	; 0x2a
 c00957a:	d015      	beq.n	c0095a8 <_vfiprintf_r+0x13c>
 c00957c:	9a07      	ldr	r2, [sp, #28]
 c00957e:	4654      	mov	r4, sl
 c009580:	2000      	movs	r0, #0
 c009582:	f04f 0c0a 	mov.w	ip, #10
 c009586:	4621      	mov	r1, r4
 c009588:	f811 3b01 	ldrb.w	r3, [r1], #1
 c00958c:	3b30      	subs	r3, #48	; 0x30
 c00958e:	2b09      	cmp	r3, #9
 c009590:	d94e      	bls.n	c009630 <_vfiprintf_r+0x1c4>
 c009592:	b1b0      	cbz	r0, c0095c2 <_vfiprintf_r+0x156>
 c009594:	9207      	str	r2, [sp, #28]
 c009596:	e014      	b.n	c0095c2 <_vfiprintf_r+0x156>
 c009598:	eba0 0308 	sub.w	r3, r0, r8
 c00959c:	46a2      	mov	sl, r4
 c00959e:	fa09 f303 	lsl.w	r3, r9, r3
 c0095a2:	4313      	orrs	r3, r2
 c0095a4:	9304      	str	r3, [sp, #16]
 c0095a6:	e7d2      	b.n	c00954e <_vfiprintf_r+0xe2>
 c0095a8:	9b03      	ldr	r3, [sp, #12]
 c0095aa:	1d19      	adds	r1, r3, #4
 c0095ac:	681b      	ldr	r3, [r3, #0]
 c0095ae:	2b00      	cmp	r3, #0
 c0095b0:	9103      	str	r1, [sp, #12]
 c0095b2:	bfbb      	ittet	lt
 c0095b4:	425b      	neglt	r3, r3
 c0095b6:	f042 0202 	orrlt.w	r2, r2, #2
 c0095ba:	9307      	strge	r3, [sp, #28]
 c0095bc:	9307      	strlt	r3, [sp, #28]
 c0095be:	bfb8      	it	lt
 c0095c0:	9204      	strlt	r2, [sp, #16]
 c0095c2:	7823      	ldrb	r3, [r4, #0]
 c0095c4:	2b2e      	cmp	r3, #46	; 0x2e
 c0095c6:	d10c      	bne.n	c0095e2 <_vfiprintf_r+0x176>
 c0095c8:	7863      	ldrb	r3, [r4, #1]
 c0095ca:	2b2a      	cmp	r3, #42	; 0x2a
 c0095cc:	d135      	bne.n	c00963a <_vfiprintf_r+0x1ce>
 c0095ce:	9b03      	ldr	r3, [sp, #12]
 c0095d0:	3402      	adds	r4, #2
 c0095d2:	1d1a      	adds	r2, r3, #4
 c0095d4:	681b      	ldr	r3, [r3, #0]
 c0095d6:	2b00      	cmp	r3, #0
 c0095d8:	9203      	str	r2, [sp, #12]
 c0095da:	bfb8      	it	lt
 c0095dc:	f04f 33ff 	movlt.w	r3, #4294967295
 c0095e0:	9305      	str	r3, [sp, #20]
 c0095e2:	f8df a0e4 	ldr.w	sl, [pc, #228]	; c0096c8 <_vfiprintf_r+0x25c>
 c0095e6:	2203      	movs	r2, #3
 c0095e8:	7821      	ldrb	r1, [r4, #0]
 c0095ea:	4650      	mov	r0, sl
 c0095ec:	f000 fa9e 	bl	c009b2c <memchr>
 c0095f0:	b140      	cbz	r0, c009604 <_vfiprintf_r+0x198>
 c0095f2:	2340      	movs	r3, #64	; 0x40
 c0095f4:	eba0 000a 	sub.w	r0, r0, sl
 c0095f8:	3401      	adds	r4, #1
 c0095fa:	fa03 f000 	lsl.w	r0, r3, r0
 c0095fe:	9b04      	ldr	r3, [sp, #16]
 c009600:	4303      	orrs	r3, r0
 c009602:	9304      	str	r3, [sp, #16]
 c009604:	f814 1b01 	ldrb.w	r1, [r4], #1
 c009608:	2206      	movs	r2, #6
 c00960a:	482c      	ldr	r0, [pc, #176]	; (c0096bc <_vfiprintf_r+0x250>)
 c00960c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 c009610:	f000 fa8c 	bl	c009b2c <memchr>
 c009614:	2800      	cmp	r0, #0
 c009616:	d03f      	beq.n	c009698 <_vfiprintf_r+0x22c>
 c009618:	4b29      	ldr	r3, [pc, #164]	; (c0096c0 <_vfiprintf_r+0x254>)
 c00961a:	bb1b      	cbnz	r3, c009664 <_vfiprintf_r+0x1f8>
 c00961c:	9b03      	ldr	r3, [sp, #12]
 c00961e:	3307      	adds	r3, #7
 c009620:	f023 0307 	bic.w	r3, r3, #7
 c009624:	3308      	adds	r3, #8
 c009626:	9303      	str	r3, [sp, #12]
 c009628:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c00962a:	443b      	add	r3, r7
 c00962c:	9309      	str	r3, [sp, #36]	; 0x24
 c00962e:	e767      	b.n	c009500 <_vfiprintf_r+0x94>
 c009630:	fb0c 3202 	mla	r2, ip, r2, r3
 c009634:	460c      	mov	r4, r1
 c009636:	2001      	movs	r0, #1
 c009638:	e7a5      	b.n	c009586 <_vfiprintf_r+0x11a>
 c00963a:	2300      	movs	r3, #0
 c00963c:	3401      	adds	r4, #1
 c00963e:	f04f 0c0a 	mov.w	ip, #10
 c009642:	4619      	mov	r1, r3
 c009644:	9305      	str	r3, [sp, #20]
 c009646:	4620      	mov	r0, r4
 c009648:	f810 2b01 	ldrb.w	r2, [r0], #1
 c00964c:	3a30      	subs	r2, #48	; 0x30
 c00964e:	2a09      	cmp	r2, #9
 c009650:	d903      	bls.n	c00965a <_vfiprintf_r+0x1ee>
 c009652:	2b00      	cmp	r3, #0
 c009654:	d0c5      	beq.n	c0095e2 <_vfiprintf_r+0x176>
 c009656:	9105      	str	r1, [sp, #20]
 c009658:	e7c3      	b.n	c0095e2 <_vfiprintf_r+0x176>
 c00965a:	fb0c 2101 	mla	r1, ip, r1, r2
 c00965e:	4604      	mov	r4, r0
 c009660:	2301      	movs	r3, #1
 c009662:	e7f0      	b.n	c009646 <_vfiprintf_r+0x1da>
 c009664:	ab03      	add	r3, sp, #12
 c009666:	462a      	mov	r2, r5
 c009668:	a904      	add	r1, sp, #16
 c00966a:	4630      	mov	r0, r6
 c00966c:	9300      	str	r3, [sp, #0]
 c00966e:	4b15      	ldr	r3, [pc, #84]	; (c0096c4 <_vfiprintf_r+0x258>)
 c009670:	e000      	b.n	c009674 <_vfiprintf_r+0x208>
 c009672:	bf00      	nop
 c009674:	4607      	mov	r7, r0
 c009676:	1c78      	adds	r0, r7, #1
 c009678:	d1d6      	bne.n	c009628 <_vfiprintf_r+0x1bc>
 c00967a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 c00967c:	07d9      	lsls	r1, r3, #31
 c00967e:	d405      	bmi.n	c00968c <_vfiprintf_r+0x220>
 c009680:	89ab      	ldrh	r3, [r5, #12]
 c009682:	059a      	lsls	r2, r3, #22
 c009684:	d402      	bmi.n	c00968c <_vfiprintf_r+0x220>
 c009686:	6da8      	ldr	r0, [r5, #88]	; 0x58
 c009688:	f7ff fe55 	bl	c009336 <__retarget_lock_release_recursive>
 c00968c:	89ab      	ldrh	r3, [r5, #12]
 c00968e:	065b      	lsls	r3, r3, #25
 c009690:	f53f af12 	bmi.w	c0094b8 <_vfiprintf_r+0x4c>
 c009694:	9809      	ldr	r0, [sp, #36]	; 0x24
 c009696:	e711      	b.n	c0094bc <_vfiprintf_r+0x50>
 c009698:	ab03      	add	r3, sp, #12
 c00969a:	462a      	mov	r2, r5
 c00969c:	a904      	add	r1, sp, #16
 c00969e:	4630      	mov	r0, r6
 c0096a0:	9300      	str	r3, [sp, #0]
 c0096a2:	4b08      	ldr	r3, [pc, #32]	; (c0096c4 <_vfiprintf_r+0x258>)
 c0096a4:	f000 f882 	bl	c0097ac <_printf_i>
 c0096a8:	e7e4      	b.n	c009674 <_vfiprintf_r+0x208>
 c0096aa:	bf00      	nop
 c0096ac:	0c00adc0 	.word	0x0c00adc0
 c0096b0:	0c00ade0 	.word	0x0c00ade0
 c0096b4:	0c00ada0 	.word	0x0c00ada0
 c0096b8:	0c00ae00 	.word	0x0c00ae00
 c0096bc:	0c00ae0a 	.word	0x0c00ae0a
 c0096c0:	00000000 	.word	0x00000000
 c0096c4:	0c009447 	.word	0x0c009447
 c0096c8:	0c00ae06 	.word	0x0c00ae06

0c0096cc <_printf_common>:
 c0096cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c0096d0:	4616      	mov	r6, r2
 c0096d2:	4699      	mov	r9, r3
 c0096d4:	688a      	ldr	r2, [r1, #8]
 c0096d6:	4607      	mov	r7, r0
 c0096d8:	690b      	ldr	r3, [r1, #16]
 c0096da:	460c      	mov	r4, r1
 c0096dc:	f8dd 8020 	ldr.w	r8, [sp, #32]
 c0096e0:	4293      	cmp	r3, r2
 c0096e2:	bfb8      	it	lt
 c0096e4:	4613      	movlt	r3, r2
 c0096e6:	6033      	str	r3, [r6, #0]
 c0096e8:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 c0096ec:	b10a      	cbz	r2, c0096f2 <_printf_common+0x26>
 c0096ee:	3301      	adds	r3, #1
 c0096f0:	6033      	str	r3, [r6, #0]
 c0096f2:	6823      	ldr	r3, [r4, #0]
 c0096f4:	0699      	lsls	r1, r3, #26
 c0096f6:	bf42      	ittt	mi
 c0096f8:	6833      	ldrmi	r3, [r6, #0]
 c0096fa:	3302      	addmi	r3, #2
 c0096fc:	6033      	strmi	r3, [r6, #0]
 c0096fe:	6825      	ldr	r5, [r4, #0]
 c009700:	f015 0506 	ands.w	r5, r5, #6
 c009704:	d106      	bne.n	c009714 <_printf_common+0x48>
 c009706:	f104 0a19 	add.w	sl, r4, #25
 c00970a:	68e3      	ldr	r3, [r4, #12]
 c00970c:	6832      	ldr	r2, [r6, #0]
 c00970e:	1a9b      	subs	r3, r3, r2
 c009710:	42ab      	cmp	r3, r5
 c009712:	dc29      	bgt.n	c009768 <_printf_common+0x9c>
 c009714:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 c009718:	1e13      	subs	r3, r2, #0
 c00971a:	6822      	ldr	r2, [r4, #0]
 c00971c:	bf18      	it	ne
 c00971e:	2301      	movne	r3, #1
 c009720:	0692      	lsls	r2, r2, #26
 c009722:	d42e      	bmi.n	c009782 <_printf_common+0xb6>
 c009724:	f104 0243 	add.w	r2, r4, #67	; 0x43
 c009728:	4649      	mov	r1, r9
 c00972a:	4638      	mov	r0, r7
 c00972c:	47c0      	blx	r8
 c00972e:	3001      	adds	r0, #1
 c009730:	d021      	beq.n	c009776 <_printf_common+0xaa>
 c009732:	6823      	ldr	r3, [r4, #0]
 c009734:	341a      	adds	r4, #26
 c009736:	f854 5c0e 	ldr.w	r5, [r4, #-14]
 c00973a:	f003 0306 	and.w	r3, r3, #6
 c00973e:	6832      	ldr	r2, [r6, #0]
 c009740:	2600      	movs	r6, #0
 c009742:	2b04      	cmp	r3, #4
 c009744:	f854 3c12 	ldr.w	r3, [r4, #-18]
 c009748:	bf08      	it	eq
 c00974a:	1aad      	subeq	r5, r5, r2
 c00974c:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 c009750:	bf14      	ite	ne
 c009752:	2500      	movne	r5, #0
 c009754:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 c009758:	4293      	cmp	r3, r2
 c00975a:	bfc4      	itt	gt
 c00975c:	1a9b      	subgt	r3, r3, r2
 c00975e:	18ed      	addgt	r5, r5, r3
 c009760:	42b5      	cmp	r5, r6
 c009762:	d11a      	bne.n	c00979a <_printf_common+0xce>
 c009764:	2000      	movs	r0, #0
 c009766:	e008      	b.n	c00977a <_printf_common+0xae>
 c009768:	2301      	movs	r3, #1
 c00976a:	4652      	mov	r2, sl
 c00976c:	4649      	mov	r1, r9
 c00976e:	4638      	mov	r0, r7
 c009770:	47c0      	blx	r8
 c009772:	3001      	adds	r0, #1
 c009774:	d103      	bne.n	c00977e <_printf_common+0xb2>
 c009776:	f04f 30ff 	mov.w	r0, #4294967295
 c00977a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c00977e:	3501      	adds	r5, #1
 c009780:	e7c3      	b.n	c00970a <_printf_common+0x3e>
 c009782:	18e1      	adds	r1, r4, r3
 c009784:	1c5a      	adds	r2, r3, #1
 c009786:	2030      	movs	r0, #48	; 0x30
 c009788:	3302      	adds	r3, #2
 c00978a:	4422      	add	r2, r4
 c00978c:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 c009790:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 c009794:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 c009798:	e7c4      	b.n	c009724 <_printf_common+0x58>
 c00979a:	2301      	movs	r3, #1
 c00979c:	4622      	mov	r2, r4
 c00979e:	4649      	mov	r1, r9
 c0097a0:	4638      	mov	r0, r7
 c0097a2:	47c0      	blx	r8
 c0097a4:	3001      	adds	r0, #1
 c0097a6:	d0e6      	beq.n	c009776 <_printf_common+0xaa>
 c0097a8:	3601      	adds	r6, #1
 c0097aa:	e7d9      	b.n	c009760 <_printf_common+0x94>

0c0097ac <_printf_i>:
 c0097ac:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 c0097b0:	460c      	mov	r4, r1
 c0097b2:	4691      	mov	r9, r2
 c0097b4:	4680      	mov	r8, r0
 c0097b6:	469a      	mov	sl, r3
 c0097b8:	7e27      	ldrb	r7, [r4, #24]
 c0097ba:	f104 0243 	add.w	r2, r4, #67	; 0x43
 c0097be:	990c      	ldr	r1, [sp, #48]	; 0x30
 c0097c0:	2f78      	cmp	r7, #120	; 0x78
 c0097c2:	d807      	bhi.n	c0097d4 <_printf_i+0x28>
 c0097c4:	2f62      	cmp	r7, #98	; 0x62
 c0097c6:	d80a      	bhi.n	c0097de <_printf_i+0x32>
 c0097c8:	2f00      	cmp	r7, #0
 c0097ca:	f000 80d8 	beq.w	c00997e <_printf_i+0x1d2>
 c0097ce:	2f58      	cmp	r7, #88	; 0x58
 c0097d0:	f000 80a3 	beq.w	c00991a <_printf_i+0x16e>
 c0097d4:	f104 0642 	add.w	r6, r4, #66	; 0x42
 c0097d8:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 c0097dc:	e03a      	b.n	c009854 <_printf_i+0xa8>
 c0097de:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 c0097e2:	2b15      	cmp	r3, #21
 c0097e4:	d8f6      	bhi.n	c0097d4 <_printf_i+0x28>
 c0097e6:	a001      	add	r0, pc, #4	; (adr r0, c0097ec <_printf_i+0x40>)
 c0097e8:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
 c0097ec:	0c009845 	.word	0x0c009845
 c0097f0:	0c009859 	.word	0x0c009859
 c0097f4:	0c0097d5 	.word	0x0c0097d5
 c0097f8:	0c0097d5 	.word	0x0c0097d5
 c0097fc:	0c0097d5 	.word	0x0c0097d5
 c009800:	0c0097d5 	.word	0x0c0097d5
 c009804:	0c009859 	.word	0x0c009859
 c009808:	0c0097d5 	.word	0x0c0097d5
 c00980c:	0c0097d5 	.word	0x0c0097d5
 c009810:	0c0097d5 	.word	0x0c0097d5
 c009814:	0c0097d5 	.word	0x0c0097d5
 c009818:	0c009965 	.word	0x0c009965
 c00981c:	0c009889 	.word	0x0c009889
 c009820:	0c009947 	.word	0x0c009947
 c009824:	0c0097d5 	.word	0x0c0097d5
 c009828:	0c0097d5 	.word	0x0c0097d5
 c00982c:	0c009987 	.word	0x0c009987
 c009830:	0c0097d5 	.word	0x0c0097d5
 c009834:	0c009889 	.word	0x0c009889
 c009838:	0c0097d5 	.word	0x0c0097d5
 c00983c:	0c0097d5 	.word	0x0c0097d5
 c009840:	0c00994f 	.word	0x0c00994f
 c009844:	680b      	ldr	r3, [r1, #0]
 c009846:	f104 0642 	add.w	r6, r4, #66	; 0x42
 c00984a:	1d1a      	adds	r2, r3, #4
 c00984c:	681b      	ldr	r3, [r3, #0]
 c00984e:	600a      	str	r2, [r1, #0]
 c009850:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 c009854:	2301      	movs	r3, #1
 c009856:	e0a3      	b.n	c0099a0 <_printf_i+0x1f4>
 c009858:	6825      	ldr	r5, [r4, #0]
 c00985a:	6808      	ldr	r0, [r1, #0]
 c00985c:	062e      	lsls	r6, r5, #24
 c00985e:	f100 0304 	add.w	r3, r0, #4
 c009862:	d50a      	bpl.n	c00987a <_printf_i+0xce>
 c009864:	6805      	ldr	r5, [r0, #0]
 c009866:	600b      	str	r3, [r1, #0]
 c009868:	2d00      	cmp	r5, #0
 c00986a:	da03      	bge.n	c009874 <_printf_i+0xc8>
 c00986c:	232d      	movs	r3, #45	; 0x2d
 c00986e:	426d      	negs	r5, r5
 c009870:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 c009874:	485e      	ldr	r0, [pc, #376]	; (c0099f0 <_printf_i+0x244>)
 c009876:	230a      	movs	r3, #10
 c009878:	e019      	b.n	c0098ae <_printf_i+0x102>
 c00987a:	f015 0f40 	tst.w	r5, #64	; 0x40
 c00987e:	6805      	ldr	r5, [r0, #0]
 c009880:	600b      	str	r3, [r1, #0]
 c009882:	bf18      	it	ne
 c009884:	b22d      	sxthne	r5, r5
 c009886:	e7ef      	b.n	c009868 <_printf_i+0xbc>
 c009888:	680b      	ldr	r3, [r1, #0]
 c00988a:	6825      	ldr	r5, [r4, #0]
 c00988c:	1d18      	adds	r0, r3, #4
 c00988e:	6008      	str	r0, [r1, #0]
 c009890:	0628      	lsls	r0, r5, #24
 c009892:	d501      	bpl.n	c009898 <_printf_i+0xec>
 c009894:	681d      	ldr	r5, [r3, #0]
 c009896:	e002      	b.n	c00989e <_printf_i+0xf2>
 c009898:	0669      	lsls	r1, r5, #25
 c00989a:	d5fb      	bpl.n	c009894 <_printf_i+0xe8>
 c00989c:	881d      	ldrh	r5, [r3, #0]
 c00989e:	2f6f      	cmp	r7, #111	; 0x6f
 c0098a0:	4853      	ldr	r0, [pc, #332]	; (c0099f0 <_printf_i+0x244>)
 c0098a2:	bf0c      	ite	eq
 c0098a4:	2308      	moveq	r3, #8
 c0098a6:	230a      	movne	r3, #10
 c0098a8:	2100      	movs	r1, #0
 c0098aa:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 c0098ae:	6866      	ldr	r6, [r4, #4]
 c0098b0:	2e00      	cmp	r6, #0
 c0098b2:	60a6      	str	r6, [r4, #8]
 c0098b4:	bfa2      	ittt	ge
 c0098b6:	6821      	ldrge	r1, [r4, #0]
 c0098b8:	f021 0104 	bicge.w	r1, r1, #4
 c0098bc:	6021      	strge	r1, [r4, #0]
 c0098be:	b90d      	cbnz	r5, c0098c4 <_printf_i+0x118>
 c0098c0:	2e00      	cmp	r6, #0
 c0098c2:	d04d      	beq.n	c009960 <_printf_i+0x1b4>
 c0098c4:	4616      	mov	r6, r2
 c0098c6:	fbb5 f1f3 	udiv	r1, r5, r3
 c0098ca:	fb03 5711 	mls	r7, r3, r1, r5
 c0098ce:	5dc7      	ldrb	r7, [r0, r7]
 c0098d0:	f806 7d01 	strb.w	r7, [r6, #-1]!
 c0098d4:	462f      	mov	r7, r5
 c0098d6:	460d      	mov	r5, r1
 c0098d8:	42bb      	cmp	r3, r7
 c0098da:	d9f4      	bls.n	c0098c6 <_printf_i+0x11a>
 c0098dc:	2b08      	cmp	r3, #8
 c0098de:	d10b      	bne.n	c0098f8 <_printf_i+0x14c>
 c0098e0:	6823      	ldr	r3, [r4, #0]
 c0098e2:	07df      	lsls	r7, r3, #31
 c0098e4:	d508      	bpl.n	c0098f8 <_printf_i+0x14c>
 c0098e6:	6923      	ldr	r3, [r4, #16]
 c0098e8:	6861      	ldr	r1, [r4, #4]
 c0098ea:	4299      	cmp	r1, r3
 c0098ec:	bfde      	ittt	le
 c0098ee:	2330      	movle	r3, #48	; 0x30
 c0098f0:	f806 3c01 	strble.w	r3, [r6, #-1]
 c0098f4:	f106 36ff 	addle.w	r6, r6, #4294967295
 c0098f8:	1b92      	subs	r2, r2, r6
 c0098fa:	6122      	str	r2, [r4, #16]
 c0098fc:	464b      	mov	r3, r9
 c0098fe:	aa03      	add	r2, sp, #12
 c009900:	4621      	mov	r1, r4
 c009902:	4640      	mov	r0, r8
 c009904:	f8cd a000 	str.w	sl, [sp]
 c009908:	f7ff fee0 	bl	c0096cc <_printf_common>
 c00990c:	3001      	adds	r0, #1
 c00990e:	d14c      	bne.n	c0099aa <_printf_i+0x1fe>
 c009910:	f04f 30ff 	mov.w	r0, #4294967295
 c009914:	b004      	add	sp, #16
 c009916:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c00991a:	4835      	ldr	r0, [pc, #212]	; (c0099f0 <_printf_i+0x244>)
 c00991c:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 c009920:	6823      	ldr	r3, [r4, #0]
 c009922:	680e      	ldr	r6, [r1, #0]
 c009924:	061f      	lsls	r7, r3, #24
 c009926:	f856 5b04 	ldr.w	r5, [r6], #4
 c00992a:	600e      	str	r6, [r1, #0]
 c00992c:	d514      	bpl.n	c009958 <_printf_i+0x1ac>
 c00992e:	07d9      	lsls	r1, r3, #31
 c009930:	bf44      	itt	mi
 c009932:	f043 0320 	orrmi.w	r3, r3, #32
 c009936:	6023      	strmi	r3, [r4, #0]
 c009938:	b91d      	cbnz	r5, c009942 <_printf_i+0x196>
 c00993a:	6823      	ldr	r3, [r4, #0]
 c00993c:	f023 0320 	bic.w	r3, r3, #32
 c009940:	6023      	str	r3, [r4, #0]
 c009942:	2310      	movs	r3, #16
 c009944:	e7b0      	b.n	c0098a8 <_printf_i+0xfc>
 c009946:	6823      	ldr	r3, [r4, #0]
 c009948:	f043 0320 	orr.w	r3, r3, #32
 c00994c:	6023      	str	r3, [r4, #0]
 c00994e:	2378      	movs	r3, #120	; 0x78
 c009950:	4828      	ldr	r0, [pc, #160]	; (c0099f4 <_printf_i+0x248>)
 c009952:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 c009956:	e7e3      	b.n	c009920 <_printf_i+0x174>
 c009958:	065e      	lsls	r6, r3, #25
 c00995a:	bf48      	it	mi
 c00995c:	b2ad      	uxthmi	r5, r5
 c00995e:	e7e6      	b.n	c00992e <_printf_i+0x182>
 c009960:	4616      	mov	r6, r2
 c009962:	e7bb      	b.n	c0098dc <_printf_i+0x130>
 c009964:	680b      	ldr	r3, [r1, #0]
 c009966:	6826      	ldr	r6, [r4, #0]
 c009968:	1d1d      	adds	r5, r3, #4
 c00996a:	6960      	ldr	r0, [r4, #20]
 c00996c:	600d      	str	r5, [r1, #0]
 c00996e:	0635      	lsls	r5, r6, #24
 c009970:	681b      	ldr	r3, [r3, #0]
 c009972:	d501      	bpl.n	c009978 <_printf_i+0x1cc>
 c009974:	6018      	str	r0, [r3, #0]
 c009976:	e002      	b.n	c00997e <_printf_i+0x1d2>
 c009978:	0671      	lsls	r1, r6, #25
 c00997a:	d5fb      	bpl.n	c009974 <_printf_i+0x1c8>
 c00997c:	8018      	strh	r0, [r3, #0]
 c00997e:	2300      	movs	r3, #0
 c009980:	4616      	mov	r6, r2
 c009982:	6123      	str	r3, [r4, #16]
 c009984:	e7ba      	b.n	c0098fc <_printf_i+0x150>
 c009986:	680b      	ldr	r3, [r1, #0]
 c009988:	1d1a      	adds	r2, r3, #4
 c00998a:	600a      	str	r2, [r1, #0]
 c00998c:	2100      	movs	r1, #0
 c00998e:	681e      	ldr	r6, [r3, #0]
 c009990:	6862      	ldr	r2, [r4, #4]
 c009992:	4630      	mov	r0, r6
 c009994:	f000 f8ca 	bl	c009b2c <memchr>
 c009998:	b108      	cbz	r0, c00999e <_printf_i+0x1f2>
 c00999a:	1b80      	subs	r0, r0, r6
 c00999c:	6060      	str	r0, [r4, #4]
 c00999e:	6863      	ldr	r3, [r4, #4]
 c0099a0:	6123      	str	r3, [r4, #16]
 c0099a2:	2300      	movs	r3, #0
 c0099a4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 c0099a8:	e7a8      	b.n	c0098fc <_printf_i+0x150>
 c0099aa:	6923      	ldr	r3, [r4, #16]
 c0099ac:	4632      	mov	r2, r6
 c0099ae:	4649      	mov	r1, r9
 c0099b0:	4640      	mov	r0, r8
 c0099b2:	47d0      	blx	sl
 c0099b4:	3001      	adds	r0, #1
 c0099b6:	d0ab      	beq.n	c009910 <_printf_i+0x164>
 c0099b8:	6823      	ldr	r3, [r4, #0]
 c0099ba:	079b      	lsls	r3, r3, #30
 c0099bc:	d413      	bmi.n	c0099e6 <_printf_i+0x23a>
 c0099be:	68e0      	ldr	r0, [r4, #12]
 c0099c0:	9b03      	ldr	r3, [sp, #12]
 c0099c2:	4298      	cmp	r0, r3
 c0099c4:	bfb8      	it	lt
 c0099c6:	4618      	movlt	r0, r3
 c0099c8:	e7a4      	b.n	c009914 <_printf_i+0x168>
 c0099ca:	2301      	movs	r3, #1
 c0099cc:	4632      	mov	r2, r6
 c0099ce:	4649      	mov	r1, r9
 c0099d0:	4640      	mov	r0, r8
 c0099d2:	47d0      	blx	sl
 c0099d4:	3001      	adds	r0, #1
 c0099d6:	d09b      	beq.n	c009910 <_printf_i+0x164>
 c0099d8:	3501      	adds	r5, #1
 c0099da:	68e3      	ldr	r3, [r4, #12]
 c0099dc:	9903      	ldr	r1, [sp, #12]
 c0099de:	1a5b      	subs	r3, r3, r1
 c0099e0:	42ab      	cmp	r3, r5
 c0099e2:	dcf2      	bgt.n	c0099ca <_printf_i+0x21e>
 c0099e4:	e7eb      	b.n	c0099be <_printf_i+0x212>
 c0099e6:	2500      	movs	r5, #0
 c0099e8:	f104 0619 	add.w	r6, r4, #25
 c0099ec:	e7f5      	b.n	c0099da <_printf_i+0x22e>
 c0099ee:	bf00      	nop
 c0099f0:	0c00ae11 	.word	0x0c00ae11
 c0099f4:	0c00ae22 	.word	0x0c00ae22

0c0099f8 <__sread>:
 c0099f8:	b510      	push	{r4, lr}
 c0099fa:	460c      	mov	r4, r1
 c0099fc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c009a00:	f000 f8a2 	bl	c009b48 <_read_r>
 c009a04:	2800      	cmp	r0, #0
 c009a06:	bfab      	itete	ge
 c009a08:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 c009a0a:	89a3      	ldrhlt	r3, [r4, #12]
 c009a0c:	181b      	addge	r3, r3, r0
 c009a0e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 c009a12:	bfac      	ite	ge
 c009a14:	6563      	strge	r3, [r4, #84]	; 0x54
 c009a16:	81a3      	strhlt	r3, [r4, #12]
 c009a18:	bd10      	pop	{r4, pc}

0c009a1a <__swrite>:
 c009a1a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c009a1e:	461f      	mov	r7, r3
 c009a20:	898b      	ldrh	r3, [r1, #12]
 c009a22:	4605      	mov	r5, r0
 c009a24:	460c      	mov	r4, r1
 c009a26:	05db      	lsls	r3, r3, #23
 c009a28:	4616      	mov	r6, r2
 c009a2a:	d505      	bpl.n	c009a38 <__swrite+0x1e>
 c009a2c:	2302      	movs	r3, #2
 c009a2e:	2200      	movs	r2, #0
 c009a30:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c009a34:	f000 f868 	bl	c009b08 <_lseek_r>
 c009a38:	89a3      	ldrh	r3, [r4, #12]
 c009a3a:	4632      	mov	r2, r6
 c009a3c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c009a40:	4628      	mov	r0, r5
 c009a42:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 c009a46:	81a3      	strh	r3, [r4, #12]
 c009a48:	463b      	mov	r3, r7
 c009a4a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 c009a4e:	f000 b817 	b.w	c009a80 <_write_r>

0c009a52 <__sseek>:
 c009a52:	b510      	push	{r4, lr}
 c009a54:	460c      	mov	r4, r1
 c009a56:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c009a5a:	f000 f855 	bl	c009b08 <_lseek_r>
 c009a5e:	1c43      	adds	r3, r0, #1
 c009a60:	89a3      	ldrh	r3, [r4, #12]
 c009a62:	bf15      	itete	ne
 c009a64:	6560      	strne	r0, [r4, #84]	; 0x54
 c009a66:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 c009a6a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 c009a6e:	81a3      	strheq	r3, [r4, #12]
 c009a70:	bf18      	it	ne
 c009a72:	81a3      	strhne	r3, [r4, #12]
 c009a74:	bd10      	pop	{r4, pc}

0c009a76 <__sclose>:
 c009a76:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c009a7a:	f000 b813 	b.w	c009aa4 <_close_r>
	...

0c009a80 <_write_r>:
 c009a80:	b538      	push	{r3, r4, r5, lr}
 c009a82:	4604      	mov	r4, r0
 c009a84:	4d06      	ldr	r5, [pc, #24]	; (c009aa0 <_write_r+0x20>)
 c009a86:	4608      	mov	r0, r1
 c009a88:	4611      	mov	r1, r2
 c009a8a:	2200      	movs	r2, #0
 c009a8c:	602a      	str	r2, [r5, #0]
 c009a8e:	461a      	mov	r2, r3
 c009a90:	f7ff f81a 	bl	c008ac8 <_write>
 c009a94:	1c43      	adds	r3, r0, #1
 c009a96:	d102      	bne.n	c009a9e <_write_r+0x1e>
 c009a98:	682b      	ldr	r3, [r5, #0]
 c009a9a:	b103      	cbz	r3, c009a9e <_write_r+0x1e>
 c009a9c:	6023      	str	r3, [r4, #0]
 c009a9e:	bd38      	pop	{r3, r4, r5, pc}
 c009aa0:	3003bed0 	.word	0x3003bed0

0c009aa4 <_close_r>:
 c009aa4:	b538      	push	{r3, r4, r5, lr}
 c009aa6:	2300      	movs	r3, #0
 c009aa8:	4d05      	ldr	r5, [pc, #20]	; (c009ac0 <_close_r+0x1c>)
 c009aaa:	4604      	mov	r4, r0
 c009aac:	4608      	mov	r0, r1
 c009aae:	602b      	str	r3, [r5, #0]
 c009ab0:	f000 fa18 	bl	c009ee4 <_close>
 c009ab4:	1c43      	adds	r3, r0, #1
 c009ab6:	d102      	bne.n	c009abe <_close_r+0x1a>
 c009ab8:	682b      	ldr	r3, [r5, #0]
 c009aba:	b103      	cbz	r3, c009abe <_close_r+0x1a>
 c009abc:	6023      	str	r3, [r4, #0]
 c009abe:	bd38      	pop	{r3, r4, r5, pc}
 c009ac0:	3003bed0 	.word	0x3003bed0

0c009ac4 <_fstat_r>:
 c009ac4:	b538      	push	{r3, r4, r5, lr}
 c009ac6:	2300      	movs	r3, #0
 c009ac8:	4d06      	ldr	r5, [pc, #24]	; (c009ae4 <_fstat_r+0x20>)
 c009aca:	4604      	mov	r4, r0
 c009acc:	4608      	mov	r0, r1
 c009ace:	4611      	mov	r1, r2
 c009ad0:	602b      	str	r3, [r5, #0]
 c009ad2:	f000 fa0f 	bl	c009ef4 <_fstat>
 c009ad6:	1c43      	adds	r3, r0, #1
 c009ad8:	d102      	bne.n	c009ae0 <_fstat_r+0x1c>
 c009ada:	682b      	ldr	r3, [r5, #0]
 c009adc:	b103      	cbz	r3, c009ae0 <_fstat_r+0x1c>
 c009ade:	6023      	str	r3, [r4, #0]
 c009ae0:	bd38      	pop	{r3, r4, r5, pc}
 c009ae2:	bf00      	nop
 c009ae4:	3003bed0 	.word	0x3003bed0

0c009ae8 <_isatty_r>:
 c009ae8:	b538      	push	{r3, r4, r5, lr}
 c009aea:	2300      	movs	r3, #0
 c009aec:	4d05      	ldr	r5, [pc, #20]	; (c009b04 <_isatty_r+0x1c>)
 c009aee:	4604      	mov	r4, r0
 c009af0:	4608      	mov	r0, r1
 c009af2:	602b      	str	r3, [r5, #0]
 c009af4:	f000 fa06 	bl	c009f04 <_isatty>
 c009af8:	1c43      	adds	r3, r0, #1
 c009afa:	d102      	bne.n	c009b02 <_isatty_r+0x1a>
 c009afc:	682b      	ldr	r3, [r5, #0]
 c009afe:	b103      	cbz	r3, c009b02 <_isatty_r+0x1a>
 c009b00:	6023      	str	r3, [r4, #0]
 c009b02:	bd38      	pop	{r3, r4, r5, pc}
 c009b04:	3003bed0 	.word	0x3003bed0

0c009b08 <_lseek_r>:
 c009b08:	b538      	push	{r3, r4, r5, lr}
 c009b0a:	4604      	mov	r4, r0
 c009b0c:	4d06      	ldr	r5, [pc, #24]	; (c009b28 <_lseek_r+0x20>)
 c009b0e:	4608      	mov	r0, r1
 c009b10:	4611      	mov	r1, r2
 c009b12:	2200      	movs	r2, #0
 c009b14:	602a      	str	r2, [r5, #0]
 c009b16:	461a      	mov	r2, r3
 c009b18:	f000 f9fc 	bl	c009f14 <_lseek>
 c009b1c:	1c43      	adds	r3, r0, #1
 c009b1e:	d102      	bne.n	c009b26 <_lseek_r+0x1e>
 c009b20:	682b      	ldr	r3, [r5, #0]
 c009b22:	b103      	cbz	r3, c009b26 <_lseek_r+0x1e>
 c009b24:	6023      	str	r3, [r4, #0]
 c009b26:	bd38      	pop	{r3, r4, r5, pc}
 c009b28:	3003bed0 	.word	0x3003bed0

0c009b2c <memchr>:
 c009b2c:	b2c9      	uxtb	r1, r1
 c009b2e:	4402      	add	r2, r0
 c009b30:	b510      	push	{r4, lr}
 c009b32:	4290      	cmp	r0, r2
 c009b34:	4603      	mov	r3, r0
 c009b36:	d101      	bne.n	c009b3c <memchr+0x10>
 c009b38:	2300      	movs	r3, #0
 c009b3a:	e003      	b.n	c009b44 <memchr+0x18>
 c009b3c:	781c      	ldrb	r4, [r3, #0]
 c009b3e:	3001      	adds	r0, #1
 c009b40:	428c      	cmp	r4, r1
 c009b42:	d1f6      	bne.n	c009b32 <memchr+0x6>
 c009b44:	4618      	mov	r0, r3
 c009b46:	bd10      	pop	{r4, pc}

0c009b48 <_read_r>:
 c009b48:	b538      	push	{r3, r4, r5, lr}
 c009b4a:	4604      	mov	r4, r0
 c009b4c:	4d06      	ldr	r5, [pc, #24]	; (c009b68 <_read_r+0x20>)
 c009b4e:	4608      	mov	r0, r1
 c009b50:	4611      	mov	r1, r2
 c009b52:	2200      	movs	r2, #0
 c009b54:	602a      	str	r2, [r5, #0]
 c009b56:	461a      	mov	r2, r3
 c009b58:	f000 f9e4 	bl	c009f24 <_read>
 c009b5c:	1c43      	adds	r3, r0, #1
 c009b5e:	d102      	bne.n	c009b66 <_read_r+0x1e>
 c009b60:	682b      	ldr	r3, [r5, #0]
 c009b62:	b103      	cbz	r3, c009b66 <_read_r+0x1e>
 c009b64:	6023      	str	r3, [r4, #0]
 c009b66:	bd38      	pop	{r3, r4, r5, pc}
 c009b68:	3003bed0 	.word	0x3003bed0

0c009b6c <__gnu_cmse_nonsecure_call>:
 c009b6c:	e92d 4fe0 	stmdb	sp!, {r5, r6, r7, r8, r9, sl, fp, lr}
 c009b70:	4627      	mov	r7, r4
 c009b72:	46a0      	mov	r8, r4
 c009b74:	46a1      	mov	r9, r4
 c009b76:	46a2      	mov	sl, r4
 c009b78:	46a3      	mov	fp, r4
 c009b7a:	46a4      	mov	ip, r4
 c009b7c:	ed2d 8b10 	vpush	{d8-d15}
 c009b80:	f04f 0500 	mov.w	r5, #0
 c009b84:	ec45 5b18 	vmov	d8, r5, r5
 c009b88:	ec45 5a19 	vmov	s18, s19, r5, r5
 c009b8c:	ec45 5a1a 	vmov	s20, s21, r5, r5
 c009b90:	ec45 5a1b 	vmov	s22, s23, r5, r5
 c009b94:	ec45 5a1c 	vmov	s24, s25, r5, r5
 c009b98:	ec45 5a1d 	vmov	s26, s27, r5, r5
 c009b9c:	ec45 5a1e 	vmov	s28, s29, r5, r5
 c009ba0:	ec45 5a1f 	vmov	s30, s31, r5, r5
 c009ba4:	eef1 5a10 	vmrs	r5, fpscr
 c009ba8:	f64f 7660 	movw	r6, #65376	; 0xff60
 c009bac:	f6c0 76ff 	movt	r6, #4095	; 0xfff
 c009bb0:	4035      	ands	r5, r6
 c009bb2:	eee1 5a10 	vmsr	fpscr, r5
 c009bb6:	f384 8800 	msr	CPSR_f, r4
 c009bba:	4625      	mov	r5, r4
 c009bbc:	4626      	mov	r6, r4
 c009bbe:	47a4      	blxns	r4
 c009bc0:	ecbd 8b10 	vpop	{d8-d15}
 c009bc4:	e8bd 8fe0 	ldmia.w	sp!, {r5, r6, r7, r8, r9, sl, fp, pc}

0c009bc8 <__aeabi_uldivmod>:
 c009bc8:	b953      	cbnz	r3, c009be0 <__aeabi_uldivmod+0x18>
 c009bca:	b94a      	cbnz	r2, c009be0 <__aeabi_uldivmod+0x18>
 c009bcc:	2900      	cmp	r1, #0
 c009bce:	bf08      	it	eq
 c009bd0:	2800      	cmpeq	r0, #0
 c009bd2:	bf1c      	itt	ne
 c009bd4:	f04f 31ff 	movne.w	r1, #4294967295
 c009bd8:	f04f 30ff 	movne.w	r0, #4294967295
 c009bdc:	f000 b980 	b.w	c009ee0 <__aeabi_idiv0>
 c009be0:	f1ad 0c08 	sub.w	ip, sp, #8
 c009be4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 c009be8:	f000 f806 	bl	c009bf8 <__udivmoddi4>
 c009bec:	f8dd e004 	ldr.w	lr, [sp, #4]
 c009bf0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c009bf4:	b004      	add	sp, #16
 c009bf6:	4770      	bx	lr

0c009bf8 <__udivmoddi4>:
 c009bf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c009bfc:	9d09      	ldr	r5, [sp, #36]	; 0x24
 c009bfe:	4604      	mov	r4, r0
 c009c00:	4688      	mov	r8, r1
 c009c02:	2b00      	cmp	r3, #0
 c009c04:	f040 8084 	bne.w	c009d10 <__udivmoddi4+0x118>
 c009c08:	428a      	cmp	r2, r1
 c009c0a:	4617      	mov	r7, r2
 c009c0c:	d943      	bls.n	c009c96 <__udivmoddi4+0x9e>
 c009c0e:	fab2 f282 	clz	r2, r2
 c009c12:	b142      	cbz	r2, c009c26 <__udivmoddi4+0x2e>
 c009c14:	f1c2 0020 	rsb	r0, r2, #32
 c009c18:	4091      	lsls	r1, r2
 c009c1a:	4097      	lsls	r7, r2
 c009c1c:	fa24 f000 	lsr.w	r0, r4, r0
 c009c20:	4094      	lsls	r4, r2
 c009c22:	ea40 0801 	orr.w	r8, r0, r1
 c009c26:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 c009c2a:	0c23      	lsrs	r3, r4, #16
 c009c2c:	fa1f fe87 	uxth.w	lr, r7
 c009c30:	fbb8 f6fc 	udiv	r6, r8, ip
 c009c34:	fb0c 8116 	mls	r1, ip, r6, r8
 c009c38:	fb06 f00e 	mul.w	r0, r6, lr
 c009c3c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 c009c40:	4298      	cmp	r0, r3
 c009c42:	d907      	bls.n	c009c54 <__udivmoddi4+0x5c>
 c009c44:	18fb      	adds	r3, r7, r3
 c009c46:	f106 31ff 	add.w	r1, r6, #4294967295
 c009c4a:	d202      	bcs.n	c009c52 <__udivmoddi4+0x5a>
 c009c4c:	4298      	cmp	r0, r3
 c009c4e:	f200 8131 	bhi.w	c009eb4 <__udivmoddi4+0x2bc>
 c009c52:	460e      	mov	r6, r1
 c009c54:	1a19      	subs	r1, r3, r0
 c009c56:	b2a3      	uxth	r3, r4
 c009c58:	fbb1 f0fc 	udiv	r0, r1, ip
 c009c5c:	fb0c 1110 	mls	r1, ip, r0, r1
 c009c60:	fb00 fe0e 	mul.w	lr, r0, lr
 c009c64:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 c009c68:	45a6      	cmp	lr, r4
 c009c6a:	d907      	bls.n	c009c7c <__udivmoddi4+0x84>
 c009c6c:	193c      	adds	r4, r7, r4
 c009c6e:	f100 33ff 	add.w	r3, r0, #4294967295
 c009c72:	d202      	bcs.n	c009c7a <__udivmoddi4+0x82>
 c009c74:	45a6      	cmp	lr, r4
 c009c76:	f200 811a 	bhi.w	c009eae <__udivmoddi4+0x2b6>
 c009c7a:	4618      	mov	r0, r3
 c009c7c:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 c009c80:	eba4 040e 	sub.w	r4, r4, lr
 c009c84:	2600      	movs	r6, #0
 c009c86:	b11d      	cbz	r5, c009c90 <__udivmoddi4+0x98>
 c009c88:	40d4      	lsrs	r4, r2
 c009c8a:	2300      	movs	r3, #0
 c009c8c:	e9c5 4300 	strd	r4, r3, [r5]
 c009c90:	4631      	mov	r1, r6
 c009c92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c009c96:	b902      	cbnz	r2, c009c9a <__udivmoddi4+0xa2>
 c009c98:	deff      	udf	#255	; 0xff
 c009c9a:	fab2 f282 	clz	r2, r2
 c009c9e:	2a00      	cmp	r2, #0
 c009ca0:	d152      	bne.n	c009d48 <__udivmoddi4+0x150>
 c009ca2:	1bcb      	subs	r3, r1, r7
 c009ca4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 c009ca8:	fa1f f887 	uxth.w	r8, r7
 c009cac:	2601      	movs	r6, #1
 c009cae:	0c21      	lsrs	r1, r4, #16
 c009cb0:	fbb3 fcfe 	udiv	ip, r3, lr
 c009cb4:	fb0e 301c 	mls	r0, lr, ip, r3
 c009cb8:	fb08 f90c 	mul.w	r9, r8, ip
 c009cbc:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 c009cc0:	4589      	cmp	r9, r1
 c009cc2:	d90b      	bls.n	c009cdc <__udivmoddi4+0xe4>
 c009cc4:	1879      	adds	r1, r7, r1
 c009cc6:	f10c 33ff 	add.w	r3, ip, #4294967295
 c009cca:	bf2c      	ite	cs
 c009ccc:	2001      	movcs	r0, #1
 c009cce:	2000      	movcc	r0, #0
 c009cd0:	4589      	cmp	r9, r1
 c009cd2:	d902      	bls.n	c009cda <__udivmoddi4+0xe2>
 c009cd4:	2800      	cmp	r0, #0
 c009cd6:	f000 80f0 	beq.w	c009eba <__udivmoddi4+0x2c2>
 c009cda:	469c      	mov	ip, r3
 c009cdc:	eba1 0109 	sub.w	r1, r1, r9
 c009ce0:	b2a3      	uxth	r3, r4
 c009ce2:	fbb1 f0fe 	udiv	r0, r1, lr
 c009ce6:	fb0e 1110 	mls	r1, lr, r0, r1
 c009cea:	fb08 f800 	mul.w	r8, r8, r0
 c009cee:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 c009cf2:	45a0      	cmp	r8, r4
 c009cf4:	d907      	bls.n	c009d06 <__udivmoddi4+0x10e>
 c009cf6:	193c      	adds	r4, r7, r4
 c009cf8:	f100 33ff 	add.w	r3, r0, #4294967295
 c009cfc:	d202      	bcs.n	c009d04 <__udivmoddi4+0x10c>
 c009cfe:	45a0      	cmp	r8, r4
 c009d00:	f200 80d2 	bhi.w	c009ea8 <__udivmoddi4+0x2b0>
 c009d04:	4618      	mov	r0, r3
 c009d06:	eba4 0408 	sub.w	r4, r4, r8
 c009d0a:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 c009d0e:	e7ba      	b.n	c009c86 <__udivmoddi4+0x8e>
 c009d10:	428b      	cmp	r3, r1
 c009d12:	d909      	bls.n	c009d28 <__udivmoddi4+0x130>
 c009d14:	2d00      	cmp	r5, #0
 c009d16:	f000 80be 	beq.w	c009e96 <__udivmoddi4+0x29e>
 c009d1a:	2600      	movs	r6, #0
 c009d1c:	e9c5 0100 	strd	r0, r1, [r5]
 c009d20:	4630      	mov	r0, r6
 c009d22:	4631      	mov	r1, r6
 c009d24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c009d28:	fab3 f683 	clz	r6, r3
 c009d2c:	2e00      	cmp	r6, #0
 c009d2e:	d14d      	bne.n	c009dcc <__udivmoddi4+0x1d4>
 c009d30:	428b      	cmp	r3, r1
 c009d32:	f0c0 80b3 	bcc.w	c009e9c <__udivmoddi4+0x2a4>
 c009d36:	4282      	cmp	r2, r0
 c009d38:	f240 80b0 	bls.w	c009e9c <__udivmoddi4+0x2a4>
 c009d3c:	4630      	mov	r0, r6
 c009d3e:	2d00      	cmp	r5, #0
 c009d40:	d0a6      	beq.n	c009c90 <__udivmoddi4+0x98>
 c009d42:	e9c5 4800 	strd	r4, r8, [r5]
 c009d46:	e7a3      	b.n	c009c90 <__udivmoddi4+0x98>
 c009d48:	4097      	lsls	r7, r2
 c009d4a:	f1c2 0320 	rsb	r3, r2, #32
 c009d4e:	fa01 f002 	lsl.w	r0, r1, r2
 c009d52:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 c009d56:	40d9      	lsrs	r1, r3
 c009d58:	fa24 f303 	lsr.w	r3, r4, r3
 c009d5c:	fa1f f887 	uxth.w	r8, r7
 c009d60:	4094      	lsls	r4, r2
 c009d62:	4303      	orrs	r3, r0
 c009d64:	fbb1 f0fe 	udiv	r0, r1, lr
 c009d68:	0c1e      	lsrs	r6, r3, #16
 c009d6a:	fb0e 1110 	mls	r1, lr, r0, r1
 c009d6e:	fb00 fc08 	mul.w	ip, r0, r8
 c009d72:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
 c009d76:	458c      	cmp	ip, r1
 c009d78:	d90e      	bls.n	c009d98 <__udivmoddi4+0x1a0>
 c009d7a:	1879      	adds	r1, r7, r1
 c009d7c:	f100 36ff 	add.w	r6, r0, #4294967295
 c009d80:	bf2c      	ite	cs
 c009d82:	f04f 0901 	movcs.w	r9, #1
 c009d86:	f04f 0900 	movcc.w	r9, #0
 c009d8a:	458c      	cmp	ip, r1
 c009d8c:	d903      	bls.n	c009d96 <__udivmoddi4+0x19e>
 c009d8e:	f1b9 0f00 	cmp.w	r9, #0
 c009d92:	f000 8096 	beq.w	c009ec2 <__udivmoddi4+0x2ca>
 c009d96:	4630      	mov	r0, r6
 c009d98:	eba1 010c 	sub.w	r1, r1, ip
 c009d9c:	b29b      	uxth	r3, r3
 c009d9e:	fbb1 f6fe 	udiv	r6, r1, lr
 c009da2:	fb0e 1116 	mls	r1, lr, r6, r1
 c009da6:	fb06 fc08 	mul.w	ip, r6, r8
 c009daa:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 c009dae:	458c      	cmp	ip, r1
 c009db0:	d907      	bls.n	c009dc2 <__udivmoddi4+0x1ca>
 c009db2:	1879      	adds	r1, r7, r1
 c009db4:	f106 33ff 	add.w	r3, r6, #4294967295
 c009db8:	d202      	bcs.n	c009dc0 <__udivmoddi4+0x1c8>
 c009dba:	458c      	cmp	ip, r1
 c009dbc:	f200 8088 	bhi.w	c009ed0 <__udivmoddi4+0x2d8>
 c009dc0:	461e      	mov	r6, r3
 c009dc2:	eba1 030c 	sub.w	r3, r1, ip
 c009dc6:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 c009dca:	e770      	b.n	c009cae <__udivmoddi4+0xb6>
 c009dcc:	f1c6 0720 	rsb	r7, r6, #32
 c009dd0:	fa03 f406 	lsl.w	r4, r3, r6
 c009dd4:	fa02 fc06 	lsl.w	ip, r2, r6
 c009dd8:	fa01 fe06 	lsl.w	lr, r1, r6
 c009ddc:	40fa      	lsrs	r2, r7
 c009dde:	fa20 f807 	lsr.w	r8, r0, r7
 c009de2:	40f9      	lsrs	r1, r7
 c009de4:	fa00 f306 	lsl.w	r3, r0, r6
 c009de8:	4322      	orrs	r2, r4
 c009dea:	ea48 040e 	orr.w	r4, r8, lr
 c009dee:	ea4f 4812 	mov.w	r8, r2, lsr #16
 c009df2:	ea4f 4e14 	mov.w	lr, r4, lsr #16
 c009df6:	fa1f f982 	uxth.w	r9, r2
 c009dfa:	fbb1 faf8 	udiv	sl, r1, r8
 c009dfe:	fb08 111a 	mls	r1, r8, sl, r1
 c009e02:	fb0a f009 	mul.w	r0, sl, r9
 c009e06:	ea4e 4e01 	orr.w	lr, lr, r1, lsl #16
 c009e0a:	4570      	cmp	r0, lr
 c009e0c:	d90e      	bls.n	c009e2c <__udivmoddi4+0x234>
 c009e0e:	eb12 0e0e 	adds.w	lr, r2, lr
 c009e12:	f10a 31ff 	add.w	r1, sl, #4294967295
 c009e16:	bf2c      	ite	cs
 c009e18:	f04f 0b01 	movcs.w	fp, #1
 c009e1c:	f04f 0b00 	movcc.w	fp, #0
 c009e20:	4570      	cmp	r0, lr
 c009e22:	d902      	bls.n	c009e2a <__udivmoddi4+0x232>
 c009e24:	f1bb 0f00 	cmp.w	fp, #0
 c009e28:	d04e      	beq.n	c009ec8 <__udivmoddi4+0x2d0>
 c009e2a:	468a      	mov	sl, r1
 c009e2c:	ebae 0e00 	sub.w	lr, lr, r0
 c009e30:	b2a4      	uxth	r4, r4
 c009e32:	fbbe f0f8 	udiv	r0, lr, r8
 c009e36:	fb08 ee10 	mls	lr, r8, r0, lr
 c009e3a:	fb00 f909 	mul.w	r9, r0, r9
 c009e3e:	ea44 4e0e 	orr.w	lr, r4, lr, lsl #16
 c009e42:	45f1      	cmp	r9, lr
 c009e44:	d907      	bls.n	c009e56 <__udivmoddi4+0x25e>
 c009e46:	eb12 0e0e 	adds.w	lr, r2, lr
 c009e4a:	f100 31ff 	add.w	r1, r0, #4294967295
 c009e4e:	d201      	bcs.n	c009e54 <__udivmoddi4+0x25c>
 c009e50:	45f1      	cmp	r9, lr
 c009e52:	d840      	bhi.n	c009ed6 <__udivmoddi4+0x2de>
 c009e54:	4608      	mov	r0, r1
 c009e56:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
 c009e5a:	ebae 0e09 	sub.w	lr, lr, r9
 c009e5e:	fba0 890c 	umull	r8, r9, r0, ip
 c009e62:	45ce      	cmp	lr, r9
 c009e64:	4641      	mov	r1, r8
 c009e66:	464c      	mov	r4, r9
 c009e68:	d302      	bcc.n	c009e70 <__udivmoddi4+0x278>
 c009e6a:	d106      	bne.n	c009e7a <__udivmoddi4+0x282>
 c009e6c:	4543      	cmp	r3, r8
 c009e6e:	d204      	bcs.n	c009e7a <__udivmoddi4+0x282>
 c009e70:	3801      	subs	r0, #1
 c009e72:	ebb8 010c 	subs.w	r1, r8, ip
 c009e76:	eb69 0402 	sbc.w	r4, r9, r2
 c009e7a:	b37d      	cbz	r5, c009edc <__udivmoddi4+0x2e4>
 c009e7c:	1a5a      	subs	r2, r3, r1
 c009e7e:	eb6e 0e04 	sbc.w	lr, lr, r4
 c009e82:	40f2      	lsrs	r2, r6
 c009e84:	fa0e f707 	lsl.w	r7, lr, r7
 c009e88:	fa2e f306 	lsr.w	r3, lr, r6
 c009e8c:	2600      	movs	r6, #0
 c009e8e:	4317      	orrs	r7, r2
 c009e90:	e9c5 7300 	strd	r7, r3, [r5]
 c009e94:	e6fc      	b.n	c009c90 <__udivmoddi4+0x98>
 c009e96:	462e      	mov	r6, r5
 c009e98:	4628      	mov	r0, r5
 c009e9a:	e6f9      	b.n	c009c90 <__udivmoddi4+0x98>
 c009e9c:	1a84      	subs	r4, r0, r2
 c009e9e:	eb61 0103 	sbc.w	r1, r1, r3
 c009ea2:	2001      	movs	r0, #1
 c009ea4:	4688      	mov	r8, r1
 c009ea6:	e74a      	b.n	c009d3e <__udivmoddi4+0x146>
 c009ea8:	3802      	subs	r0, #2
 c009eaa:	443c      	add	r4, r7
 c009eac:	e72b      	b.n	c009d06 <__udivmoddi4+0x10e>
 c009eae:	3802      	subs	r0, #2
 c009eb0:	443c      	add	r4, r7
 c009eb2:	e6e3      	b.n	c009c7c <__udivmoddi4+0x84>
 c009eb4:	3e02      	subs	r6, #2
 c009eb6:	443b      	add	r3, r7
 c009eb8:	e6cc      	b.n	c009c54 <__udivmoddi4+0x5c>
 c009eba:	f1ac 0c02 	sub.w	ip, ip, #2
 c009ebe:	4439      	add	r1, r7
 c009ec0:	e70c      	b.n	c009cdc <__udivmoddi4+0xe4>
 c009ec2:	3802      	subs	r0, #2
 c009ec4:	4439      	add	r1, r7
 c009ec6:	e767      	b.n	c009d98 <__udivmoddi4+0x1a0>
 c009ec8:	f1aa 0a02 	sub.w	sl, sl, #2
 c009ecc:	4496      	add	lr, r2
 c009ece:	e7ad      	b.n	c009e2c <__udivmoddi4+0x234>
 c009ed0:	3e02      	subs	r6, #2
 c009ed2:	4439      	add	r1, r7
 c009ed4:	e775      	b.n	c009dc2 <__udivmoddi4+0x1ca>
 c009ed6:	3802      	subs	r0, #2
 c009ed8:	4496      	add	lr, r2
 c009eda:	e7bc      	b.n	c009e56 <__udivmoddi4+0x25e>
 c009edc:	462e      	mov	r6, r5
 c009ede:	e6d7      	b.n	c009c90 <__udivmoddi4+0x98>

0c009ee0 <__aeabi_idiv0>:
 c009ee0:	4770      	bx	lr
 c009ee2:	bf00      	nop

0c009ee4 <_close>:
 c009ee4:	4b02      	ldr	r3, [pc, #8]	; (c009ef0 <_close+0xc>)
 c009ee6:	2258      	movs	r2, #88	; 0x58
 c009ee8:	f04f 30ff 	mov.w	r0, #4294967295
 c009eec:	601a      	str	r2, [r3, #0]
 c009eee:	4770      	bx	lr
 c009ef0:	3003bed0 	.word	0x3003bed0

0c009ef4 <_fstat>:
 c009ef4:	4b02      	ldr	r3, [pc, #8]	; (c009f00 <_fstat+0xc>)
 c009ef6:	2258      	movs	r2, #88	; 0x58
 c009ef8:	f04f 30ff 	mov.w	r0, #4294967295
 c009efc:	601a      	str	r2, [r3, #0]
 c009efe:	4770      	bx	lr
 c009f00:	3003bed0 	.word	0x3003bed0

0c009f04 <_isatty>:
 c009f04:	4b02      	ldr	r3, [pc, #8]	; (c009f10 <_isatty+0xc>)
 c009f06:	2258      	movs	r2, #88	; 0x58
 c009f08:	2000      	movs	r0, #0
 c009f0a:	601a      	str	r2, [r3, #0]
 c009f0c:	4770      	bx	lr
 c009f0e:	bf00      	nop
 c009f10:	3003bed0 	.word	0x3003bed0

0c009f14 <_lseek>:
 c009f14:	4b02      	ldr	r3, [pc, #8]	; (c009f20 <_lseek+0xc>)
 c009f16:	2258      	movs	r2, #88	; 0x58
 c009f18:	f04f 30ff 	mov.w	r0, #4294967295
 c009f1c:	601a      	str	r2, [r3, #0]
 c009f1e:	4770      	bx	lr
 c009f20:	3003bed0 	.word	0x3003bed0

0c009f24 <_read>:
 c009f24:	4b02      	ldr	r3, [pc, #8]	; (c009f30 <_read+0xc>)
 c009f26:	2258      	movs	r2, #88	; 0x58
 c009f28:	f04f 30ff 	mov.w	r0, #4294967295
 c009f2c:	601a      	str	r2, [r3, #0]
 c009f2e:	4770      	bx	lr
 c009f30:	3003bed0 	.word	0x3003bed0

0c009f34 <_sbrk>:
 c009f34:	4b04      	ldr	r3, [pc, #16]	; (c009f48 <_sbrk+0x14>)
 c009f36:	4602      	mov	r2, r0
 c009f38:	6819      	ldr	r1, [r3, #0]
 c009f3a:	b909      	cbnz	r1, c009f40 <_sbrk+0xc>
 c009f3c:	4903      	ldr	r1, [pc, #12]	; (c009f4c <_sbrk+0x18>)
 c009f3e:	6019      	str	r1, [r3, #0]
 c009f40:	6818      	ldr	r0, [r3, #0]
 c009f42:	4402      	add	r2, r0
 c009f44:	601a      	str	r2, [r3, #0]
 c009f46:	4770      	bx	lr
 c009f48:	3003bec0 	.word	0x3003bec0
 c009f4c:	3003d2d8 	.word	0x3003d2d8

0c009f50 <_exit>:
 c009f50:	e7fe      	b.n	c009f50 <_exit>
	...

0c009f54 <_init>:
 c009f54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c009f56:	bf00      	nop
 c009f58:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c009f5a:	bc08      	pop	{r3}
 c009f5c:	469e      	mov	lr, r3
 c009f5e:	4770      	bx	lr

0c009f60 <_fini>:
 c009f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c009f62:	bf00      	nop
 c009f64:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c009f66:	bc08      	pop	{r3}
 c009f68:	469e      	mov	lr, r3
 c009f6a:	4770      	bx	lr
 c009f6c:	464e495b 	.word	0x464e495b
 c009f70:	6e49205d 	.word	0x6e49205d
 c009f74:	61697469 	.word	0x61697469
 c009f78:	697a696c 	.word	0x697a696c
 c009f7c:	4220676e 	.word	0x4220676e
 c009f80:	4e20324c 	.word	0x4e20324c
 c009f84:	72612056 	.word	0x72612056
 c009f88:	3a206165 	.word	0x3a206165
 c009f8c:	776f5020 	.word	0x776f5020
 c009f90:	64207265 	.word	0x64207265
 c009f94:	2f6e776f 	.word	0x2f6e776f
 c009f98:	65736572 	.word	0x65736572
 c009f9c:	6f6e2074 	.word	0x6f6e2074
 c009fa0:	75732074 	.word	0x75732074
 c009fa4:	726f7070 	.word	0x726f7070
 c009fa8:	2e646574 	.word	0x2e646574
 c009fac:	000d2e2e 	.word	0x000d2e2e
 c009fb0:	5252455b 	.word	0x5252455b
 c009fb4:	6e49205d 	.word	0x6e49205d
 c009fb8:	42207469 	.word	0x42207469
 c009fbc:	4e20324c 	.word	0x4e20324c
 c009fc0:	65482056 	.word	0x65482056
 c009fc4:	72656461 	.word	0x72656461
 c009fc8:	65726120 	.word	0x65726120
 c009fcc:	46203a61 	.word	0x46203a61
 c009fd0:	656c6961 	.word	0x656c6961
 c009fd4:	5b000d64 	.word	0x5b000d64
 c009fd8:	5d464e49 	.word	0x5d464e49
 c009fdc:	696e4920 	.word	0x696e4920
 c009fe0:	4c422074 	.word	0x4c422074
 c009fe4:	564e2032 	.word	0x564e2032
 c009fe8:	61654820 	.word	0x61654820
 c009fec:	20726564 	.word	0x20726564
 c009ff0:	61657261 	.word	0x61657261
 c009ff4:	6f44203a 	.word	0x6f44203a
 c009ff8:	000d656e 	.word	0x000d656e
 c009ffc:	464e495b 	.word	0x464e495b
 c00a000:	6e49205d 	.word	0x6e49205d
 c00a004:	61697469 	.word	0x61697469
 c00a008:	697a696c 	.word	0x697a696c
 c00a00c:	4220676e 	.word	0x4220676e
 c00a010:	4e20324c 	.word	0x4e20324c
 c00a014:	6f432056 	.word	0x6f432056
 c00a018:	65746e75 	.word	0x65746e75
 c00a01c:	000d7372 	.word	0x000d7372
 c00a020:	464e495b 	.word	0x464e495b
 c00a024:	6843205d 	.word	0x6843205d
 c00a028:	696b6365 	.word	0x696b6365
 c00a02c:	4220676e 	.word	0x4220676e
 c00a030:	4e20324c 	.word	0x4e20324c
 c00a034:	72612056 	.word	0x72612056
 c00a038:	000d6165 	.word	0x000d6165
 c00a03c:	464e495b 	.word	0x464e495b
 c00a040:	6843205d 	.word	0x6843205d
 c00a044:	696b6365 	.word	0x696b6365
 c00a048:	4220676e 	.word	0x4220676e
 c00a04c:	4e20324c 	.word	0x4e20324c
 c00a050:	72612056 	.word	0x72612056
 c00a054:	68206165 	.word	0x68206165
 c00a058:	65646165 	.word	0x65646165
 c00a05c:	5b000d72 	.word	0x5b000d72
 c00a060:	5d525245 	.word	0x5d525245
 c00a064:	6f725720 	.word	0x6f725720
 c00a068:	4220676e 	.word	0x4220676e
 c00a06c:	4e20324c 	.word	0x4e20324c
 c00a070:	72412056 	.word	0x72412056
 c00a074:	68206165 	.word	0x68206165
 c00a078:	65646165 	.word	0x65646165
 c00a07c:	5b000d72 	.word	0x5b000d72
 c00a080:	5d464e49 	.word	0x5d464e49
 c00a084:	65684320 	.word	0x65684320
 c00a088:	6e696b63 	.word	0x6e696b63
 c00a08c:	4c422067 	.word	0x4c422067
 c00a090:	564e2032 	.word	0x564e2032
 c00a094:	756f4320 	.word	0x756f4320
 c00a098:	7265746e 	.word	0x7265746e
 c00a09c:	6e6f6320 	.word	0x6e6f6320
 c00a0a0:	74736973 	.word	0x74736973
 c00a0a4:	79636e65 	.word	0x79636e65
 c00a0a8:	455b000d 	.word	0x455b000d
 c00a0ac:	205d5252 	.word	0x205d5252
 c00a0b0:	4320564e 	.word	0x4320564e
 c00a0b4:	746e756f 	.word	0x746e756f
 c00a0b8:	4e207265 	.word	0x4e207265
 c00a0bc:	6320746f 	.word	0x6320746f
 c00a0c0:	69736e6f 	.word	0x69736e6f
 c00a0c4:	6e657473 	.word	0x6e657473
 c00a0c8:	64252074 	.word	0x64252074
 c00a0cc:	5b000a0d 	.word	0x5b000a0d
 c00a0d0:	5d464e49 	.word	0x5d464e49
 c00a0d4:	6e6f4320 	.word	0x6e6f4320
 c00a0d8:	74736973 	.word	0x74736973
 c00a0dc:	20746e65 	.word	0x20746e65
 c00a0e0:	20324c42 	.word	0x20324c42
 c00a0e4:	4320564e 	.word	0x4320564e
 c00a0e8:	746e756f 	.word	0x746e756f
 c00a0ec:	25207265 	.word	0x25207265
 c00a0f0:	3d202064 	.word	0x3d202064
 c00a0f4:	25783020 	.word	0x25783020
 c00a0f8:	000a0d78 	.word	0x000a0d78
 c00a0fc:	5252455b 	.word	0x5252455b
 c00a100:	6e49205d 	.word	0x6e49205d
 c00a104:	42207469 	.word	0x42207469
 c00a108:	4e20324c 	.word	0x4e20324c
 c00a10c:	6f632056 	.word	0x6f632056
 c00a110:	65746e75 	.word	0x65746e75
 c00a114:	3a207372 	.word	0x3a207372
 c00a118:	69614620 	.word	0x69614620
 c00a11c:	0d64656c 	.word	0x0d64656c
 c00a120:	4e495b00 	.word	0x4e495b00
 c00a124:	49205d46 	.word	0x49205d46
 c00a128:	2074696e 	.word	0x2074696e
 c00a12c:	20324c42 	.word	0x20324c42
 c00a130:	6320564e 	.word	0x6320564e
 c00a134:	746e756f 	.word	0x746e756f
 c00a138:	20737265 	.word	0x20737265
 c00a13c:	30206f74 	.word	0x30206f74
 c00a140:	44203a20 	.word	0x44203a20
 c00a144:	0d656e6f 	.word	0x0d656e6f
 c00a148:	4e495b00 	.word	0x4e495b00
 c00a14c:	42205d46 	.word	0x42205d46
 c00a150:	4e20324c 	.word	0x4e20324c
 c00a154:	72412056 	.word	0x72412056
 c00a158:	49206165 	.word	0x49206165
 c00a15c:	6974696e 	.word	0x6974696e
 c00a160:	7a696c61 	.word	0x7a696c61
 c00a164:	3a206465 	.word	0x3a206465
 c00a168:	776f5020 	.word	0x776f5020
 c00a16c:	44207265 	.word	0x44207265
 c00a170:	2f6e776f 	.word	0x2f6e776f
 c00a174:	65736572 	.word	0x65736572
 c00a178:	75732074 	.word	0x75732074
 c00a17c:	726f7070 	.word	0x726f7070
 c00a180:	0d646574 	.word	0x0d646574
 c00a184:	00          	.byte	0x00
 c00a185:	5b          	.byte	0x5b
 c00a186:	4e49      	.short	0x4e49
 c00a188:	43205d46 	.word	0x43205d46
 c00a18c:	746e756f 	.word	0x746e756f
 c00a190:	25207265 	.word	0x25207265
 c00a194:	65732064 	.word	0x65732064
 c00a198:	6f742074 	.word	0x6f742074
 c00a19c:	25783020 	.word	0x25783020
 c00a1a0:	000a0d78 	.word	0x000a0d78
 c00a1a4:	5252455b 	.word	0x5252455b
 c00a1a8:	7245205d 	.word	0x7245205d
 c00a1ac:	20726f72 	.word	0x20726f72
 c00a1b0:	6c696877 	.word	0x6c696877
 c00a1b4:	6f642065 	.word	0x6f642065
 c00a1b8:	656c6275 	.word	0x656c6275
 c00a1bc:	6e6f6320 	.word	0x6e6f6320
 c00a1c0:	6c6f7274 	.word	0x6c6f7274
 c00a1c4:	676e696c 	.word	0x676e696c
 c00a1c8:	616d6920 	.word	0x616d6920
 c00a1cc:	20736567 	.word	0x20736567
 c00a1d0:	696c6176 	.word	0x696c6176
 c00a1d4:	69746164 	.word	0x69746164
 c00a1d8:	000d6e6f 	.word	0x000d6e6f
 c00a1dc:	5252455b 	.word	0x5252455b
 c00a1e0:	7245205d 	.word	0x7245205d
 c00a1e4:	20726f72 	.word	0x20726f72
 c00a1e8:	6c696877 	.word	0x6c696877
 c00a1ec:	6e692065 	.word	0x6e692065
 c00a1f0:	61697469 	.word	0x61697469
 c00a1f4:	697a696c 	.word	0x697a696c
 c00a1f8:	4620676e 	.word	0x4620676e
 c00a1fc:	6873616c 	.word	0x6873616c
 c00a200:	746e4920 	.word	0x746e4920
 c00a204:	61667265 	.word	0x61667265
 c00a208:	000d6563 	.word	0x000d6563

0c00a20c <DriverVersion>:
 c00a20c:	02020203                                ....

0c00a210 <TFM_Driver_USART0>:
 c00a210:	0c002211 0c002231 0c0022ad 0c002235     ."..1"..."..5"..
 c00a220:	0c002239 0c002289 0c002269 0c00223f     9"..."..i"..?"..
 c00a230:	0c002245 0c002373 0c00224b 0c00224f     E"..s#..K"..O"..
 c00a240:	0c00236d 0c00225b                       m#..["..

0c00a248 <ARM_FLASH0_DEV_DATA>:
 c00a248:	00000000 00000080 00001000 00000800     ................
 c00a258:	00000008 000000ff                       ........

0c00a260 <DriverVersion>:
 c00a260:	01000201                                ....

0c00a264 <TFM_Driver_FLASH0>:
 c00a264:	0c002379 0c002399 0c0023d1 0c00239d     y#...#...#...#..
 c00a274:	0c0023a1 0c00259d 0c002411 0c0024e5     .#...%...$...$..
 c00a284:	0c0023b7 0c0023bd 0c0023c9              .#...#...#..

0c00a290 <AHBPrescTable>:
	...
 c00a298:	04030201 09080706                       ........

0c00a2a0 <APBPrescTable>:
 c00a2a0:	00000000 04030201                       ........

0c00a2a8 <MSIRangeTable>:
 c00a2a8:	000186a0 00030d40 00061a80 000c3500     ....@........5..
 c00a2b8:	000f4240 001e8480 003d0900 007a1200     @B........=...z.
 c00a2c8:	00f42400 016e3600 01e84800 02dc6c00     .$...6n..H...l..
	...
 c00a2e8:	5252455b 6e55205d 65707865 64657463     [ERR] Unexpected
 c00a2f8:	6c617620 66206575 5420726f 204e455a      value for TZEN 
 c00a308:	756c6176 5b000d65 5d525245 656e5520     value..[ERR] Une
 c00a318:	63657078 20646574 756c6176 6f662065     xpected value fo
 c00a328:	75642072 62206c61 206b6e61 666e6f63     r dual bank conf
 c00a338:	72756769 6f697461 5b000d6e 5d525245     iguration..[ERR]
 c00a348:	656e5520 63657078 20646574 756c6176      Unexpected valu
 c00a358:	6f662065 77732072 62207061 206b6e61     e for swap bank 
 c00a368:	666e6f63 72756769 6f697461 5b000d6e     configuration..[
 c00a378:	5d464e49 6f6f4220 64644174 78302072     INF] BootAddr 0x
 c00a388:	0a0d7825 52455b00 55205d52 7078656e     %x...[ERR] Unexp
 c00a398:	65746365 61762064 2065756c 20726f66     ected value for 
 c00a3a8:	20434553 544f4f42 64644120 73736572     SEC BOOT Address
 c00a3b8:	495b000d 205d464e 4b4e4142 73203120     ..[INF] BANK 1 s
 c00a3c8:	72756365 6c662065 20687361 2c64255b     ecure flash [%d,
 c00a3d8:	5d642520 4f203a20 255b2042 25202c64      %d] : OB [%d, %
 c00a3e8:	0a0d5d64 52455b00 55205d52 7078656e     d]...[ERR] Unexp
 c00a3f8:	65746365 61762064 2065756c 20726f66     ected value for 
 c00a408:	75636573 66206572 6873616c 6f727020     secure flash pro
 c00a418:	74636574 3a6e6f69 74657320 736d7720     tection: set wms
 c00a428:	0d316365 4e495b00 42205d46 204b4e41     ec1..[INF] BANK 
 c00a438:	65732032 65727563 616c6620 5b206873     2 secure flash [
 c00a448:	202c6425 205d6425 424f203a 64255b20     %d, %d] : OB [%d
 c00a458:	6425202c 000a0d5d 464e495b 4142205d     , %d]...[INF] BA
 c00a468:	31204b4e 616c6620 77206873 65746972     NK 1 flash write
 c00a478:	6f727020 74636574 206e6f69 2c64255b      protection [%d,
 c00a488:	5d642520 4f203a20 255b2042 25202c64      %d] : OB [%d, %
 c00a498:	0a0d5d64 52455b00 55205d52 7078656e     d]...[ERR] Unexp
 c00a4a8:	65746365 61762064 2065756c 20726f66     ected value for 
 c00a4b8:	74697277 72702065 6365746f 6e6f6974     write protection
 c00a4c8:	73203a20 77207465 0d317072 4e495b00      : set wrp1..[IN
 c00a4d8:	42205d46 204b4e41 6c662032 20687361     F] BANK 2 flash 
 c00a4e8:	74697277 72702065 6365746f 6e6f6974     write protection
 c00a4f8:	64255b20 6425202c 203a205d 5b20424f      [%d, %d] : OB [
 c00a508:	202c6425 0d5d6425 455b000a 205d5252     %d, %d]...[ERR] 
 c00a518:	78656e55 74636570 76206465 65756c61     Unexpected value
 c00a528:	726f6620 69727720 70206574 65746f72      for write prote
 c00a538:	6f697463 203a206e 20746573 32707277     ction : set wrp2
 c00a548:	495b000d 205d464e 4b4e4142 73203120     ..[INF] BANK 1 s
 c00a558:	72756365 73752065 66207265 6873616c     ecure user flash
 c00a568:	64255b20 6425202c 203a205d 5b20424f      [%d, %d] : OB [
 c00a578:	202c6425 0d5d6425 455b000a 205d5252     %d, %d]...[ERR] 
 c00a588:	78656e55 74636570 76206465 65756c61     Unexpected value
 c00a598:	726f6620 63657320 20657275 72657375      for secure user
 c00a5a8:	616c6620 70206873 65746f72 6f697463      flash protectio
 c00a5b8:	203a206e 20746573 31706468 455b000d     n : set hdp1..[E
 c00a5c8:	205d5252 78656e55 74636570 76206465     RR] Unexpected v
 c00a5d8:	65756c61 726f6620 41525320 4520324d     alue for SRAM2 E
 c00a5e8:	45534152 20746120 65736552 5b000d74     RASE at Reset..[
 c00a5f8:	5d525245 656e5520 63657078 20646574     ERR] Unexpected 
 c00a608:	756c6176 6f662065 424f2072 50445220     value for OB RDP
 c00a618:	206f7420 676f7270 0d6d6172 52455b00      to program..[ER
 c00a628:	55205d52 7078656e 65746365 61762064     R] Unexpected va
 c00a638:	2065756c 20726f66 6b6e6162 4f203220     lue for bank 2 O
 c00a648:	52572042 52412050 74204145 7270206f     B WRP AREA to pr
 c00a658:	6172676f 5b000d6d 5d525245 656e5520     ogram..[ERR] Une
 c00a668:	63657078 20646574 756c6176 6f662065     xpected value fo
 c00a678:	61622072 31206b6e 20424f20 20505257     r bank 1 OB WRP 
 c00a688:	41455241 206f7420 676f7270 0d6d6172     AREA to program.
 c00a698:	52455b00 45205d52 726f7272 69687720     .[ERR] Error whi
 c00a6a8:	7320656c 69747465 4f20676e 61422042     le setting OB Ba
 c00a6b8:	20316b6e 666e6f63 000d6769 5252455b     nk1 config..[ERR
 c00a6c8:	7245205d 20726f72 6c696877 78652065     ] Error while ex
 c00a6d8:	74756365 206e6f69 4c5f424f 636e7561     ecution OB_Launc
 c00a6e8:	5b000d68 5d464e49 6f6f4220 636f4c74     h..[INF] BootLoc
 c00a6f8:	7830206b 0a0d7825 52455b00 55205d52     k 0x%x...[ERR] U
 c00a708:	7078656e 65746365 61762064 2065756c     nexpected value 
 c00a718:	20726f66 20434553 544f4f42 434f4c20     for SEC BOOT LOC
 c00a728:	5b000d4b 5d464e49 50445220 6576654c     K..[INF] RDPLeve
 c00a738:	7830206c 28207825 78257830 000a0d29     l 0x%x (0x%x)...
 c00a748:	5252455b 6e55205d 65707865 64657463     [ERR] Unexpected
 c00a758:	6c617620 66206575 5220726f 6c205044      value for RDP l
 c00a768:	6c657665 495b000d 205d464e 676f7250     evel..[INF] Prog
 c00a778:	6d6d6172 20676e69 20504452 25206f74     ramming RDP to %
 c00a788:	000a0d78 464e495b 6e55205d 67756c70     x...[INF] Unplug
 c00a798:	756c502f 756a2067 7265706d 35504a20     /Plug jumper JP5
 c00a7a8:	44492820 000d2944 5252455b 7245205d      (IDD)..[ERR] Er
 c00a7b8:	20726f72 6c696877 65732065 6e697474     ror while settin
 c00a7c8:	44522067 656c2050 0d6c6576               g RDP level..

0c00a7d5 <CSWTCH.58>:
 c00a7d5:	                                         ...

0c00a7d8 <CSWTCH.59>:
 c00a7d8:	10101000 10101004 10101002               ..............

0c00a7e6 <UARTPrescTable>:
 c00a7e6:	00020001 00060004 000a0008 0010000c     ................
 c00a7f6:	00400020 01000080 32414853 53003635      .@.....SHA256.S
 c00a806:	32324148                                 HA224.

0c00a80c <mbedtls_sha224_info>:
 c00a80c:	00000005 0c00a805 0000001c 00000040     ............@...
 c00a81c:	0c006a8d 0c006a89 0c006a85 0c006a79     .j...j...j..yj..
 c00a82c:	0c006a61 0c006a4f 0c006a4b 0c006a47     aj..Oj..Kj..Gj..

0c00a83c <mbedtls_sha256_info>:
 c00a83c:	00000006 0c00a7fe 00000020 00000040     ........ ...@...
 c00a84c:	0c006a93 0c006a89 0c006a85 0c006a7f     .j...j...j...j..
 c00a85c:	0c006a61 0c006a4f 0c006a4b 0c006a47     aj..Oj..Kj..Gj..
 c00a86c:	464e495b 7825205d 7825202c 7825202c     [INF] %x, %x, %x
 c00a87c:	7825202c 7825202c 7825202c 25202c20     , %x, %x, %x , %
 c00a88c:	252c2078 0a0d2c78                        x ,%x,...

0c00a895 <pss_zeros>:
	...
 c00a89d:	464e495b 6f43205d 6f72746e 6e696c6c     [INF] Controllin
 c00a8ad:	6e612067 636e6520 74707972 70206465     g an encrypted p
 c00a8bd:	616d6972 69207972 6567616d 495b000d     rimary image..[I
 c00a8cd:	205d464e 64616548 64207265 2073656f     NF] Header does 
 c00a8dd:	20746f6e 20746966 61206e69 6f6c6220     not fit in a blo
 c00a8ed:	73206b63 3a657a69 746f6e20 70757320     ck size: not sup
 c00a8fd:	74726f70 77206465 20687469 4255434d     ported with MCUB
 c00a90d:	5f544f4f 4d495250 5f595241 594c4e4f     OOT_PRIMARY_ONLY
 c00a91d:	495b000d 205d464e 69726576 73207966     ..[INF] verify s
 c00a92d:	6b206769 69207965 64252064 5b000a0d     ig key id %d...[
 c00a93d:	5d464e49 67697320 7574616e 4f206572     INF] signature O
 c00a94d:	5b000d4b 5d464e49 72657620 20796669     K..[INF] verify 
 c00a95d:	6e756f63 20726574 20642520 25207825     counter  %d %x %
 c00a96d:	000a0d78 464e495b 6f63205d 65746e75     x...[INF] counte
 c00a97d:	25202072 203a2064 0a0d6b6f 4e495b00     r  %d : ok...[IN
 c00a98d:	75205d46 7078656e 65746365 4c542064     F] unexpected TL
 c00a99d:	78252056 000a0d20 464e495b 6869205d     V %x ...[INF] ih
 c00a9ad:	616c665f 25207367 000a0d78 4e52575b     _flags %x...[WRN
 c00a9bd:	6146205d 64656c69 61657220 676e6964     ] Failed reading
 c00a9cd:	63657320 73726f74 4f42203b 4d5f544f      sectors; BOOT_M
 c00a9dd:	495f5841 535f474d 4f544345 253d5352     AX_IMG_SECTORS=%
 c00a9ed:	202d2064 206f6f74 6c616d73 0a0d3f6c     d - too small?..
 c00a9fd:	52575b00 46205d4e 656c6961 65722064     .[WRN] Failed re
 c00aa0d:	6e696461 6d692067 20656761 64616568     ading image head
 c00aa1d:	3b737265 616d4920 253d6567 000a0d75     ers; Image=%u...
 c00aa2d:	4e52575b 6d49205d 20656761 69206425     [WRN] Image %d i
 c00aa3d:	6e652073 70797263 20646574 5b000a0d     s encrypted ...[
 c00aa4d:	5d4e5257 616d4920 25206567 73692064     WRN] Image %d is
 c00aa5d:	736e6920 6c6c6174 0d206465 495b000a      installed ...[I
 c00aa6d:	205d464e 67616d49 70752065 64617267     NF] Image upgrad
 c00aa7d:	72702065 72616d69 6c732079 2d20746f     e primary slot -
 c00aa8d:	7270203e 72616d69 6c732079 000d746f     > primary slot..
 c00aa9d:	464e495b 6f50205d 20726577 2066666f     [INF] Power off 
 c00aaad:	20746f6e 70707573 6574726f 5b000d64     not supported..[
 c00aabd:	5d464e49 616f4c20 6e452064 70797263     INF] Load Encryp
 c00aacd:	20646574 0d79654b 4e495b00 43205d46     ted Key..[INF] C
 c00aadd:	6979706f 7420676e 70206568 616d6972     opying the prima
 c00aaed:	73207972 20746f6c 74206f74 70206568     ry slot to the p
 c00aafd:	616d6972 73207972 3a746f6c 25783020     rimary slot: 0x%
 c00ab0d:	79622078 0d736574 455b000a 205d5252     x bytes...[ERR] 
 c00ab1d:	75636553 79746972 756f6320 7265746e     Security counter
 c00ab2d:	64707520 20657461 6c696166 61206465      update failed a
 c00ab3d:	72657466 616d6920 75206567 61726770     fter image upgra
 c00ab4d:	0d2e6564 69727000 7972616d 52455b00     de...primary.[ER
 c00ab5d:	49205d52 6567616d 206e6920 20656874     R] Image in the 
 c00ab6d:	73207325 20746f6c 6e207369 7620746f     %s slot is not v
 c00ab7d:	64696c61 000a0d21 5252455b 6553205d     alid!...[ERR] Se
 c00ab8d:	69727563 63207974 746e756f 75207265     curity counter u
 c00ab9d:	74616470 61662065 64656c69 74666120     pdate failed aft
 c00abad:	69207265 6567616d 6c617620 74616469     er image validat
 c00abbd:	2e6e6f69 495b000d 205d464e 72617453     ion...[INF] Star
 c00abcd:	676e6974 6f6f6220 616f6c74 0d726564     ting bootloader.
 c00abdd:	52455b00 45205d52 726f7272 69687720     .[ERR] Error whi
 c00abed:	6920656c 6974696e 7a696c61 20676e69     le initializing 
 c00abfd:	20656874 75636573 79746972 756f6320     the security cou
 c00ac0d:	7265746e 455b000d 205d5252 62616e55     nter..[ERR] Unab
 c00ac1d:	7420656c 6966206f 6220646e 61746f6f     le to find boota
 c00ac2d:	20656c62 67616d69 5b000d65 5d464e49     ble image..[INF]
 c00ac3d:	6f6f4220 616f6c74 20726564 69616863      Bootloader chai
 c00ac4d:	616f6c6e 64612064 73657264 666f2073     nload address of
 c00ac5d:	74657366 7830203a 0a0d7825 4e495b00     fset: 0x%x...[IN
 c00ac6d:	4a205d46 69706d75 7420676e 6874206f     F] Jumping to th
 c00ac7d:	69662065 20747372 67616d69 6c732065     e first image sl
 c00ac8d:	000d746f 5252455b 7245205d 20726f72     ot..[ERR] Error 
 c00ac9d:	6c696877 6e752065 74696e69 696c6169     while uninitiali
 c00acad:	676e697a 616c4620 49206873 7265746e     zing Flash Inter
 c00acbd:	65636166 455b000d 205d5252 6576654e     face..[ERR] Neve
 c00accd:	68732072 646c756f 74656720 72656820     r should get her
 c00acdd:	                                         e..

0c00ace0 <flash_map>:
 c00ace0:	00000001 0000d000 0006b000 5252455b     ............[ERR
 c00acf0:	6e69205d 696c6176 6c662064 20687361     ] invalid flash 
 c00ad00:	25204449 65203b64 63657078 20646574     ID %d; expected 
 c00ad10:	0a0d6425 52455b00 69205d52 6c61766e     %d...[ERR] inval
 c00ad20:	66206469 6873616c 65726120 44492061     id flash area ID
 c00ad30:	455b000d 205d5252 61657261 20642520     ..[ERR] area %d 
 c00ad40:	657a6973 25783020 6f6e2078 69642074     size 0x%x not di
 c00ad50:	69736976 20656c62 73207962 6f746365     visible by secto
 c00ad60:	69732072 3020657a 0d782578 455b000a     r size 0x%x...[E
 c00ad70:	205d5252 73616c66 72612068 25206165     RR] flash area %
 c00ad80:	65732064 726f7463 756f6320 6f20746e     d sector count o
 c00ad90:	66726576 0d776f6c 0000000a              verflow.....

0c00ad9c <_global_impure_ptr>:
 c00ad9c:	30030098                                ...0

0c00ada0 <__sf_fake_stderr>:
	...

0c00adc0 <__sf_fake_stdin>:
	...

0c00ade0 <__sf_fake_stdout>:
	...
 c00ae00:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
 c00ae10:	32313000 36353433 41393837 45444342     .0123456789ABCDE
 c00ae20:	31300046 35343332 39383736 64636261     F.0123456789abcd
 c00ae30:	00006665                                ef..

0c00ae34 <__EH_FRAME_BEGIN__>:
 c00ae34:	00000000                                ....
